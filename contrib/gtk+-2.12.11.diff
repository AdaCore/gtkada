2008-10-30  Arnaud Charlet  <charlet@adacore.com>

	* gdk/quartz/gdkkeys-quartz.c: Use new input API, since old keyboard
	API is not available for x86-64.

2008-10-28  Arnaud Charlet  <charlet@adacore.com>

	* configure: Force disabling of mediaLib support, too painful to
	support.

2000-04-17  Arnaud Charlet  <charlet@adacore.com>

	* tests/Makefile.in: Fix makefile when there is no C++ compiler
	available.

2006-02-23  Arnaud Charlet  <charlet@adacore.com>

	* gdk/x11/gdkasync.c: #define ANSICPP on Solaris, to work around
	bug in X11/Xmd.h on Solaris 8.

2003-11-27  Arnaud Charlet  <charlet@adacore.com>

	* gtk/gtktextview.c (incremental_validate_callback): Increase amount
	of characters validated at each call, this gives a better behavior
	when loading big files.
	Submitted at http://bugzilla.gnome.org/show_bug.cgi?id=332057

--- gtk/gtktextview.c.old	2006-02-17 16:11:04.000000000 +0100
+++ gtk/gtktextview.c	2006-02-20 17:08:54.691581240 +0100
@@ -3273,7 +3273,7 @@ incremental_validate_callback (gpointer 
   
   DV(g_print(G_STRLOC"\n"));
   
-  gtk_text_layout_validate (text_view->layout, 2000);
+  gtk_text_layout_validate (text_view->layout, 20000);
 
   gtk_text_view_update_adjustments (text_view);
   
--- gdk/x11/gdkasync.c.old	Thu Feb 23 11:30:46 2006
+++ gdk/x11/gdkasync.c	Thu Feb 23 11:48:14 2006
@@ -47,6 +47,11 @@ in this Software without prior written a
 #ifdef NEED_XIPROTO_H_FOR_XREPLY
 #include <X11/extensions/XIproto.h>
 #endif
+
+#if defined (sun) && defined (__SVR4)
+#define ANSICPP
+#endif
+
 #include <X11/Xlibint.h>
 #include "gdkasync.h"
 #include "gdkx.h"
--- tests/Makefile.in.old	2008-04-18 12:32:24.431430164 +0200
+++ tests/Makefile.in	2008-04-18 12:34:07.692529898 +0200
@@ -363,3 +363,2 @@ noinst_PROGRAMS = \
 	autotestfilechooser		\
-	autotestkeywords		\
 	floatingtest			\
@@ -697,3 +696,2 @@ CONFIG_CLEAN_FILES =
 @HAVE_CXX_FALSE@@USE_X11_TRUE@	autotestfilechooser$(EXEEXT) \
-@HAVE_CXX_FALSE@@USE_X11_TRUE@	autotestkeywords$(EXEEXT) \
 @HAVE_CXX_FALSE@@USE_X11_TRUE@	floatingtest$(EXEEXT) \
@@ -762,3 +760,2 @@ CONFIG_CLEAN_FILES =
 @HAVE_CXX_FALSE@@USE_X11_FALSE@	autotestfilechooser$(EXEEXT) \
-@HAVE_CXX_FALSE@@USE_X11_FALSE@	autotestkeywords$(EXEEXT) \
 @HAVE_CXX_FALSE@@USE_X11_FALSE@	floatingtest$(EXEEXT) \
@@ -825,3 +822,2 @@ CONFIG_CLEAN_FILES =
 @HAVE_CXX_TRUE@@USE_X11_TRUE@	autotestfilechooser$(EXEEXT) \
-@HAVE_CXX_TRUE@@USE_X11_TRUE@	autotestkeywords$(EXEEXT) \
 @HAVE_CXX_TRUE@@USE_X11_TRUE@	floatingtest$(EXEEXT) \
@@ -887,7 +883,5 @@ CONFIG_CLEAN_FILES =
 @HAVE_CXX_TRUE@@USE_X11_TRUE@	testtooltips$(EXEEXT) \
-@HAVE_CXX_TRUE@@USE_X11_TRUE@	testvolumebutton$(EXEEXT) \
-@HAVE_CXX_TRUE@@USE_X11_TRUE@	autotestkeywords$(EXEEXT)
+@HAVE_CXX_TRUE@@USE_X11_TRUE@	testvolumebutton$(EXEEXT)
 @HAVE_CXX_TRUE@@USE_X11_FALSE@noinst_PROGRAMS = \
 @HAVE_CXX_TRUE@@USE_X11_FALSE@	autotestfilechooser$(EXEEXT) \
-@HAVE_CXX_TRUE@@USE_X11_FALSE@	autotestkeywords$(EXEEXT) \
 @HAVE_CXX_TRUE@@USE_X11_FALSE@	floatingtest$(EXEEXT) \
@@ -951,4 +945,3 @@ CONFIG_CLEAN_FILES =
 @HAVE_CXX_TRUE@@USE_X11_FALSE@	testtooltips$(EXEEXT) \
-@HAVE_CXX_TRUE@@USE_X11_FALSE@	testvolumebutton$(EXEEXT) \
-@HAVE_CXX_TRUE@@USE_X11_FALSE@	autotestkeywords$(EXEEXT)
+@HAVE_CXX_TRUE@@USE_X11_FALSE@	testvolumebutton$(EXEEXT)
 PROGRAMS = $(noinst_PROGRAMS)
--- configure.old	2008-10-28 04:44:14.140371000 -0400
+++ configure	2008-10-28 04:45:48.426989000 -0400
@@ -29542,6 +29542,8 @@ else
   use_mlib=no
 fi
 
+use_mlib=no
+
 if test $use_mlib = yes; then
     cat >>confdefs.h <<\_ACEOF
 #define USE_MEDIALIB 1
--- gdk/quartz/gdkkeys-quartz.c.old	2008-10-30 14:31:20.000000000 +0100
+++ gdk/quartz/gdkkeys-quartz.c	2008-10-30 15:31:09.000000000 +0100
@@ -61,7 +61,7 @@
 
 static GdkKeymap *default_keymap = NULL;
 
-static KeyboardLayoutRef current_layout = NULL;
+static TISInputSourceRef current_layout = NULL;
 
 /* This is a table of all keyvals. Each keycode gets KEYVALS_PER_KEYCODE entries.
  * TThere is 1 keyval per modifier (Nothing, Shift, Alt, Shift+Alt);
@@ -179,114 +179,32 @@ const static struct {
 static void
 maybe_update_keymap (void)
 {
-  KeyboardLayoutRef new_layout;
+  TISInputSourceRef new_layout;
 
-  KLGetCurrentKeyboardLayout (&new_layout);
+  new_layout = TISCopyCurrentKeyboardLayoutInputSource ();
 
   if (new_layout != current_layout)
     {
       guint *p;
       int i;
 
-      KeyboardLayoutKind layout_kind;
-      
       g_free (keyval_array);
       keyval_array = g_new0 (guint, NUM_KEYCODES * KEYVALS_PER_KEYCODE);
-
-      /* Get the layout kind */
-      KLGetKeyboardLayoutProperty (new_layout, kKLKind, (const void **)&layout_kind);
-
-      /* 8-bit-only keyabord layout */
-      if (layout_kind == kKLKCHRKind)
+      
 	{ 
-	  const void *chr_data;
+	  const void *chr_data = NULL;
 	  
 	  /* Get chr data */
-	  KLGetKeyboardLayoutProperty (new_layout, kKLKCHRData, (const void **)&chr_data);
+	  CFDataRef currentKeyLayoutDataRef = (CFDataRef) TISGetInputSourceProperty (new_layout, kTISPropertyUnicodeKeyLayoutData);
+	  if (currentKeyLayoutDataRef)
+	    chr_data = CFDataGetBytePtr (currentKeyLayoutDataRef);
 	  
-	  for (i = 0; i < NUM_KEYCODES; i++) 
+	  if (chr_data == NULL)
 	    {
-	      int j;
-	      UInt32 modifiers[] = {0, shiftKey, optionKey, shiftKey | optionKey};
-
-	      p = keyval_array + i * KEYVALS_PER_KEYCODE;
-	      
-	      for (j = 0; j < KEYVALS_PER_KEYCODE; j++)
-		{
-		  UInt32 c, state = 0;
-		  UInt16 key_code;
-		  UniChar uc;
-		  
-		  key_code = modifiers[j] | i;
-		  c = KeyTranslate (chr_data, key_code, &state);
-
-		  if (state != 0)
-		    {
-		      UInt32 state2 = 0;
-		      c = KeyTranslate (chr_data, key_code | 128, &state2);
-		    }
-
-		  if (c != 0 && c != 0x10)
-		    {
-		      int k;
-		      gboolean found = FALSE;
-
-		      /* FIXME: some keyboard layouts (e.g. Russian) use
-                       * a different 8-bit character set. We should
-                       * check for this. Not a serious problem, because
-		       * most (all?) of these layouts also have a
-		       * uchr version. 
-		       */
-		      uc = macroman2ucs (c);
-
-		      for (k = 0; k < G_N_ELEMENTS (special_ucs_table); k++) 
-			{
-			  if (special_ucs_table[k].ucs_value == uc)
-			    {
-			      p[j] = special_ucs_table[k].keyval;
-			      found = TRUE;
-			      break;
-			    }
-			}
-		      
-		      /* Special-case shift-tab since GTK+ expects
-		       * GDK_ISO_Left_Tab for that. 
-		       */
-		      if (found && p[j] == GDK_Tab && modifiers[j] == shiftKey) 
-			p[j] = GDK_ISO_Left_Tab;
-
-		      if (!found)
-                        {
-                          guint tmp;
-                          
-                          tmp = gdk_unicode_to_keyval (uc);
-                          if (tmp != (uc | 0x01000000))
-                            p[j] = tmp;
-                          else
-                            p[j] = 0;
-                        }
-		    }
-		}
-	      
-	      if (p[3] == p[2])
-		p[3] = 0;
-	      if (p[2] == p[1])
-		p[2] = 0;
-	      if (p[1] == p[0])
-		p[1] = 0;
-	      if (p[0] == p[2] && 
-		  p[1] == p[3])
-		p[2] = p[3] = 0;
+	      g_error ("cannot get keyboard layout data");
+	      return;
 	    }
-	}
-      /* unicode keyboard layout */
-      else if (layout_kind == kKLKCHRuchrKind || layout_kind == kKLuchrKind)
-	{ 
-	  const void *chr_data;
-	  
-	  /* Get chr data */
-	  KLGetKeyboardLayoutProperty (new_layout, kKLuchrData, (const void **)&chr_data);
-	  
+
 	  for (i = 0; i < NUM_KEYCODES; i++) 
 	    {
 	      int j;
@@ -362,11 +280,6 @@ maybe_update_keymap (void)
 		p[2] = p[3] = 0;
 	    }
 	}
-      else
-	{
-	  g_error ("unknown type of keyboard layout (neither KCHR nor uchr)"
-	           " - not supported right now");
-	}
 
       for (i = 0; i < G_N_ELEMENTS (known_keys); i++)
 	{
