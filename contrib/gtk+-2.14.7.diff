2009-09-19  Arnaud Charlet  <charlet@adacore.com>

	* gtk/gtktreemodel.c (gtk_tree_model_row_has_child_toggled): Replace
	g_return_if_fail by explicit check, since path may legitimately
	be NULL (I918-021).

2009-01-12  Nicolas Setton  <setton@adacore.com>

	* gtktreeview.c (gtk_tree_view_enter_notify): Do not react to
	 crossing events.
	(gtk_tree_view_leave_notify): Likewise.
        Prevents unwanted side-effects of synth-crossing. (I106-018)

2009-01-06  Nicolas Setton  <setton@adacore.com>

	* gtk/gtktreeview.c (gtk_tree_view_enter_notify): Put kludge to
	work around Gtk+ bug in handling of keyboard keys+focus events in
	tree view (HC15-032).

2008-10-30  Arnaud Charlet  <charlet@adacore.com>

	* gdk/quartz/gdkkeys-quartz.c: Use new input API, since old keyboard
	API is not available for x86-64.
	Submitted at http://bugzilla.gnome.org/show_bug.cgi?id=558586
	Committed on Gtk+ trunk on 2008-11-06

2006-02-23  Arnaud Charlet  <charlet@adacore.com>

	* gdk/x11/gdkasync.c: #define ANSICPP on Solaris, to work around
	bug in X11/Xmd.h on Solaris 8.

2003-11-27  Arnaud Charlet  <charlet@adacore.com>

	* gtk/gtktextview.c (incremental_validate_callback): Increase amount
	of characters validated at each call, this gives a better behavior
	when loading big files.
	Submitted at http://bugzilla.gnome.org/show_bug.cgi?id=332057

--- gtk/gtktextview.c.old	2006-02-17 16:11:04.000000000 +0100
+++ gtk/gtktextview.c	2006-02-20 17:08:54.691581240 +0100
@@ -3273,7 +3273,7 @@ incremental_validate_callback (gpointer 
   
   DV(g_print(G_STRLOC"\n"));
   
-  gtk_text_layout_validate (text_view->layout, 2000);
+  gtk_text_layout_validate (text_view->layout, 20000);
 
   gtk_text_view_update_adjustments (text_view);
   
--- gdk/x11/gdkasync.c.old	Thu Feb 23 11:30:46 2006
+++ gdk/x11/gdkasync.c	Thu Feb 23 11:48:14 2006
@@ -47,6 +47,11 @@ in this Software without prior written a
 #ifdef NEED_XIPROTO_H_FOR_XREPLY
 #include <X11/extensions/XIproto.h>
 #endif
+
+#if defined (sun) && defined (__SVR4)
+#define ANSICPP
+#endif
+
 #include <X11/Xlibint.h>
 #include "gdkasync.h"
 #include "gdkx.h"
--- gdk/quartz/gdkkeys-quartz.c.old	2008-10-30 14:31:20.000000000 +0100
+++ gdk/quartz/gdkkeys-quartz.c	2008-10-30 15:31:09.000000000 +0100
@@ -61,7 +61,7 @@
 
 static GdkKeymap *default_keymap = NULL;
 
-static KeyboardLayoutRef current_layout = NULL;
+static TISInputSourceRef current_layout = NULL;
 
 /* This is a table of all keyvals. Each keycode gets KEYVALS_PER_KEYCODE entries.
  * TThere is 1 keyval per modifier (Nothing, Shift, Alt, Shift+Alt);
@@ -179,114 +179,32 @@ const static struct {
 static void
 maybe_update_keymap (void)
 {
-  KeyboardLayoutRef new_layout;
+  TISInputSourceRef new_layout;
 
-  KLGetCurrentKeyboardLayout (&new_layout);
+  new_layout = TISCopyCurrentKeyboardLayoutInputSource ();
 
   if (new_layout != current_layout)
     {
       guint *p;
       int i;
 
-      KeyboardLayoutKind layout_kind;
-      
       g_free (keyval_array);
       keyval_array = g_new0 (guint, NUM_KEYCODES * KEYVALS_PER_KEYCODE);
-
-      /* Get the layout kind */
-      KLGetKeyboardLayoutProperty (new_layout, kKLKind, (const void **)&layout_kind);
-
-      /* 8-bit-only keyabord layout */
-      if (layout_kind == kKLKCHRKind)
+      
 	{ 
-	  const void *chr_data;
+	  const void *chr_data = NULL;
 	  
 	  /* Get chr data */
-	  KLGetKeyboardLayoutProperty (new_layout, kKLKCHRData, (const void **)&chr_data);
+	  CFDataRef currentKeyLayoutDataRef = (CFDataRef) TISGetInputSourceProperty (new_layout, kTISPropertyUnicodeKeyLayoutData);
+	  if (currentKeyLayoutDataRef)
+	    chr_data = CFDataGetBytePtr (currentKeyLayoutDataRef);
 	  
-	  for (i = 0; i < NUM_KEYCODES; i++) 
+	  if (chr_data == NULL)
 	    {
-	      int j;
-	      UInt32 modifiers[] = {0, shiftKey, optionKey, shiftKey | optionKey};
-
-	      p = keyval_array + i * KEYVALS_PER_KEYCODE;
-	      
-	      for (j = 0; j < KEYVALS_PER_KEYCODE; j++)
-		{
-		  UInt32 c, state = 0;
-		  UInt16 key_code;
-		  UniChar uc;
-		  
-		  key_code = modifiers[j] | i;
-		  c = KeyTranslate (chr_data, key_code, &state);
-
-		  if (state != 0)
-		    {
-		      UInt32 state2 = 0;
-		      c = KeyTranslate (chr_data, key_code | 128, &state2);
-		    }
-
-		  if (c != 0 && c != 0x10)
-		    {
-		      int k;
-		      gboolean found = FALSE;
-
-		      /* FIXME: some keyboard layouts (e.g. Russian) use
-                       * a different 8-bit character set. We should
-                       * check for this. Not a serious problem, because
-		       * most (all?) of these layouts also have a
-		       * uchr version. 
-		       */
-		      uc = macroman2ucs (c);
-
-		      for (k = 0; k < G_N_ELEMENTS (special_ucs_table); k++) 
-			{
-			  if (special_ucs_table[k].ucs_value == uc)
-			    {
-			      p[j] = special_ucs_table[k].keyval;
-			      found = TRUE;
-			      break;
-			    }
-			}
-		      
-		      /* Special-case shift-tab since GTK+ expects
-		       * GDK_ISO_Left_Tab for that. 
-		       */
-		      if (found && p[j] == GDK_Tab && modifiers[j] == shiftKey) 
-			p[j] = GDK_ISO_Left_Tab;
-
-		      if (!found)
-                        {
-                          guint tmp;
-                          
-                          tmp = gdk_unicode_to_keyval (uc);
-                          if (tmp != (uc | 0x01000000))
-                            p[j] = tmp;
-                          else
-                            p[j] = 0;
-                        }
-		    }
-		}
-	      
-	      if (p[3] == p[2])
-		p[3] = 0;
-	      if (p[2] == p[1])
-		p[2] = 0;
-	      if (p[1] == p[0])
-		p[1] = 0;
-	      if (p[0] == p[2] && 
-		  p[1] == p[3])
-		p[2] = p[3] = 0;
+	      g_error ("cannot get keyboard layout data");
+	      return;
 	    }
-	}
-      /* unicode keyboard layout */
-      else if (layout_kind == kKLKCHRuchrKind || layout_kind == kKLuchrKind)
-	{ 
-	  const void *chr_data;
-	  
-	  /* Get chr data */
-	  KLGetKeyboardLayoutProperty (new_layout, kKLuchrData, (const void **)&chr_data);
-	  
+
 	  for (i = 0; i < NUM_KEYCODES; i++) 
 	    {
 	      int j;
@@ -362,11 +280,6 @@ maybe_update_keymap (void)
 		p[2] = p[3] = 0;
 	    }
 	}
-      else
-	{
-	  g_error ("unknown type of keyboard layout (neither KCHR nor uchr)"
-	           " - not supported right now");
-	}
 
       for (i = 0; i < G_N_ELEMENTS (known_keys); i++)
 	{
--- gtk/gtktreeview.c.old	2008-11-24 07:35:35.000000000 +0100
+++ gtk/gtktreeview.c	2009-01-06 15:14:25.171875000 +0100
@@ -5459,6 +5459,9 @@ gtk_tree_view_enter_notify (GtkWidget   
   if (tree_view->priv->tree == NULL)
     return FALSE;
 
+  if (event->y == 0)
+    return FALSE;
+
   /* find the node internally */
   new_y = TREE_WINDOW_Y_TO_RBTREE_Y(tree_view, event->y);
   if (new_y < 0)
--- gtk/gtktreeview.c.orig	2009-01-12 11:49:09.000000000 +0100
+++ gtk/gtktreeview.c	2009-01-12 15:44:05.000000000 +0100
@@ -5461,6 +5461,12 @@ gtk_tree_view_enter_notify (GtkWidget   
   GtkRBNode *node;
   gint new_y;
 
+  if (event->mode == GDK_CROSSING_GRAB 
+      || event->mode == GDK_CROSSING_NORMAL
+      || event->mode == GDK_CROSSING_GTK_GRAB
+      || event->mode == GDK_CROSSING_GTK_UNGRAB)
+    return TRUE;
+
   /* Sanity check it */
   if (event->window != tree_view->priv->bin_window)
     return FALSE;
@@ -5487,7 +5493,10 @@ gtk_tree_view_leave_notify (GtkWidget   
 {
   GtkTreeView *tree_view;
 
-  if (event->mode == GDK_CROSSING_GRAB)
+  if (event->mode == GDK_CROSSING_GRAB 
+      || event->mode == GDK_CROSSING_NORMAL
+      || event->mode == GDK_CROSSING_GTK_GRAB
+      || event->mode == GDK_CROSSING_GTK_UNGRAB)
     return TRUE;
 
   tree_view = GTK_TREE_VIEW (widget);
--- gtk/gtktreemodel.c.old	2009-09-19 12:03:49.804000000 +0200
+++ gtk/gtktreemodel.c	2009-09-19 12:41:00.954000000 +0200
@@ -1512,8 +1512,11 @@ gtk_tree_model_row_has_child_toggled (Gt
 				      GtkTreeIter  *iter)
 {
   g_return_if_fail (GTK_IS_TREE_MODEL (tree_model));
-  g_return_if_fail (path != NULL);
-  g_return_if_fail (iter != NULL);
+
+  if (path == NULL)
+    return;
+  if (iter == NULL)
+    return;
 
   g_signal_emit (tree_model, tree_model_signals[ROW_HAS_CHILD_TOGGLED], 0, path, iter);
 }
