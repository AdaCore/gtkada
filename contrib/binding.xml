<?xml version="1.0"?>

<!--  This file overrides parts of the .gir files. -->

<GIR xmlns:gir="http://www.gtk.org/introspection/core/1.0"
     xmlns:c="http://www.gtk.org/introspection/c/1.0">

   <!-- ################################################
        Gtk.Aspect_Frame
        ################################################-->

   <package id="Gtk.Aspect_Frame">
      <doc testgtk="create_frame.adb.adb"
           group="Layout Containers">
A Gtk_Aspect_Frame is the same type of widget as a frame, but it
constrains its child to a specific aspect ratio between its width
and its height.

This ratio can either be given explicitly by the user, or chosen from the
widget's initial size request (might be different from the one if was
actually given).
      </doc>
     <parameter name="self" ada="Aspect_Frame"/>
     <method id="gtkada_GtkAspectFrame_get_xalign" bind="True"/>
     <method id="gtkada_GtkAspectFrame_get_yalign" bind="True"/>
     <method id="gtkada_GtkAspectFrame_get_ratio" bind="True"/>
     <method id="gtk_aspect_frame_new">
       <parameter name="label" default='""' empty_maps_to_null="True" />
     </method>
   </package>

   <!-- ###################################################
        Gtk.Button
        ###################################################-->
   <package id="Gtk.Button">
      <doc screenshot="gtk-button"
           group="Buttons and Toggles"
           testgtk="create_buttons.adb">
This package implements a general button widget. This button can
be clicked on by the user to start any action.
This button does not have multiple states, it can just be temporarily
pressed while the mouse is on it, but does not keep its pressed state.

The gtk+ sources provide the following drawing that explains the role of
the various spacings that can be set for a button:
      </doc>
      <parameter name="self" ada="Button"/>
      <method id="gtk_button_new" bind="False"/>
      <method id="gtk_button_new_with_label" ada="Gtk_New" >
         <parameter name="label" default='""' empty_maps_to_null="True"/>
      </method>
   </package>

   <!-- ################################################
        Gtk.EventBox
        ################################################-->

   <package id="Gtk.Event_Box">
      <doc group="Layout Containers">
This widget is a container that catches events for its child when its
child does not have its own window (like a Gtk_Scrolled_Window or a
Gtk_Label for instance).
Some widgets in GtkAda do not have their own window, and thus can not
directly get events from the server. The Gtk_Event_Box widget can be
used to force its child to receive events anyway.

For instance, this widget is used internally in a Gtk_Combo_Box so that
the application can change the cursor when the mouse is in the popup
window. In that case, it contains a frame, that itself contains the
scrolled window of the popup.
      </doc>
     <parameter name="self" ada="Event_Box"/>
     <method id="gtk_event_box_new">
         <doc>
Create a new box.

The box's child can then be set using the Gtk.Container.Add function.
         </doc>
     </method>
   </package>

   <!-- ###################################################
        Gtk.Frame
        ###################################################-->
   <package id="Gtk.Frame">
      <doc screenshot="gtk-frame" testgtk="create_frame.adb"
           group="Ornaments">
A Gtk_Frame is a simple border than can be added to any widget or
group of widget to enhance its visual aspect.
Optionally, a frame can have a title.

This is a very convenient widget to visually group related widgets (like
groups of buttons for instance), possibly with a title to explain the
purpose of this group.

A Gtk_Frame has only one child, so you have to put a container like for
instance a Gtk_Box inside if you want the frame to surround multiple
widgets.
      </doc>
      <parameter name="self" ada="Frame"/>

      <method id="gtk_frame_new">
         <parameter name="label" default='""' empty_maps_to_null="True" />
      </method>
   </package>

   <!-- ################################################
        Gtk.Label
        ################################################-->

   <package id="Gtk.Label">
      <doc screenshot="gtk-label" testgtk="create_label.adb"
           group="Display widgets">
A Gtk_Label is a light widget associated with some text you want
to display on the screen. You can change the text dynamically if
needed.

The text can be on multiple lines if you separate each line with
the ASCII.LF character. However, this is not the recommended way
to display long texts (see the Gtk_Text widget instead).

== Mnemonics ==

Labels may contain mnemonics. Mnemonics are underlined characters in the
label, used for keyboard navigation. Mnemonics are created by providing
string with an underscore before the mnemonic character, such as "_File",
to the functions gtk_new_with_mnemonic or set_text_with_mnemonic().

Mnemonics automatically activate any activatable widget the label is
inside, such as a Gtk_Button; if the label is not inside the mnemonic's
target widget, you have to tell the label about the target using
set_mnemonic_widget(). For instance:
    declare
       Button : Gtk_Button;
       Label  : Gtk_Label;
    begin
       Gtk_New (Button);
       Gtk_New_With_Mnemonic (Label, "_File");
       Add (Button, Label);
    end;
However, there exists a convenience function in Gtk.Button to create such
a button already.

== Markup ==

To make it easy to format text in a label (changing colors, fonts, etc.),
label text can be provided in a simple markup format. Here's how to create
a label with a small font:
     Gtk_New (Label, "&lt;small&gt;hello&lt;/small&gt;");

The markup must be valid, and &lt;&gt;&amp; characters must be escaped with
&amp;lt; &amp;gt; and &amp;amp;

Markup strings are just a convenient way to set the Pango_Attr_List on
label; Set_Attributes() may be a simpler way to set attributes in some
cases. Be careful though; Pango_Attr_List tends to cause
internationalization problems, unless you're applying attributes to the
entire string (i.e. unless you set the range of each attribute to [0,
G_MAXINT)). The reason is that specifying the start_index and end_index for
a Pango_Attribute requires knowledge of the exact string being displayed,
so translations will cause problems.

== Selectable labels ==

Labels can be made selectable with Set_Selectable. Selectable
labels allow the user to copy the label contents to the clipboard. Only
should be made selectable.
      </doc>

      <parameter name="self" ada="Label"/>
      <method id="gtk_label_new">
         <parameter name="str" default='""'/>
      </method>
      <method id="gtk_label_get" bind="false"/>
      <method id="gtk_label_select_region">
         <parameter name="start_offset" default="-1"/>
         <parameter name="end_offset" default="-1"/>
      </method>
      <method id="gtk_label_get_selection_bounds"
         return_as_param="Has_Selection"/>
      <method id="gtk_label_set_pattern">
         <doc>
Change the underlines pattern.

Pattern is a simple string made of underscore and space characters,
matching the ones in the string. GtkAda will underline every letter
that matches an underscore.

An empty string disables the underlines.

example: If the text is FooBarBaz and the Pattern is "___   ___"
then both "Foo" and "Baz" will be underlined, but not "Bar".
         </doc>
      </method>
   </package>

   <!-- ################################################
        Gtk.Paned
        ################################################-->

   <package id="Gtk.Paned">
      <doc screenshot="gtk-paned" testgtk="create_paned.adb"
           group="Layout container">
A Gtk_Paned is a container that organizes its two children either
horizontally or vertically.
The initial size allocated to the children depends on the size
they request. However, the user has the possibility to interactively
move a separation bar between the two to enlarge one of the children,
while at the same time shrinking the second one.
The bar can be moved by clicking with the mouse on a small cursor
displayed in the bar, and then dragging the mouse.

No additional decoration is provided around the children.

Each child has two parameters, Resize and Shrink.

If Shrink is True, then the widget can be made smaller than its
requisition size by the user. Set this to False if you want to
set a minimum size.

if Resize is True, this means that the child accepts to be resized, and
will not require any size. Thus, the size allocated to it will be
the total size allocated to the container minus the size requested by
the other child.
If Resize is False, the child should ask for a specific size, which it
will get. The other child will be resized accordingly.
If both Child have the same value for Resize (either True or False), then
the size allocated to each is a ratio between the size requested by both.

When you use Set_Position with a parameter other than -1, or the user
moves the handle to resize the widgets, the behavior of Resize is
canceled.
      </doc>
      <parameter name="self" ada="Paned"/>
      <method id="gtk_paned_pack1">
         <parameter name="self" ada="Paned"/>
         <parameter name="resize" default="False" />
         <parameter name="shrink" default="True" />
         <doc>
Add a child to the top or left pane.
You can not change dynamically the attributes Resize and Shrink.
Instead, you have to remove the child from the container, and put it
back with the new value of the attributes. You should also first
call Gtk.Object.Ref on the child so as to be sure it is not destroyed
when you remove it, and Gtk.Object.Unref it at the end. See the
example in testgtk/ in the GtkAda distribution.
         </doc>
      </method>
      <method id="gtk_paned_pack2">
         <parameter name="self" ada="Paned"/>
         <parameter name="resize" default="False" />
         <parameter name="shrink" default="False" />
      </method>
      <method id="gtk_paned_add1">
         <parameter name="self" ada="Paned"/>
         <doc>
Add the first child of the container.
The child will be displayed either in the top or in the left pane,
depending on the orientation of the container.
This is equivalent to using the Pack1 procedure with its default parameters.
         </doc>
      </method>
      <method id="gtk_paned_add2">
         <parameter name="self" ada="Paned"/>
         <doc>
Add the second child of the container.
It will be displayed in the bottom or right pane, depending on the
container's orientation.
This is equivalent to using Pack2 with its default parameters.
         </doc>
      </method>
   </package>

   <package id="Gtk.Vpaned" into="Paned">
      <type name="Gtk_Vpaned" subtype="true"/>
      <parameter name="self" ada="Paned"/>
      <method id="gtk_vpaned_new" ada="Gtk_New_Vpaned">
         <doc>The children will be displayed one on top of the other</doc>
      </method>
      <method id="gtk_vpaned_get_type" ada="Get_Type_Vpaned" />
   </package>

   <package id="Gtk.Hpaned" into="Paned">
      <type name="Gtk_Hpaned" subtype="true"/>
      <parameter name="self" ada="Paned"/>
      <method id="gtk_hpaned_new" ada="Gtk_New_Hpaned">
         <doc>The children will be displayed next to each other</doc>
      </method>
      <method id="gtk_hpaned_get_type" ada="Get_Type_Hpaned" />
   </package>


   <!-- ################################################
        Gtk.Box, Gtk.Vbox, Gtk.Hbox
        ################################################-->
   <package id="Gtk.Box">
      <doc screenshot="gtk-box" testgtk="create_box.adb"
           group="Layout containers">
A box is a container that can have multiple children, organized either
horizontally or vertically. Two subtypes are provided, Gtk_Hbox and
Gtk_Vbox, to conform to the C API. In Ada, you do not need to
distinguish between the two, but note that the Gtk_Box type is conceptually
an abstract type: there is no way to create a "Gtk_Box", only ways to
create either an horizontal box, or a vertical box.

Children can be added to one of two positions in the box, either at the
beginning (ie left or top) or at the end (ie right or bottom). Each of
these positions can contain multiple widgets.

Every time a child is added to the start, it is placed to the right
(resp. the bottom) of the previous widget added to the start.

Every time a child is added to the end, it is placed to the left (resp.
the top) of the previous widget added to the end.

There are a number of parameters to specify the behavior of the box when
it is resized, and how the children should be reorganized and/or resized.

See the testgtk example in the GtkAda distribution to see concrete examples
on how all the parameters for the boxes work.
      </doc>
      <method id="gtk_box_pack_start">
         <parameter name="self" ada="In_Box"/>
         <parameter name="expand" default="True"/>
         <parameter name="fill" default="True"/>
         <parameter name="padding" default="0"/>
      </method>
      <method id="gtk_box_pack_end">
         <parameter name="self" ada="In_Box"/>
         <parameter name="expand" default="True"/>
         <parameter name="fill" default="True"/>
         <parameter name="padding" default="0"/>
      </method>
      <parameter name="self" ada="Box"/>

      <extra>
         <gir:method c:identifier="ada_box_get_child" name="Get_Child"
                     version="GtkAda 1.0">
            <gir:doc>Return the Num-th child of the box, or null if there is no such child</gir:doc>
            <gir:return-value>
               <gir:type name="GtkWidget" c:type="GtkWidget*"/>
            </gir:return-value>
            <gir:parameters>
               <gir:parameter name="num">
                  <gir:type name="Gint" c:type="gint"/>
               </gir:parameter>
            </gir:parameters>
         </gir:method>
      </extra>
   </package>

   <package id="Gtk.Vbox" into="Box">
      <type name="Gtk_Vbox" subtype="true"/>
      <method id="gtk_vbox_new" ada="Gtk_New_Vbox">
         <parameter name="homogeneous" default="False"/>
         <parameter name="spacing" default="0"/>
      </method>
      <parameter name="self" ada="Box"/>
      <method id="gtk_vbox_get_type" ada="Get_Vbox_Type" />
   </package>

   <package id="Gtk.Hbox" into="Box">
      <type name="Gtk_Hbox" subtype="true"/>
      <method id="gtk_hbox_new" ada="Gtk_New_Hbox" >
         <parameter name="homogeneous" default="False"/>
         <parameter name="spacing" default="0"/>
      </method>
      <parameter name="self" ada="Box"/>
      <method id="gtk_hbox_get_type" ada="Get_Hbox_Type" />
   </package>

   <package id="Gtk.Scale">
      <doc group="Numeric/Text Data Entry" screenshot="gtk-scale.png">
A scale is a horizontal or vertical widget that a user can slide to choose
a value in a given range. This is a kind of cursor, similar to what one
finds on audio systems to select the volume for instance.
      </doc>
      <parameter name="self" ada="Scale"/>
   </package>
   <package id="Gtk.Vscale" into="Scale">
      <parameter name="self" ada="Scale"/>
      <type name="Gtk_Vscale" subtype="true"/>
      <method id="gtk_vscale_new" ada="Gtk_New_Vscale">
         <parameter name="adjustment" default="null"/>
      </method>
      <method id="gtk_vscale_new_with_range" ada="Gtk_New_Vscale"/>
      <method id="gtk_vscale_get_type" ada="Vscale_Get_Type" />
   </package>
   <package id="Gtk.Hscale" into="Scale">
      <parameter name="self" ada="Scale"/>
      <type name="Gtk_Hscale" subtype="true"/>
      <method id="gtk_hscale_new" ada="Gtk_New_Hscale">
         <parameter name="adjustment" default="null"/>
      </method>
      <method id="gtk_hscale_new_with_range" ada="Gtk_New_Hscale"/>
      <method id="gtk_hscale_get_type" ada="Hscale_Get_Type" />
   </package>

   <!-- ########################################################
        ## Gtk.Arrow
        ########################################################-->

   <package id="Gtk.Arrow">
      <doc screenshot="gtk-arrow" testgtk="create_arrow.adb">
Gtk_Arrow should be used to draw simple arrows that need to point in one
of the four cardinal directions (up, down, left, or right). The style of
the arrow can be one of shadow in, shadow out, etched in, or etched out.
Note that these directions and style types may be ammended in versions of
Gtk to come.

Gtk_Arrow will fill any space alloted to it, but since it is inherited from
Gtk_Misc, it can be padded and/or aligned, to fill exactly the space you
desire.

Arrows are created with a call to Gtk_New. The direction or style of an
arrow can be changed after creation by using Set.
      </doc>
      <parameter name="self" ada="Arrow"/>
   </package>

   <!-- #######################################################
        ## Gtk.Viewport
        #######################################################-->

   <package id="Gtk.Viewport">
      <doc group="Scrolling">
This widget is an adapter: it can contain any child, and will make it
scrollable. Its use is not necessary inside a Gtk_Scrolled_Window, which
automatically uses a Gtk_Viewport when necessary.
      </doc>
      <parameter name="self" ada="Viewport"/>
      <method id="gtk_viewport_new">
         <parameter name="hadjustment" default="null"/>
         <parameter name="vadjustment" default="null"/>
      </method>
   </package>

   <!-- #######################################################
        ## Gtk.Pixmap
        #######################################################-->

   <package id="Gtk.Pixmap">
      <doc group="Obsolescent widgets"/>
      <parameter name="self" ada="Pixmap"/>
      <parameter name="pixmap" ada="Val"/>
      <method id="gtk_pixmap_set_build_insensitive">
         <doc>Whether the pixmap should be grayed out, as is done for insensitive widgets that do not accept user interaction</doc>
      </method>

      <extra>
         <with_spec pkg="Gtk.Widget" />
         <with_spec pkg="Gtk.Window" />
         <with_spec pkg="Gtkada.Types" />
         <with_body pkg="Interfaces.C.Strings" />
         <with_body pkg="Gdk.Color" />
         <spec>
   function Create_Pixmap
     (Filename : String;
      Window   : access Gtk.Window.Gtk_Window_Record'Class) return Gtk_Pixmap;
      --  Create a pixmap given a window and a filename

   function Create_Pixmap
     (Data     : Gtkada.Types.Chars_Ptr_Array;
      Window   : access Gtk.Window.Gtk_Window_Record'Class) return Gtk_Pixmap;
   --  Create a pixmap given a window and a buffer.
            </spec>
            <body>
   Dummy_Pixmap : constant GtkAda.Types.chars_ptr_array :=
     (New_String ("1 1 1 1"),
      New_String ("c None"),
      New_String (" "));
   --  This is a dummy pixmap we use when a pixmap can't be found.

   function Create_Pixmap
     (Filename : String;
      Window   : access Gtk.Window.Gtk_Window_Record'Class) return Gtk_Pixmap
   is
      Gdkpixmap : Gdk.Pixmap.Gdk_Pixmap;
      Mask      : Gdk.Bitmap.Gdk_Bitmap;
      Pixmap    : Gtk_Pixmap;

      use Gtk.Widget;
      use Gtk.Window;

   begin
      if not Realized_Is_Set (Window) then
         Gtk.Window.Realize (Window);
      end if;

      if Filename = "" then
         Gdk.Pixmap.Create_From_Xpm_D
           (Gdkpixmap, Get_Window (Window), Mask,
            Gdk.Color.Null_Color, Dummy_Pixmap);
      else
         Gdk.Pixmap.Create_From_Xpm
           (Gdkpixmap, Get_Window (Window), Mask,
            Gdk.Color.Null_Color, Filename);
      end if;

      Gtk_New (Pixmap, Gdkpixmap, Mask);
      return Pixmap;
   end Create_Pixmap;

   function Create_Pixmap
     (Data   : Gtkada.Types.Chars_Ptr_Array;
      Window : access Gtk.Window.Gtk_Window_Record'Class) return Gtk_Pixmap
   is
      Gdkpixmap : Gdk.Pixmap.Gdk_Pixmap;
      Mask      : Gdk.Bitmap.Gdk_Bitmap;
      Pixmap    : Gtk_Pixmap;

      use Gtk.Widget;
      use Gtk.Window;

   begin
      if not Realized_Is_Set (Window) then
         Gtk.Window.Realize (Window);
      end if;

      Gdk.Pixmap.Create_From_Xpm_D
        (Gdkpixmap, Get_Window (Window), Mask, Gdk.Color.Null_Color, Data);
      Gtk_New (Pixmap, Gdkpixmap, Mask);

      return Pixmap;
   end Create_Pixmap;
         </body>
      </extra>
   </package>

   <package id="Gtk.Misc">
      <doc group="Abstract base classes">
This widget is a base class for all the widgets that require an
alignment and padding.
This widget can not be instantiated directly.
      </doc>
      <parameter name="self" ada="Misc"/>
      <method id="gtk_misc_set_alignment">
         <doc>
Modify the alignment for the widget.
Xalign and Yalign are both values between 0.0 and 1.0 that specify the
alignment: if Xalign is 0.0, the widget will be left aligned; if it is
0.5, the widget will be centered; if it is 1.0 the widget will be
right aligned. Yalign is from top (0.0) to bottom (1.0).
Both Xalign and Yalign will be constrained to the range 0.0 .. 1.0
Note that if the widget fills its allocated area, these two parameters
won't have any effect.
         </doc>
      </method>
      <method id="gtk_misc_set_padding">
         <doc>
Set the padding (i.e. the extra spaces on the side of the widget).
If Xpad or Ypad is negative, they will be changed to 0.
         </doc>
      </method>
   </package>

   <package id="Gtk.Bin">
      <doc group="Abstract base classes">
Base class for containers that have only one child.
This widget can not be instantiated directly.
      </doc>
      <parameter name="self" ada="Bin"/>
   </package>

   <package id="Gtk.List" obsolescent="True">
      <doc group="Obsolescent widgets" testgtk="create_list.adb"/>
      <parameter name="self" ada="List"/>
      <method id="gtk_list_append_items">
         <parameter name="items" ctype="WidgetList"/>
      </method>
      <method id="gtk_list_prepend_items">
         <parameter name="items" ctype="WidgetList"/>
      </method>
      <method id="gtk_list_insert_items">
         <parameter name="items" ctype="WidgetList"/>
      </method>
      <method id="gtk_list_remove_items">
         <parameter name="items" ctype="WidgetList"/>
      </method>
      <method id="gtk_list_remove_items_no_unref">
         <parameter name="items" ctype="WidgetList"/>
      </method>
      <method id="gtk_list_clear_items">
         <doc>Remove some items from the list. If The_End is negative, it means the end of the list. The first item in the list has an index of 0</doc>
      </method>
      <extra>
         <spec>
   function Get_Selection (Widget : access Gtk.List.Gtk_List_Record)
      return Widget_List.Glist;
         </spec>
         <body>
   function Get_Selection (Widget : access Gtk.List.Gtk_List_Record)
      return Widget_List.Glist
   is
      use Widget_List;
      function Internal (Widget : in System.Address)
                         return      System.Address;
      pragma Import (C, Internal, "ada_list_get_selection");
      List : Gtk.Widget.Widget_List.Glist;
   begin
      Set_Object (List, Internal (Get_Object (Widget)));
      return List;
   end Get_Selection;
         </body>
      </extra>
   </package>

   <package id="Gtk.Progress" obsolescent="True">
      <doc group="Obsolescent widgets">This package is deprecated. It now only acts as an abstract base class for other widgets.</doc>
      <parameter name="self" ada="Progress"/> <!-- for all methods -->
      <method id="gtk_progress_get_adjustment">
         <parameter name="self" ada="widget"/>
      </method>
      <method id="gtkada_GtkProgress_get_adjustment" bind="true"/>
      <method id="gtkada_GtkProgress_get_activity_mode" bind="true"/>
   </package>

   <package id="Gtk.Layout">
      <doc group="Layout containers" testgtk="create_layout.adb"
           screenshot="gtk-layout">
A Gtk_Layout is a widget that can have an almost infinite size, without
occupying a lot of memory. Its children can be located anywhere within
it, but will only appear on the screen if the visible area of the layout
contains them.
Just like a Gtk_Viewport, its visible area is indicated by two
Gtk_Adjustment widgets, and thus a Gtk_Layout can be put as is in a
Gtk_Scrolled_Window.
As for Gtk_Fixed containers, the children can be located anywhere in the
layout (no automatic organization is done). But, as opposed to Gtk_Fixed
widgets, a Gtk_Layout does not try to resize itself to show all its
children.

Starting from GtkAda 2.0, you have to call Set_Size and specify the maximum
size of the layout, otherwise children added with Put outside the size
defined for the layout will never be visible.
One way to do this is to systematically call Set_Size before calling Put,
and make sure you specify a size big enough for the layout.
      </doc>
      <parameter name="self" ada="Layout"/> <!-- for all methods -->
      <method id="gtk_layout_new">
         <parameter name="hadjustment" default="null"/>
         <parameter name="vadjustment" default="null"/>
      </method>
      <method id="gtk_layout_put">
         <doc>The child will be displayed on the screen only if at least part of it intersects the visible area of the layout. The layout does not resize itself to automatically show the widget. You also need to call Set_Size, if the size you initially defined is smaller than (X, Y), or the child will never be visible even if the layout is scrolled.</doc>
      </method>
      <method id="gtk_layout_set_hadjustment">
         <doc>Return the adjustment that indicate the horizontal visual area of the layout. You generally do not have to modify the value of this adjustment yourself, since this is done automatically when the layout has been put in a Gtk_Scrolled_Window.</doc>
      </method>
   </package>

   <package id="Gtk.GRange">
      <doc testgtk="create_range.adb" screenshot="gtk-range">This widget provides a low level graphical representation of a range of values. It is used by other widgets such as Gtk_Scale and Gtk_Scrollbar.</doc>
      <parameter name="self" ada="The_Range"/>
   </package>

   <package id="Gtk.Button_Box">
      <doc testgtk="create_button_box.adb" screenshot="gtk-button_box"
           group="Layout containers">
A Gtk_Button_Box is a special type of Gtk_Box specially tailored to contain
buttons.

This is only a base class for Gtk_Hbutton_Box and Gtk_Vbutton_Box which
provide a way to arrange their children horizontally (resp. vertically).
You can not instantiate a Gtk_Button_Box directly, and have to use one the
above two instead.
      </doc>
      <parameter name="self" ada="Widget"/>
      <method id="gtk_button_box_set_child_size" obsolescent="True"/>
      <method id="gtk_button_box_get_child_size" obsolescent="True"/>
      <method id="gtk_button_box_set_child_ipadding" obsolescent="True"/>
      <method id="gtk_button_box_set_child_secondary">
         <doc>
Set whether Child should appear in a secondary group of children.
A typical use of a secondary child is the help button in a dialog.

This group appears after the other children if the style is
Buttonbox_Start, Buttonbox_Spread or Buttonbox_Edge, and before the
other children if the style is Buttonbox_End. For horizontal button
boxes, the definition of before/after depends on direction of the
widget. (See Gtk.Widget.Set_Direction) If the style is Buttonbox_Start,
or Buttonbox_End, then the secondary children are aligned at
the other end of the button box from the main children. For the
other styles, they appear immediately next to the main children.

Is_Secondary: if True, the Child appears in a secondary group of the
              button box.
         </doc>
      </method>
   </package>

   <package id="Gtk.Hbutton_Box">
      <doc group="Layout containers">
A Gtk_Hbutton_Box is a specific Gtk_Button_Box that organizes its
children horizontally.
The beginning of the box (when you add children with Gtk.Box.Pack_Start)
is on the left of the box. Its end (for Gtk.Box.Pack_End) is on the right.
      </doc>
      <parameter name="self" ada="Widget"/>
      <method id="gtk_hbutton_box_get_spacing_default" obsolescent="True"/>
      <method id="gtk_hbutton_box_set_spacing_default" obsolescent="True">
         <doc>Set the default spacing (space between two adjacent children). This is done for all the Hbutton_Boxes in your application. This can be overridden for a specific box by calling Gtk.Button_Box.Set_Spacing.</doc>
      </method>
      <method id="gtk_hbutton_box_get_layout_default" obsolescent="True"/>
      <method id="gtk_hbutton_box_set_layout_default" obsolescent="True">
         <doc>Set the the default layout to use for all the hbutton_boxes in your application that don't have a specific value set by Gtk.Button_Box.Set_Layout. The default value is Buttonbox_Edge</doc>
      </method>
   </package>

   <package id="Gtk.Vbutton_Box">
      <doc group="Layout containers">
A Gtk_Vbutton_Box is a specific Gtk_Button_Box that organizes its
children vertically.
The beginning of the box (when you add children with Gtk.Box.Pack_Start)
is on the top of the box. Its end (for Gtk.Box.Pack_End) is on the bottom.
      </doc>
      <parameter name="self" ada="Widget"/>
      <method id="gtk_vbutton_box_get_spacing_default" obsolescent="True"/>
      <method id="gtk_vbutton_box_set_spacing_default" obsolescent="True"/>
      <method id="gtk_vbutton_box_get_layout_default" obsolescent="True"/>
      <method id="gtk_vbutton_box_get_layout_default" obsolescent="True"/>
   </package>

   <package id="Gtk.Volume_Button">
      <doc>
Gtk_Volume_Button is a subclass of Gtk_Scale_Button that has been tailored
for use as a volume control widget with suitable icons, tooltips and
accessible labels.
      </doc>
      <parameter name="self" ada="Widget"/>
   </package>

   <package id="Gtk.About_Dialog">
      <doc group="Windows" testgtk="create_about.adb">
The Gtk_About_Dialog offers a simple way to display information about a
program like its logo, name, copyright, website and license. It is also
possible to give credits to the authors, documenters, translators and
artists who have worked on the program. An about dialog is typically opened
when the user selects the About option from the Help menu. All parts of the
dialog are optional.

About dialog often contain links and email addresses. Gtk_About_Dialog
supports this by offering global hooks, which are called when the user
clicks on a link or email address, see Set_Email_Hook and Set_Url_Hook.
Email addresses in the authors, documenters and artists properties are
recognized by looking for &lt;user@host&gt;, URLs are recognized by looking for
http://url, with url extending to the next space, tab or line break.

To make constructing a Gtk_About_Dialog as convenient as possible, you can
use the function gtk_show_about_dialog which constructs and shows a dialog
and keeps it around so that it can be shown again.
     </doc>
     <parameter name="self" ada="About"/>
     <extra>
        <with_spec pkg="Interfaces.C.Strings"/>
        <!-- This is defined in a <callback> node in GIR, but not processed
             automatically yet -->
        <type ctype="GtkAboutDialogActivateLinkFunc"
           ada="Activate_Link_Func">
   type Activate_Link_Func is access procedure
     (About : System.Address;
      Link  : Interfaces.C.Strings.chars_ptr;
      Data  : System.Address);
   pragma Convention (C, Activate_Link_Func);
   --  A callback called when the user presses an hyper link in the about
   --  dialog. This is a low-level function, and you'll need to convert the
   --  parameters to more useful types with:
   --     Stub : Gtk_About_Dialog_Record;
   --     A    : constant Gtk_About_Dialog :=
   --       Gtk_About_Dialog (Get_User_Data (About, Stub));
   --     L    : constant String := Interfaces.C.Strings.Value (Link);
        </type>
     </extra>
  </package>

  <package id="Gtk.GEntry">
     <doc testgtk="create_entry.adb" group="Numeric/Text Data Entry"
          screenshot="gtk-gentry">
A Gtk_Entry is a single line text editing widget.
The text is automatically scrolled if it is longer than can be displayed
on the screen, so that the cursor position is visible at all times.

See Gtk_Text_View for a multiple-line text editing widget.
     </doc>
     <parameter name="self" ada="The_Entry"/>
  </package>

  <package id="Gtk.Combo" obsolescent="True">
     <doc group="Obsolescent widgets" screenshot="gtk-combo"
          see="Gtk.Combo_Box">
The Gtk_Combo widget consists of a single-line text entry field and a
drop-down list. The drop-down list is displayed when the user clicks on a
small arrow button to the right of the entry field.

The drop-down list is a Gtk_List widget and can be accessed using the list
member of the Gtk_Combo. List elements can contain arbitrary widgets, but
if an element is not a plain label, then you must use the
Gtk_List.Set_Item_String function. This sets the string which will be
placed in the text entry field when the item is selected.

By default, the user can step through the items in the list using the arrow
(cursor) keys, though this behaviour can be turned off with Set_Use_Arrows.

Normally the arrow keys are only active when the contents of the text entry
field matches one of the items in the list. If the contents of the entry
field do not match any of the list items, then pressing the arrow keys does
nothing. However, by calling Set_Use_Arrows_Always you can specify that the
arrow keys are always active. If the contents of the entry field does not
match any of the items in the list, then pressing the up or down arrow key
will set the entry field to the last or first item in the list,
respectively.
     </doc>
     <parameter name="self" ada="Combo_Box"/>
     <method id="gtk_combo_set_value_in_list">
        <parameter name="val" default="True"/>
        <parameter name="ok_if_empty" default="False"/>
        <doc>Specify whether the value entered in the text entry field must match one of the values in the list. If this is set then the user will not be able to perform any other action until a valid value has been entered. If an empty field is acceptable, the Ok_If_Empty parameter should be True. If the value entered must match one of the values in the list, val should be True.</doc>
     </method>
     <method id="gtk_combo_set_use_arrows">
        <parameter name="val" default="True"/>
        <doc>Specify if the arrow (cursor) keys can be used to step through the items in the list. This is on by default.</doc>
     </method>
     <method id="gtk_combo_set_use_arrows_always">
        <parameter name="val" default="True"/>
        <doc>Specify if the arrow keys will still work even if the current contents of the Gtk_Entry field do not match any of the list items.</doc>
     </method>
     <method id="gtk_combo_set_case_sensitive">
        <parameter name="val" default="True"/>
        <doc>Specify whether the text entered into the Gtk_Entry field and the text in the list items are case sensitive. This may be useful, for example, when you have called Set_Value_In_List to limit the values entered, but you are not worried about differences in case.</doc>
     </method>
     <method id="gtk_combo_set_popdown_strings">
        <parameter name="strings" ctype="StringList"/>
        <doc>Set all the items in the popup list.</doc>
     </method>
     <method id="gtk_combo_disable_activate">
        <doc>Disable the standard handler for the return key in the entry field. The default behavior is to popdown the combo box list, so that the user can choose from it. However, if you want to add your own callback for the return key, you need to call this subprogram, and connect a handler to the "activate" signal for the entry.</doc>
     </method>
     <method id="gtk_combo_set_item_string">
        <doc>Set the string to place in the Gtk_Entry field when a particular list item is selected. This is needed if the list item is not a simple label.</doc>
     </method>
     <method id="gtkada_GtkCombo_get_entry"  bind="True"/>
     <method id="gtkada_GtkCombo_set_entry"  bind="True"/>
     <method id="gtkada_GtkCombo_get_list"   bind="True"/>
     <method id="gtkada_GtkCombo_get_popwin" bind="True"/>
     <extra>
        <with_spec pkg="Gtk.Enums" />  <!--  for String_List -->
     </extra>
  </package>

  <package id="Gtk.Dialog">
     <doc group="Windows" testgtk="create_dialog.adb"
          screenshot="gtk-dialog">Dialog boxes are a convenient way to prompt the user for a small amount of input, eg. to display a message, ask a question, or anything else that does not require extensive effort on the user's part.

Gtkada treats a dialog as a window split horizontally. The top section is a Gtk_Vbox, and is where widgets such as a Gtk_Label or a Gtk_Entry should be packed. The second area is known as the action_area. This is generally used for packing buttons into the dialog which may perform functions such as cancel, ok, or apply. The two areas are separated by a Gtk_Hseparator.

If 'dialog' is a newly created dialog, the two primary areas of the window can be accessed using Get_Vbox and Get_Action_Area as can be seen from the example, below.

A 'modal' dialog (that is, one which freezes the rest of the application from user input), can be created by calling Set_Modal on the dialog.

See Gtkada.Dialogs for a higher level dialog interface.
     </doc>
     <parameter name="self" ada="Dialog" />
     <parameter name="response_id" type="Gtk_Response_Type"/>
     <method id="gtk_dialog_get_action_area" return="GtkBox*"/>
     <method id="gtk_dialog_get_content_area" return="GtkBox*"/>
     <method id="gtk_dialog_get_response_for_widget" return="GtkResponseType"/>
     <method id="gtk_dialog_run" return="GtkResponseType"/>
     <method id="gtkada_GtkDialog_get_vbox" bind="true" return="GtkBox*"/>
     <method id="gtk_dialog_add_button">
        <parameter name="button_text" ada="text"/>
     </method>

     <!-- Bound manually below -->
     <method id="gtk_dialog_set_alternative_button_order_from_array" bind="False"/>

     <!-- Following methods have varargs -->
     <method id="gtk_dialog_new_with_buttons" bind="False"/>
     <method id="gtk_dialog_add_buttons" bind="False"/>
     <method id="gtk_dialog_set_alternative_button_order" bind="False"/>

     <method id="ada_gtk_dialog_new_with_buttons">
        <parameter name="parent" default="null"/>
     </method>

     <extra>
        <gir:constructor c:identifier="ada_gtk_dialog_new_with_buttons"
             name="new" version="GtkAda 1.0">
             <gir:doc>Create a new dialog with a specific title, and specific attributes. Parent is the transient parent for the dialog (ie the one that is used for reference for the flag Destroy_With_Parent, or to compute the initial position of the dialog).</gir:doc>
           <gir:return-value>
              <gir:type name="GtkDialog" c:type="GtkDialog*"/>
           </gir:return-value>
           <gir:parameters>
              <gir:parameter name="title">
                 <gir:type name="utf8" c:type="gchar*"/>
              </gir:parameter>
              <gir:parameter name="parent">
                 <gir:type name="Window" c:type="GtkWindow*"/>
              </gir:parameter>
              <gir:parameter name="flags">
                 <gir:type name="DialogFlags" c:type="GtkDialogFlags"/>
              </gir:parameter>
           </gir:parameters>
        </gir:constructor>

        <spec>
   procedure Set_Alternative_Button_Order_From_Array
     (Dialog    : access Gtk_Dialog_Record;
      New_Order : Response_Type_Array);
   --  Sets an alternative button order. If the gtk-alternative-button-order
   --  setting is set to %TRUE, the dialog buttons are reordered according to
   --  the order of the response ids passed to this function.
   --
   --  By default, GTK+ dialogs use the button order advocated by the Gnome
   --  Human Interface Guidelines with the affirmative button at the far right,
   --  and the cancel button left of it. But the builtin GTK+ dialogs and
   --  message dialogs' do provide an alternative button order, which is more
   --  suitable on some platforms, e.g. Windows.
   --
   --  Use this function after adding all the buttons to your dialog.

   function Gtk_Alternative_Dialog_Button_Order
     (Screen : Gdk.Gdk_Screen := null)  return Boolean;
   --  Returns True if dialogs are expected to use an alternative button order
   --  on the given screen (or current screen if null) . See
   --  Set_Alternative_Button_Order_From_Array for more details about
   --  alternative button order.
   --
   --  If you need to use this function, you should probably connect to the
   --  ::notify:gtk-alternative-button-order signal on the Gtk_Settings object
   --  associated to Screen, in order to be notified if the button order
   --  setting changes.
   --
   --  Returns: Whether the alternative button order should be used
        </spec>
        <body>
   procedure Set_Alternative_Button_Order_From_Array
     (Dialog    : access Gtk_Dialog_Record;
      New_Order : Response_Type_Array)
   is
      procedure Internal
        (Dialog    : System.Address;
         N_Params  : Gint;
         New_Order : System.Address);
      pragma Import
        (C, Internal, "gtk_dialog_set_alternative_button_order_from_array");
   begin
      Internal (Get_Object (Dialog), New_Order'Length,
                New_Order (New_Order'First)'Address);
   end Set_Alternative_Button_Order_From_Array;

   function Gtk_Alternative_Dialog_Button_Order
     (Screen : Gdk.Gdk_Screen := null) return Boolean
   is
      function Internal (Screen : Gdk.Gdk_Screen) return Gboolean;
      pragma Import (C, Internal, "gtk_alternative_dialog_button_order");
   begin
      return Boolean'Val (Internal (Screen));
   end Gtk_Alternative_Dialog_Button_Order;
        </body>

        <type ctype="GtkDialogFlags" ada="Gtk_Dialog_Flags">
   type Gtk_Dialog_Flags is mod 8;
   for Gtk_Dialog_Flags'Size use Gint'Size;
   pragma Convention (C, Gtk_Dialog_Flags);
   Modal               : constant Gtk_Dialog_Flags := 2 ** 0;
   Destroy_With_Parent : constant Gtk_Dialog_Flags := 2 ** 1;
   No_Separator        : constant Gtk_Dialog_Flags := 2 ** 2;
   --  Various flags that can be set for the dialog, with the following
   --  implications:
   --     - Modal : the dialog is modal, see Gtk.Window.Set_Modal
   --     - Destroy_With_Parent: The dialog is destroyed if its parent is
   --       destroyed. See Gtk.Window.Set_Destroy_With_Parent
   --     - No_Separator: No separator bar above the buttons.
        </type>

        <type ctype="GtkResponseType" ada="Gtk_Response_Type">
   type Gtk_Response_Type is new Gint;
   --  Type used for Response_Id's.
   --  Positive values are totally user-interpreted.
   --  GtkAda will sometimes return Gtk_Response_None if no Response_Id is
   --  available.
   --
   --  Typical usage is:
   --    if Gtk.Dialog.Run (Dialog) = Gtk_Response_Accept then
   --       blah;
   --    end if;

   Gtk_Response_None : constant Gtk_Response_Type := -1;
   --  GtkAda returns this if a response widget has no Response_Id,
   --  or if the dialog gets programmatically hidden or destroyed.

   Gtk_Response_Reject : constant Gtk_Response_Type := -2;
   Gtk_Response_Accept : constant Gtk_Response_Type := -3;
   --  GtkAda won't return these unless you pass them in
   --  as the response for an action widget. They are
   --  for your convenience.

   Gtk_Response_Delete_Event : constant Gtk_Response_Type := -4;
   --  If the dialog is deleted through the button in the titlebar

   Gtk_Response_OK     : constant Gtk_Response_Type := -5;
   Gtk_Response_Cancel : constant Gtk_Response_Type := -6;
   Gtk_Response_Close  : constant Gtk_Response_Type := -7;
   Gtk_Response_Yes    : constant Gtk_Response_Type := -8;
   Gtk_Response_No     : constant Gtk_Response_Type := -9;
   Gtk_Response_Apply  : constant Gtk_Response_Type := -10;
   Gtk_Response_Help   : constant Gtk_Response_Type := -11;
   --  These are returned from dialogs, and you can also use them
   --  yourself if you like.
        </type>

        <type ctype="GtkResponseType*" ada="Response_Type_Array">
   type Response_Type_Array is array (Natural range &lt;&gt;) of Gtk_Response_Type;
        </type>
     </extra>
  </package>

  <package id="Gtk.Curve">
     <doc group="Drawing">
The Gtk_Curve widget allows the user to edit a curve covering a range of values. It is typically used to fine-tune color balances in graphics applications like the Gimp.

The Gtk_Curve widget has 3 modes of operation: spline, linear and free.  In spline mode the user places points on the curve which are automatically connected together into a smooth curve. In linear mode the user places points on the curve which are connected by straight lines. In free mode the user can draw the points of the curve freely, and they are not connected at all.
     </doc>
     <parameter name="self" ada="Curve"/>
     <method id="gtk_curve_set_vector" bind="False"/>
     <method id="gtk_curve_get_vector" bind="False"/>
     <method id="gtk_curve_set_gamma">
        <doc>Recompute the entire curve using the given gamma value. A gamma value of 1.0 results in a straight line. Values greater than 1.0 result in a curve above the straight line. Values less than 1.0 result in a curve below the straight line. The curve type is changed to Curve_Type_Free.</doc>
     </method>
     <method id="gtk_curve_set_range">
        <doc>Set the minimum and maximum x &amp; y values of the curve. The curve is also reset with a call to Reset.</doc>
     </method>
     <method id="gtk_curve_set_curve_type">
        <doc>Set the type of the curve. The curve will remain unchanged except when changing from a free curve to a linear or spline curve, in which case the curve will be changed as little as possible.</doc>
     </method>
     <method id="gtk_curve_reset">
        <doc>Reset the curve. Reset to a straight line from the minimum x &amp; y values to the maximum x &amp; y values (i.e. from the bottom-left to the top-right corners). The curve type is not changed.</doc>
     </method>

     <extra>
        <spec>
   procedure Set_Vector
     (Curve  : access Gtk_Curve_Record; Vector : Gfloat_Array);
   procedure Get_Vector
     (Curve  : access Gtk_Curve_Record; Vector : out Gfloat_Array);
   --  Set the vector of points on the curve.
   --  The curve type is set to Curve_Type_Free.
       </spec>
       <body>
   procedure Get_Vector
     (Curve  : access Gtk_Curve_Record;
      Vector : out Gfloat_Array)
   is
      procedure Internal
        (Curve  : System.Address;
         Veclen : Integer;
         Vector : System.Address);
      pragma Import (C, Internal, "gtk_curve_get_vector");

   begin
      Internal (Get_Object (Curve), Vector'Length, Vector'Address);
   end Get_Vector;

   procedure Set_Vector
     (Curve  : access Gtk_Curve_Record;
      Vector : Gfloat_Array)
   is
      procedure Internal
        (Curve  : System.Address;
         Veclen : Integer;
         Vector : System.Address);
      pragma Import (C, Internal, "gtk_curve_set_vector");

   begin
      Internal (Get_Object (Curve), Vector'Length,
                Vector (Vector'First)'Address);
   end Set_Vector;
       </body>
    </extra>
  </package>

  <package id="Gtk.Expander">
     <doc group="Layout containers" screenshot="gtk-expanded">A container that can hide its child.</doc>
     <parameter name="self" ada="Expander"/>
  </package>

  <package id="Gtk.Drawing_Area">
     <doc group="Drawing" testgtk="libart_demo.adb">
This widget provides an empty canvas on which the application can draw anything.

Note that this widget is simply an empty space, and that you need to connect it to events to make it useful. For instance, you might want to do one of the following :

* Connect it to "expose_event": The handlers are called every time the widget needs to be redrawn. You can then draw anything you want on the canvas, after getting its associated window with a call to Gtk.Widget.Get_Window. Note that the event mask is automatically set up to accept expose_events.

* Connect it to "button_press_event" and "button_release_event" events, when you want it to react to user input. Note that you need to set up the event mask with a call to Gtk.Widget.Set_Events.

See also the Double_Buffer widget provided in the GtkAda examples for an advanced example that demonstrates how to use double buffering, to avoid flickering in your drawings.</doc>
     <parameter name="self" ada="Drawing_Area"/>
     <method id="gtk_drawing_area_size" obsolescent="True">
        <doc>Request a new size for the area. This queues a resize request for the area.</doc>
     </method>
  </package>

  <package id="Gtk.Adjustment">
     <doc group="Scrolling">This object represents an adjustable bounded value. It is used in many other widgets that have such internal values, like Gtk_Scrollbar, Gtk_Spin_Button, Gtk_Range, ... Modifying the value of these widgets is done through their associated adjustments.

The modification of the value is left to the user, who should call Value_Changed or Changed to emit the relevant signals.

The meaning of the most important fields can be explained on the following figure (imagine this is a scrollbar):

[-------|=================|-------------------]

lower    value        value + page_size       upper
     </doc>
     <parameter name="self" ada="Adjustment"/>
     <method id="gtk_adjustment_new">
        <parameter name="page_size" default="0.0"/>
        <doc>Create a new adjustment. Value is the initial value of the adjustment. It must be in the range (Lower .. Upper) and the adjustment's value will never be outside this range. Step_Increment is the value used to make minor adjustments, such as when the user clicks on the arrows of a scrollbar. Page_Increment is used to make major adjustments, such as when the user clicks in the through on a scrollbar. Page_Size is deprecated, use the default value.</doc>
     </method>
     <method id="gtk_adjustment_clamp_page">
        <doc>Update the Adjustment value to ensure that the range between Lower and Upper is in the current page (i.e. between value and value + page_size). If the range is larger than the page size, then only the start of it will be in the current page. A "value_changed" signal will be emitted if the value is changed.</doc>
     </method>
  </package>

  <package id="Gtk.Image">
     <doc group="Display widgets" screenshot="gtk-image">The Gtk_Image widget displays a graphical image. The image is typically created using Gdk.Image.Gdk_New.

The pixels in a Gtk_Image may be manipulated by the application after creation, as Gtk_Image store the pixel data on the client side. If you wish to store the pixel data on the server side (thus not allowing manipulation of the data after creation) you should use Gtk_Pixmap.</doc>
     <parameter name="self" ada="Image"/>
     <parameter name="image" ada="Val"/>
     <parameter name="size" type="Gtk.Enums.Gtk_Icon_Size"/>
     <method id="gtk_image_new_from_animation" ada="Gtk_New"/>
     <method id="gtk_image_new_from_file"      ada="Gtk_New"/>
     <method id="gtk_image_new_from_image"     ada="Gtk_New"/>
     <method id="gtk_image_new_from_pixbuf"    ada="Gtk_New"/>
     <method id="gtk_image_new_from_icon_set"  ada="Gtk_New"/>
     <method id="gtk_image_new_from_pixmap"    ada="Gtk_New"/>
     <method id="gtk_image_new_from_stock"     ada="Gtk_New"/>
     <method id="gtk_image_get_animation"      ada="Get"/>
     <method id="gtk_image_set_from_animation" ada="Set"/>
     <method id="gtk_image_get_image"          ada="Get"/>
     <method id="gtk_image_get" bind="False"/> <!-- same as get_image -->
     <method id="gtk_image_set_from_image"     ada="Set"/>
     <method id="gtk_image_set" bind="False"/> <!-- same as set_from_image -->
     <method id="gtk_image_get_pixbuf"         ada="Get"/>
     <method id="gtk_image_set_from_pixbuf"    ada="Set"/>
     <method id="gtk_image_get_icon_set"       ada="Get"/>
     <method id="gtk_image_set_from_icon_set"  ada="Set"/>
     <method id="gtk_image_get_pixmap"         ada="Get"/>
     <method id="gtk_image_set_from_pixmap"    ada="Set"/>
     <method id="gtk_image_get_stock"          ada="Get" bind="False"/>
     <method id="gtk_image_set_from_stock"     ada="Set"/>
     <method id="gtk_image_get_gicon"          ada="Get"/>
     <method id="gtk_image_set_from_gicon"     ada="Set"/>
     <method id="gtk_image_set_from_file"      ada="Set"/>
     <method id="gtk_image_get_icon_name"      ada="Get" bind="False"/>
     <extra>
        <type ctype="GtkImageType" ada="Gtk_Image_Type">
   type Gtk_Image_Type is
     (Image_Empty,
      Image_Pixmap,
      Image_Image,
      Image_Pixbuf,
      Image_Stock,
      Image_Icon_Set,
      Image_Animation,
      Image_Icon_Name,
      Image_Gicon);
   pragma Convention (C, Gtk_Image_Type);
        </type>
        <with_spec pkg="GNAT.Strings"/>
        <spec>
   function Get
     (Image : access Gtk_Image_Record;
      Size  : access Gtk.Enums.Gtk_Icon_Size) return String;
   --  Get the stock_id for the image displayed

   procedure Get_Icon_Name
     (Image : access Gtk_Image_Record;
      Name  : out GNAT.Strings.String_Access;
      Size  : out Gtk.Enums.Gtk_Icon_Size);
        </spec>
        <body>
   procedure Get_Icon_Name
     (Image : access Gtk_Image_Record;
      Name  : out GNAT.Strings.String_Access;
      Size  : out Gtk_Icon_Size)
   is
      procedure Internal
        (Image : System.Address;
         Name  : out Interfaces.C.Strings.chars_ptr;
         Size  : out Gtk_Icon_Size);
      pragma Import (C, Internal, "gtk_image_get_icon_name");
      Str : chars_ptr;
   begin
      Internal (Get_Object (Image), Str, Size);
      Name := new String'(Value (Str));
   end Get_Icon_Name;

   function Get
     (Image : access Gtk_Image_Record;
      Size  : access Gtk.Enums.Gtk_Icon_Size) return String
   is
      procedure Internal
        (Image    : System.Address;
         Stock_Id : out Interfaces.C.Strings.chars_ptr;
         Size     : out Gint);
      pragma Import (C, Internal, "gtk_image_get_stock");

      Stock : Interfaces.C.Strings.chars_ptr;
      Sze   : Gint;

   begin
      Internal (Get_Object (Image), Stock, Sze);
      Size.all := Gtk.Enums.Gtk_Icon_Size'Val (Sze);
      return Interfaces.C.Strings.Value (Stock);
   end Get;

        </body>
     </extra>
  </package>

  <package id="Gtk.Calendar">
     <doc group="Selectors" testgtk="create_calendar.adb"
          screenshot="gtk-calendar">
Gtk_Calendar is a widget that displays a calendar, one month at a time. It can be created with Gtk_New.

The month and year currently displayed can be altered with Select_Month. The exact day can be selected from the displayed month using Select_Day.

The way in which the calendar itself is displayed can be altered using Display_Options.

The selected date can be retrieved from a Gtk_Calendar using Get_Date.

If performing many 'mark' operations, the calendar can be frozen to prevent flicker, using Freeze, and 'thawed' again using Thaw.
     </doc>
     <parameter name="self" ada="Calendar"/>
     <method id="gtk_calendar_freeze" obsolescent="True"/>
     <method id="gtk_calendar_thaw" obsolescent="True"/>
     <method id="gtk_calendar_set_detail_func">
        <body>
   procedure Set_Detail_Func
     (Calendar : access Gtk_Calendar_Record;
      Func     : Gtk_Calendar_Detail_Func;
      Data     : System.Address;
      Destroy  : G_Destroy_Notify_Address)
   is
      procedure Internal
        (Calendar : System.Address;
         Func     : System.Address;
         Data     : System.Address;
         Destroy  : G_Destroy_Notify_Address);
      pragma Import (C, Internal, "gtk_calendar_set_detail_func");
      D : constant Detail_Func_Data_Access :=
         new Detail_Func_Data'(Func, Data, Destroy);
   begin
      Internal (Get_Object (Calendar),
                Detail_Callback'Address, D.all'Address,
                Free_Detail_Func_Data'Access);
   end Set_Detail_Func;
        </body>
     </method>
     <extra>
        <type ctype="GtkCalendarDisplayOptions"
              ada="Gtk_Calendar_Display_Options">
   type Gtk_Calendar_Display_Options is mod 2 ** 8;

   Show_Heading : constant Gtk_Calendar_Display_Options := 2 ** 0;
   --  Specify that the month and year should be displayed.

   Show_Day_Names : constant Gtk_Calendar_Display_Options := 2 ** 1;
   --  Specify that three letter day descriptions should be present.

   No_Month_Change : constant Gtk_Calendar_Display_Options := 2 ** 2;
   --  Prevent the user from switching months with the calendar.

   Show_Week_Numbers : constant Gtk_Calendar_Display_Options := 2 ** 3;
   --  Display each week numbers of the current year, down the left side of
   --  the calendar.

   Week_Start_Monday : constant Gtk_Calendar_Display_Options := 2 ** 4;
   --  Start the calendar week on Monday, instead of the default Sunday.
        </type>
        <type ctype="GtkCalendarDetailFunc"
              ada="Gtk_Calendar_Detail_Func">
   type Gtk_Calendar_Detail_Func is access function
      (Calendar  : access Gtk_Calendar_Record'Class;
       Year      : Guint;
       Month     : Guint;
       Day       : Guint;
       User_Data : System.Address) return String;
   --  Return the details for the given day, or the empty string when there
   --  are no details.
        </type>
        <with_body pkg="Interfaces.C.Strings"/>
        <with_body pkg="Ada.Unchecked_Conversion" use="False"/>
        <with_body pkg="Ada.Unchecked_Deallocation" use="False"/>
        <body>
   type Detail_Func_Data is record
      Callback   : Gtk_Calendar_Detail_Func;
      User_Data  : System.Address;
      On_Destroy : G_Destroy_Notify_Address;
   end record;
   type Detail_Func_Data_Access is access Detail_Func_Data;
   function Convert is new Ada.Unchecked_Conversion
      (System.Address, Detail_Func_Data_Access);
   procedure Free_Detail_Func_Data (Data : System.Address);
   pragma Convention (C, Free_Detail_Func_Data);
   function Detail_Callback
      (Calendar : System.Address;
       Year, Month, Day : Guint;
       User_Data : System.Address) return chars_ptr;
   pragma Convention (C, Detail_Callback);
   --  Support for GtkCalendarDetailFunc

   function Detail_Callback
      (Calendar : System.Address;
       Year, Month, Day : Guint;
       User_Data : System.Address) return Interfaces.C.Strings.chars_ptr
   is
      Stub : Gtk_Calendar_Record;
      Cal  : constant Gtk_Calendar :=
         Gtk_Calendar (Get_User_Data (Calendar, Stub));
      Data : constant Detail_Func_Data_Access := Convert (User_Data);
      Details : constant String :=
         Data.Callback (Cal, Year, Month, Day, Data.User_Data);
   begin
      if Details = "" then
         return Interfaces.C.Strings.Null_Ptr;
      else
         return New_String (Details);
      end if;
   end Detail_Callback;

   procedure Free_Detail_Func_Data (Data : System.Address) is
      use System;
      procedure Unchecked_Free is new Ada.Unchecked_Deallocation
         (Detail_Func_Data, Detail_Func_Data_Access);
      D : Detail_Func_Data_Access := Convert (Data);
   begin
      if D.On_Destroy /= null and then D.User_Data /= Null_Address then
         D.On_Destroy (D.User_Data);
      end if;
      Unchecked_Free (D);
   end Free_Detail_Func_Data;
        </body>
     </extra>
  </package>

  <package id="Gtk.Size_Group">
     <doc testgtk="create_size_groups.adb">
Gtk_Size_Group provides a mechanism for grouping a number of widgets together so they all request the same amount of space. This is typically useful when you want a column of widgets to have the same size, but you can't use a Gtk_Table widget.

Note that size groups only affect the amount of space requested, not the size that the widgets finally receive. If you want the widgets in a Gtk_Size_Group to actually be the same size, you need to pack them in such a way that they get the size they request and not more. For example, if you are packing your widgets into a table, you would not include the Fill flag.
     </doc>
     <parameter name="self" ada="Size_Group" />
     <method id="gtk_size_group_new">
        <parameter name="mode" default="Both"/>
     </method>
     <method id="gtk_size_group_get_widgets" return="WidgetSList"/>
     <extra>
        <with_spec pkg="Glib.Generic_Properties"/>
        <type ctype="GtkSizeGroupMode" ada="Size_Group_Mode"
              properties="Gtk.Size_Group.Property_Size_Group_Mode">
   type Size_Group_Mode is (None, Horizontal, Vertical, Both);
   pragma Convention (C, Size_Group_Mode);
   --  This type indicates how the size of all widgets in the group match:
   --  - None: The behavior is the same as if there was no size. Each widget
   --          requests its most appropriate size.
   --  - Horizontal: All the widgets in the group will have the same width.
   --  - Vertical: All the widgets in the group will have the same height
   --  - Both: All the widgets in the group will have exactly the same size.

   package Size_Group_Mode_Properties is new
      Glib.Generic_Properties.Generic_Internal_Discrete_Property
         (Size_Group_Mode);
   type Property_Size_Group_Mode is new Size_Group_Mode_Properties.Property;
        </type>
     </extra>
  </package>

  <package id="Gtk.Alignment">
     <doc testgtk="create_alignment.adb" screenshot="gtk-alignment">
A Gtk_Alignment controls the size and alignment of its single child inside the area allocated to the alignment widget.

The scale/size settings indicate how much the child will expand to fill the container. The values should be in the range 0.0 (no expansion) to 1.0 (full expansion). Note that the scale only indicates the minimal size for the child, it does not force an absolute size.

The alignment settings indicate where in the alignment widget the child should be located. The values are in the range 0.0 (top or left) to 1.0 (bottom or right). These settings are irrelevant if the child is fully expanded.
     </doc>
     <parameter name="self" ada="Alignment"/>
     <method id="gtkada_GtkAlignment_get_xalign" bind="True"/>
     <method id="gtkada_GtkAlignment_get_xscale" bind="True"/>
     <method id="gtkada_GtkAlignment_get_yalign" bind="True"/>
     <method id="gtkada_GtkAlignment_get_yscale" bind="True"/>
  </package>

  <package id="Gtk.Status_Bar">
     <doc group="Display widgets" testgtk="create_status.adb"
          screenshot="gtk-status_bar">
A status bar is a special widget in which you can display messages. This type of widget is generally found at the bottom of application windows, and is used to display help or error messages.

This widget works as a stack of messages, ie all older messages are kept when a new one is inserted. It is of course possible to remove the most recent message from the stack. This stack behavior is especially useful when messages can be displayed from several places in your application. Thus, each one subprogram that needs to print a message can simply push it on the stack, and does not need to make sure that the user has had enough time to read the previous message (a timeout can be set to automatically remove the message after a specific delay)

Each message is associated with a specific Context_Id. Each of this context can have a special name, and these context can be used to organize the messages into categories (for instance one for help messages and one for error messages). You can then selectively remove the most recent message of each category.
     </doc>
     <parameter name="self" ada="Statusbar"/>
     <parameter name="context" type="Context_Id"/>
     <parameter name="context_id" ada="context" type="Context_Id"/>
     <parameter name="message_id" ada="Message" type="Message_Id"/>
     <method id="gtk_statusbar_get_context_id" return="Context_Id"/>
     <method id="gtkada_GtkStatusbar_get_messages" return="MessagesList"
             bind="True"/>
     <method id="gtk_statusbar_push" return="Message_Id"/>
     <extra>
        <with_spec pkg="Interfaces.C.Strings"/>
        <with_spec pkg="Glib.GSlist"/>
        <with_body pkg="Ada.Unchecked_Conversion" use="False"/>
        <type ctype="StatusBarMsg" ada="Status_Bar_Msg">
   type Context_Id is new Guint;
   type Message_Id is new Guint;

   type Status_Bar_Msg is record
      Text    : Interfaces.C.Strings.chars_ptr;
      Context : Context_Id;
      Message : Message_Id;
   end record;
   --  A message from the queue. Each of this message is associated with a
   --  specific context, and has a specific number.

   --  &lt;no_doc&gt;
   function Convert (Msg : Status_Bar_Msg) return System.Address;
   function Convert (Msg : System.Address) return Status_Bar_Msg;
   package Messages_List is new Glib.GSlist.Generic_SList (Status_Bar_Msg);
   --  &lt;/no_doc&gt;
        </type>
        <body>
   function Convert (Msg : Status_Bar_Msg) return System.Address is
   begin
      return Msg'Address;
      --  This function is anyway not supposed to be used
   end Convert;

   function Convert (Msg : System.Address) return Status_Bar_Msg is
      type Status_Bar_Msg_Access is access all Status_Bar_Msg;
      function Internal is new
        Ada.Unchecked_Conversion (System.Address, Status_Bar_Msg_Access);
   begin
      return Internal (Msg).all;
   end Convert;

        </body>
     </extra>
  </package>

  <package id="Gtk.Table">
     <doc group="Layout containers">
A Gtk_Table is a container that can contain any number of children.  Each of them is attached to a specific row and a specific column in widget.

Every row in the table must have the same height, and every column must have the same width if the table was said as Homogeneous. But you can also decide to have an heterogeneous table, where the width and height are set by the children contained in the table.  Check out the Gtk_Sheet widget for a different kind of table that can also contain text and images in a more efficient way.
     </doc>
     <parameter name="self" ada="Table"/>
     <method id="gtk_table_new">
        <doc>Create a new table. The width allocated to the table is divided into Columns columns, which all have the same width if Homogeneous is True. If Homogeneous is False, the width will be calculated with the children contained in the table. Same behavior for the rows.</doc>
     </method>
     <method id="gtk_table_attach">
        <doc>Insert a new widget in the table. All the attachments are relative to the separations between columns and rows (for instance, to insert a widget spanning the first two columns in the table, you should put Left_Attach=0 and Right_Attach=2). Same behavior for the rows. Xoptions and Yoptions indicate the behavior of the child when the table is resized (whether the child can shrink or expand). See the description in Gtk.Box for more information on the possible values. Xpadding and Ypadding are the amount of space left around the child.</doc>
        <parameter name="xoptions" default="Expand or Fill"/>
        <parameter name="yoptions" default="Expand or Fill"/>
        <parameter name="xpadding" default="0"/>
        <parameter name="ypadding" default="0"/>
     </method>
     <method id="gtk_table_attach_defaults">
        <doc>Insert a new widget in the table, with default values. No padding is put around the child, and the options are set to Expand and Fill. This call is similar to Attach with default values and is only provided for compatibility.</doc>
     </method>
     <method id="gtk_table_set_col_spacing">
        <doc>Set the spacing in pixels between Column and the next one.</doc>
     </method>
     <method id="gtk_table_set_homogeneous">
        <doc>Indicate the homogeneous status of the table. If Homogeneous is True, the rows and columns of the table will all be allocated the same width or height.</doc>
     </method>
  </package>

  <package id="Gtk.Combo_Box">
     <doc group="Trees and Lists" screenshot="gtk-combo_box"
          see="Gtk.Combo_Box_Entry">
A Gtk_Combo_Box is a widget that allows the user to choose from a list of valid choices. The Gtk_Combo_Box displays the selected choice. When activated, the Gtk_Combo_Box displays a popup which allows the user to make new choice. The style in which the selected value is displayed, and the style of the popup is determined by the current theme. It may be similar to a Gtk_Option_Menu, or similar to a Windows-style combo box.

Unlike its predecessors Gtk.Combo.Gtk_Combo and Gtk.Option_Menu.Gtk_Option_Menu, the Gtk_Combo_Box uses the model-view pattern; the list of valid choices is specified in the form of a tree model, and the display of the choices can be adapted to the data in the model by using cell renderers, as you would in a tree view. This is possible since Gtk_Combo_Box implements the Gtk_Cell_Layout interface. The tree model holding the valid choices is not restricted to a flat list, it can be a real tree, and the popup will reflect the tree structure.

In addition to the model-view API, Gtk_Combo_Box offers a simple API which is suitable for text-only combo boxes, and hides the complexity of managing the data in a model.
     </doc>
     <method id="gtk_combo_box_get_popup_accessible" bind="False"/>
     <method id="gtk_combo_box_get_active_iter" bind="False"/> <!-- below-->
     <extra>
        <spec>
   function Get_Active_Iter
     (Combo_Box : access Gtk_Combo_Box_Record)
      return Gtk.Tree_Model.Gtk_Tree_Iter;
        </spec>
        <body>
   function Get_Active_Iter
     (Combo_Box : access Gtk_Combo_Box_Record) return Gtk_Tree_Iter
   is
      function Internal
        (Combo_Box : System.Address;
         Iter      : System.Address)
         return Gboolean;
      pragma Import (C, Internal, "gtk_combo_box_get_active_iter");
      Iter : aliased Gtk_Tree_Iter;
      Tmp  : constant Gboolean := Internal
        (Get_Object (Combo_Box), Iter'Address);
   begin
      if Tmp /= 0 then
         return Iter;
      else
         return Null_Iter;
      end if;
   end Get_Active_Iter;
        </body>
     </extra>
  </package>

  <package id="Gtk.Check_Button">
     <doc screenshot="gtk-check_button" group="Buttons and Toggles"
          testgtk="create_check_buttons.adb">
A Gtk_Check_Button places a discrete Gtk_Toggle_Button next to a widget, (usually a Gtk_Label).
     </doc>

     <parameter name="self" ada="Check_Button"/>
     <method id="gtk_check_button_new" bind="False"/>
     <method id="gtk_check_button_new_with_label" ada="Gtk_New" >
        <parameter name="label" default='""' empty_maps_to_null="True"/>
        <doc>Create a check button. if Label is null, then no widget is associated with the button, and any widget can be added to the button (with Gtk.Container.Add).</doc>
     </method>
  </package>

  <package id="Gtk.Toggle_Button">
     <doc screenshot="gtk-toggle_button" group="Buttons and Toggles"
          testgtk="create_toggle_buttons.adb">
A Gtk_Toggle_Button is like a regular button, but can be in one of two states, "active" or "inactive". Its visual aspect is modified when the state is changed.

You should consider using a Gtk_Check_Button instead, since it looks nicer and provides more visual clues that the button can be toggled.
     </doc>
     <parameter name="self" ada="Toggle_Button"/>
     <method id="gtk_toggle_button_new" bind="False"/>
     <method id="gtk_toggle_button_new_with_label" ada="Gtk_New" >
        <doc>Initialize a button. If Label is "", then no label is created inside the button and you will have to provide your own child through a call to Gtk.Container.Add. This is the recommended way to put a pixmap inside a toggle button.</doc>
        <parameter name="label" default='""' empty_maps_to_null="True"/>
     </method>
     <method id="gtk_toggle_button_set_active">
        <doc>Change the state of the button. When Is_Active is True, the button is drawn as a pressed button</doc>
     </method>
     <method id="gtk_toggle_button_set_inconsistent">
        <parameter name="Setting" default="True"/>
     </method>
  </package>

  <package id="Gtk.Accel_Group">
     <doc>An accel group represents a group of keyboard accelerators, generally attached to a toplevel window. Accelerators are different from mnemonics. Accelerators are shortcuts for activating a menu item. They appear alongside the menu item they are a shortcut for. Mnemonics are shortcuts for GUI elements, such as buttons. They appear as underline characters. Menu items can have both.
     </doc>
     <parameter name="self" ada="Accel_Group"/>
     <method id="gtk_accel_group_new">
        <doc>Creates a new Gtk.Accel_Group.Gtk_Accel_Group.
Remember to call Gtk.Window.Add_Accel_Group to active the group.</doc>
     </method>
     <method id="gtk_accel_group_connect">
        <parameter name="closure" type="C_Gtk_Accel_Group_Activate"/>
     </method>
     <method id="gtk_accel_group_disconnect">
        <parameter name="closure" type="C_Gtk_Accel_Group_Activate"/>
     </method>
     <method id="gtk_accel_group_connect_by_path">
        <parameter name="closure" type="C_Gtk_Accel_Group_Activate"/>
     </method>
     <method id="gtk_accel_group_query" bind="False"/> 
        <!-- ???Would be nice -->
     <method id="gtk_accel_group_from_accel_closure">
        <parameter name="closure" type="C_Gtk_Accel_Group_Activate"/>
     </method>
     <function id="gtk_accel_groups_activate">
        <parameter name="accel_key" type="Gdk.Types.Gdk_Key_Type"/>
     </function>
     <function id="gtk_accel_groups_from_object" ada="From_Object"
               return="ObjectSList"/>
     <function id="gtk_accelerator_valid">
        <parameter name="keyval" type="Gdk.Types.Gdk_Key_Type"/>
     </function>
     <function id="gtk_accelerator_parse">
        <parameter name="accelerator_key" ctype="GdkKeyType*"/>
     </function>
     <function id="gtk_accelerator_name">
        <parameter name="accelerator_key" type="Gdk.Types.Gdk_Key_Type"/>
     </function>
     <function id="gtk_accelerator_get_label">
        <parameter name="accelerator_key" type="Gdk.Types.Gdk_Key_Type"/>
     </function>
     <function id="gtk_accelerator_set_default_mod_mask"
               ada="Set_Default_Mod_Mask" />
     <function id="gtk_accelerator_get_default_mod_mask"
               return="GdkModifierType" ada="Get_Default_Mod_Mask"/>
     <extra>
        <type ctype="GtkAccelFlags" ada="Gtk_Accel_Flags">
   type Gtk_Accel_Flags is new Guint;
   Accel_Visible : constant Gtk_Accel_Flags := 2 ** 0;
   Accel_Locked  : constant Gtk_Accel_Flags := 2 ** 1;
   Accel_Mask    : constant Gtk_Accel_Flags := 16#07#;
        </type>
        <type ctype="GtkAccelKey" ada="Gtk_Accel_Key">
   type Gtk_Accel_Key is record
      Accel_Key  : Gdk.Types.Gdk_Key_Type;
      Accel_Mods : Gdk.Types.Gdk_Modifier_Type;
      Flags      : Gtk_Accel_Flags;
   end record;
   pragma Convention (C, Gtk_Accel_Key);
        </type>
        <type ctype="GtkAccelGroupActive" ada="Gtk_Accel_Group_Activate">
   type Gtk_Accel_Group_Activate is access function
     (Accel_Group   : access Gtk_Accel_Group_Record'Class;
      Acceleratable : Glib.Object.GObject;
      Keyval        : Gdk.Types.Gdk_Key_Type;
      Modifier      : Gdk.Types.Gdk_Modifier_Type) return Boolean;

   type C_Gtk_Accel_Group_Activate is access function
     (Accel_Group   : System.Address;
      Acceleratable : System.Address;
      Keyval        : Gdk.Types.Gdk_Key_Type;
      Modifier      : Gdk.Types.Gdk_Modifier_Type) return Boolean;
   pragma Convention (C, C_Gtk_Accel_Group_Activate);
   --  Same as Gtk_Accel_Group_Activate, but passing directly the C values.
   --  You must use Get_User_Data to convert to the Ada types.
        </type>
        <type ctype="GtkAccelGroupFindFunc" ada="C_Gtk_Accel_Group_Find_Func">
   type C_Gtk_Accel_Group_Find_Func is access function
      (Key           : access Gtk_Accel_Key;
       Closure       : C_Gtk_Accel_Group_Activate;
       Data          : System.Address) return Boolean;
   pragma Convention (C, C_Gtk_Accel_Group_Find_Func);
   --  When a match is found, must return True.
   --  Must not modify Key
        </type>
     </extra>
  </package>

  <package id="Gtk.Radio_Button">
     <doc screenshot="gtk-radio_button" group="Buttons and Toggles"
          testgtk="create_radio_button.adb">
A Gtk_Radio_Button is a simple button that has two states, like a Gtk_Toggle_Button. However, Gtk_Radio_Buttons can be grouped together to get a special behavior: only one button in the group can be active at any given time. Thus, when the user selects one of the buttons from the group, the button that was previously selected is disabled.

The radio buttons always belongs to a group, even if there is only one in this group.</doc>
     <parameter name="self" ada="Radio_Button"/>
     <parameter name="param1" ada="Group"/>
     <method id="gtk_radio_button_new" bind="False"/>
     <method id="gtk_radio_button_new_from_widget" bind="False"/>
     <method id="gtk_radio_button_new_with_label" ada="Gtk_New" >
        <doc>Creates or initializes a new radio button, belonging to Group. If Label is left as the empty string, then the button will not have any child and you are free to put any thing you want in it, including a pixmap. To initialize the group (when creating the first button), leave Group to the Null_List. You can later get the new group that is created with a call to the Group subprogram below.</doc>
        <parameter name="group" default="Widget_SList.Null_List" ctype="WidgetSList"/>
        <parameter name="label" default='""' empty_maps_to_null="True"/>
     </method>
     <method id="gtk_radio_button_new_with_label_from_widget" ada="Gtk_New" >
        <parameter name="label" default='""' empty_maps_to_null="True"/>
     </method>
     <method id="gtk_radio_button_new_with_mnemonic">
        <parameter name="group" default="Widget_SList.Null_List" ctype="WidgetSList"/>
     </method>
     <method id="gtk_radio_button_new_with_mnemonic_from_widget" ada="Gtk_New_With_Mnemonic">
        <doc extend="true">To initialize a new group (when creating the first button), you should pass it null or a button that has not been created with Gtk_New, as in the example below.</doc>
     </method>
     <method id="gtk_radio_button_get_group" return="WidgetSList"/>
     <method id="gtk_radio_button_set_group">
        <parameter name="group" ctype="WidgetSList"/>
     </method>
  </package>

  <package id="Gtk.Radio_Action">
     <doc group="Action-based menus" see="Gtk_Action">A Gtk_Radio_Action is similar to Gtk_Radio_Menu_Item. A number of radio actions can be linked together so that only one may be active at any one time.</doc>
     <parameter name="self" ada="Action"/>
     <method id="gtk_radio_action_new">
        <parameter name="label" default='""'/>
        <parameter name="tooltip" default='""'/>
        <parameter name="stock_id" default='""'/>
     </method>
     <method id="gtk_radio_action_set_group">
        <parameter name="group" ctype="WidgetSList"/>
        <doc extend="true">A common way to set up a group of radio group is the following:

%PRE%      Group  : GSlist := null;
      Action : Gtk_Radio_Action;
      while ... loop
         Gtk_New (Action, ...);
         Set_Group (Action, Group);
         Group := Get_Group (Action);
      end loop;</doc>
     </method>
     <method id="gtk_radio_action_get_group" return="WidgetSList"/>
  </package>

  <package id="Gtk.Separator">
     <doc group="Ornaments" screenshot="gtk-separator">
A separator is a vertical or horizontal line that can be displayed between
widgets, to provide visual grouping of the widgets into meaningful groups.
It is for instance used in dialogs to isolate the actual contents of the
dialogs and the various buttons to acknowledge the dialog (OK, Cancel,...)</doc>
      <parameter name="self" ada="Separator"/>
  </package>
  <package id="Gtk.Vseparator" into="Separator">
      <type name="Gtk_Vseparator" subtype="true"/>
      <method id="gtk_vseparator_new" ada="Gtk_New_Vseparator"/>
      <parameter name="self" ada="Separator"/>
      <method id="gtk_vseparator_get_type" ada="Vseparator_Get_Type" />
  </package>
  <package id="Gtk.Hseparator" into="Separator">
      <type name="Gtk_Hseparator" subtype="true"/>
      <method id="gtk_hseparator_new" ada="Gtk_New_Hseparator"/>
      <parameter name="self" ada="Separator"/>
      <method id="gtk_hseparator_get_type" ada="Hseparator_Get_Type" />
  </package>

  <package id="Gtk.Separator_Menu_Item">
     <doc group="Menus and Toolbars">
This widget serves as separator between menu items. It is represented graphically as a horizontal line between two items, and is used to group items into meaningful groups.</doc>
  </package>

</GIR>
