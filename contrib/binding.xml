<?xml version="1.0"?>

<!--  This file overrides parts of the .gir files. -->

<GIR xmlns:gir="http://www.gtk.org/introspection/core/1.0"
     xmlns:c="http://www.gtk.org/introspection/c/1.0">

   <!-- ################################################
        Gdk.Device
        ################################################-->

   <package id="GdkDevice">
      <enum ctype="GdkDeviceType" />
      <enum ctype="GdkAxisFlags" />
      <list ada="Device_List" ctype="GdkDevice"/>
      <method id="::changed" bind="False" /> <!-- elaboration circularity -->
      <method id="gdk_device_get_axis" bind="False" /><!-- need support for array of gdoubles -->
      <method id="gdk_device_get_axis_value" bind="False" /><!-- need support for array of gdoubles -->
      <method id="gdk_device_get_history" bind="False" /><!-- need support for array of Gdk_Time_Coord -->
      <method id="gdk_device_free_history" bind="False" /><!-- no need while we don't bind get_history -->
      <method id="gdk_device_grab_info_libgtk_only" bind="False" /><!-- not part of library -->
      <method id="gdk_device_get_key" return="" bind="False"/><!-- pending L118-010 -->
      <method id="gdk_device_get_window_at_position" bind="False"/><!-- below -->
      <method id="gdk_device_get_position" bind="False"/><!-- pending resolution of a problem with generating the stub object -->
      <method id="gdk_device_list_axes" bind="False"/><!-- no support for atom lists -->
      <method id="gdk_device_list_slave_devices" bind="False"/><!-- no support
      for Gdk_Device_Type_Master lists -->

      <method id="gdk_device_get_seat" return="GObject*"/>
      <method id="::tool-changed">
        <parameter name="tool" ctype="GObject*"/>
      </method>

      <extra>
         <spec>
   procedure Get_Window_At_Position
      (Self   : not null access Gdk_Device_Record;
       Win_X  : out Gint;
       Win_Y  : out Gint;
       Window : out Gdk.Gdk_Window);
   --  Obtains the window underneath Device, returning the location of the
   --  device in Win_X and Win_Y. Returns null if the window tree under Device
   --  is not known to GDK (for example, belongs to another application).
   --  As a slave device coordinates are those of its master pointer, This
   --  function may not be called on devices of type
   --  Gdk.Device.Gdk_Device_Type_Slave, unless there is an ongoing grab on
   --  them, see Gdk.Device.Grab.
   --  Since: gtk+ 3.0
   --  "win_x": return location for the X coordinate of the device location,
   --  relative to the window origin, or null.
   --  "win_y": return location for the Y coordinate of the device location,
   --  relative to the window origin, or null.

   procedure Set_Device
      (Event   : Gdk.Event.Gdk_Event;
       Device  : not null access Gdk_Device_Record);
   --  Sets the device for Event to Device. The event must
   --  have been allocated by GTK+, for instance, by gdk_event_copy().

   procedure Set_Source_Device
      (Event   : Gdk.Event.Gdk_Event;
       Device  : not null access Gdk_Device_Record);
   --  Sets the slave device for Event to Device.
   --  The event must have been allocated by GTK+,
   --  for instance by gdk_event_copy().
         </spec>
         <body>
   procedure Set_Source_Device
      (Event  : Gdk.Event.Gdk_Event;
       Device : not null access Gdk_Device_Record)
   is
      procedure Internal (Event : Gdk.Event.Gdk_Event; D : System.Address);
      pragma Import (C, Internal, "gdk_event_set_source_device");
   begin
      Internal (Event, Get_Object (Device));
   end Set_Source_Device;

   procedure Set_Device
      (Event  : Gdk.Event.Gdk_Event;
       Device : not null access Gdk_Device_Record)
   is
      procedure Internal (Event : Gdk.Event.Gdk_Event; D : System.Address);
      pragma Import (C, Internal, "gdk_event_set_device");
   begin
      Internal (Event, Get_Object (Device));
   end Set_Device;

   procedure Get_Window_At_Position
      (Self   : not null access Gdk_Device_Record;
       Win_X  : out Gint;
       Win_Y  : out Gint;
       Window : out Gdk.Gdk_Window)
   is
      function Internal
         (Self      : System.Address;
          Acc_Win_X : access Gint;
          Acc_Win_Y : access Gint) return Gdk.Gdk_Window;
      pragma Import (C, Internal, "gdk_device_get_window_at_position");
      Acc_Win_X  : aliased Gint;
      Acc_Win_Y  : aliased Gint;
   begin
      Window := Internal (Get_Object (Self), Acc_Win_X'Access, Acc_Win_Y'Access);
      Win_X := Acc_Win_X;
      Win_Y := Acc_Win_Y;
   end Get_Window_At_Position;
         </body>
      </extra>
   </package>

   <!-- ################################################
        Gdk.DeviceTool
        ################################################-->

   <package id="GdkDeviceTool">
     <enum ctype="GdkDeviceToolType" />
   </package>

   <!-- ################################################
        Gdk.Monitor
        ################################################-->

   <package id="GdkMonitor">
     <enum ctype="GdkSubpixelLayout"/>
     <method id="gdk_monitor_get_display" return="GObject*"/>
   </package>

   <!-- ################################################
        Gdk.Drag_Contexts
        ################################################-->

   <package id="GdkDragContext">
      <enum ctype="GdkDragAction" prefix="GDK_"/>
      <enum ctype="GdkDragCancelReason" prefix="GDK_"/>
      <enum ctype="GdkDragProtocol" prefix="GDK_"/>
      <method id="gdk_drag_context_list_targets" bind="False"/><!-- not supposed to be used by applications -->
      <method id="::action-changed">
        <parameter name="action" ctype="GdkDragAction"/>
      </method>
      <method id="::cancel">
        <parameter name="reason" ctype="GdkDragCancelReason"/>
      </method>
   </package>

   <!-- ################################################
        Gdk.Screen
        ################################################-->

   <package id="GdkScreen">
     <doc group="Gdk, the low-level API"/>
     <parameter name="self" ada="Screen"/>
     <method id="gdk_screen_get_setting" bind="False" />
     <method id="::composited-changed" bind="False" /> <!-- elaboration circularity -->
     <method id="::monitors-changed" bind="False" /> <!-- elaboration circularity -->
     <method id="::size-changed" bind="False" /> <!-- elaboration circularity -->

     <method id="gdk_screen_get_toplevel_windows" return="WindowList" bind="False"/>  <!--  circular dep -->
     <method id="gdk_screen_get_window_stack" return="WindowList" bind="False"/> <!-- circular dep with GdkWindow-->
     <method id="gdk_screen_list_visuals" return="WindowList" bind="False"/> <!-- circular dep with GdkWindow-->
     <extra>
       <with_spec pkg="Gdk.Types" />
       <spec>
   -------------
   -- Display --
   -------------
   --  These subprograms should really be in gdk-display.ads to match what is
   --  done for gtk+ itself, but that would create dependency circularities.
   --  Ada 2012 has support for these, but we want GtkAda to build with Ada95
   --  compilers.

   function Get_Screen
     (Display    : access Gdk.Display.Gdk_Display_Record'Class;
      Screen_Num : Glib.Gint)
      return Gdk_Screen;
   --  Returns a screen object for one of the screens of the display.

   function Get_Default_Screen
     (Display : access Gdk.Display.Gdk_Display_Record'Class) return Gdk_Screen;
   --  Get the default Gdk_Screen for display.

   procedure Get_Pointer
     (Display : access Gdk.Display.Gdk_Display_Record'Class;
      Screen  : out Gdk_Screen;
      X       : out Glib.Gint;
      Y       : out Glib.Gint;
      Mask    : out Gdk.Types.Gdk_Modifier_Type);
   --  Gets the current location of the pointer and the current modifier
   --  mask for a given display.
   --  (X, Y) are coordinates relative to the root window on the display

   procedure Warp_Pointer
     (Display : access Gdk.Display.Gdk_Display_Record'Class;
      Screen  : access Gdk_Screen_Record;
      X       : Glib.Gint;
      Y       : Glib.Gint);
   --  Warps the pointer of display to the point x,y on the screen screen,
   --  unless the pointer is confined to a window by a grab, in which case it
   --  will be moved as far as allowed by the grab. Warping the pointer creates
   --  events as if the user had moved the mouse instantaneously to the
   --  destination.
   --
   --  Note that the pointer should normally be under the control of the user.
   --  This function was added to cover some rare use cases like keyboard
   --  navigation support for the color picker in the GtkColorSelectionDialog.
       </spec>
       <body>
   function Get_Screen
     (Display    : access Gdk_Display_Record'Class;
      Screen_Num : Gint)
      return Gdk_Screen
   is
      function Internal
        (Display    : System.Address;
         Screen_Num : Gint)
         return System.Address;
      pragma Import (C, Internal, "gdk_display_get_screen");
      --  External binding: gdk_display_get_screen
      Stub : Gdk_Screen_Record;
   begin
      return Gdk_Screen
        (Get_User_Data
          (Internal (Get_Object (Display), Screen_Num), Stub));
   end Get_Screen;

   function Get_Default_Screen
     (Display : access Gdk_Display_Record'Class)
      return Gdk_Screen
   is
      function Internal
        (Display : System.Address)
         return System.Address;
      pragma Import (C, Internal, "gdk_display_get_default_screen");
      --  External binding: gdk_display_get_default_screen
      Stub : Gdk_Screen_Record;
   begin
      return Gdk_Screen
        (Get_User_Data
          (Internal (Get_Object (Display)), Stub));
   end Get_Default_Screen;

   procedure Get_Pointer
     (Display : access Gdk_Display_Record'Class;
      Screen  : out Gdk_Screen;
      X       : out Gint;
      Y       : out Gint;
      Mask    : out Gdk_Modifier_Type)
   is
      procedure Internal
        (Display : System.Address;
         Screen  : out System.Address;
         X       : out Gint;
         Y       : out Gint;
         Mask    : out Gdk_Modifier_Type);
      pragma Import (C, Internal, "gdk_display_get_pointer");
      --  External binding: gdk_display_get_pointer

      S    : System.Address;
      Stub : Gdk_Screen_Record;

   begin
      Internal (Get_Object (Display), S, X, Y, Mask);
      Screen := Gdk_Screen (Get_User_Data (S, Stub));
   end Get_Pointer;

   procedure Warp_Pointer
     (Display : access Gdk.Display.Gdk_Display_Record'Class;
      Screen  : access Gdk_Screen_Record;
      X       : Glib.Gint;
      Y       : Glib.Gint)
   is
      procedure Internal (D, S : System.Address; X, Y : Gint);
      pragma Import (C, Internal, "gdk_display_warp_pointer");
      --  External binding: gdk_display_warp_pointer
   begin
      Internal (Get_Object (Display), Get_Object (Screen), X, Y);
   end Warp_Pointer;
       </body>
     </extra>
   </package>

   <!-- ################################################
        Gdk.Seat
        ################################################-->

   <package id="GdkSeat">
     <enum ctype="GdkSeatCapabilities"/>
     <list ada="Gdk_Seat_List" ctype="GdkSeat*"/>
     <method id="gdk_seat_get_slaves" return="DeviceList"/>
     <method id="gdk_seat_get_display" return ="GObject*"/>
      <method id="::tool-added">
        <parameter name="tool" ctype="GObject*"/>
      </method>
      <method id="::tool-removed">
        <parameter name="tool" ctype="GObject*"/>
      </method>
      <method id="::device-added">
        <parameter name="device" ctype="GObject*"/>
      </method>
      <method id="::device-removed">
        <parameter name="device" ctype="GObject*"/>
      </method>
      <extra>
        <with_spec pkg="Gdk.Types" />
      </extra>
   </package>

   <!-- ################################################
        Gtk.Aspect_Frame
        ################################################-->

   <package id="GtkAspectFrame">
     <doc testgtk="create_frame.adb" group="Layout Containers"/>
     <parameter name="self" ada="Aspect_Frame"/>
     <method id="gtk_aspect_frame_new">
       <parameter name="label" default='""' allow-none="1"/>
     </method>
   </package>

   <!-- ###################################################
        Gtk.Button
        ###################################################-->

   <package id="GtkButton">
      <doc screenshot="gtk-button" group="Buttons and Toggles"
           testgtk="create_buttons.adb"/>
      <parameter name="self" ada="Button"/>
      <method id="gtk_button_new" bind="False"/>
      <method id="gtk_button_new_with_label" ada="Gtk_New" >
         <parameter name="label" default='""' allow-none="1"/>
      </method>
   </package>

   <!-- ###################################################
        Gtk.Cell_Area
        ###################################################-->

   <package id="GtkCellArea">
      <doc group="Layout Containers"/>
      <method id="gtk_cell_area_cell_get_valist" bind="False"/><!-- va_list -->
      <method id="gtk_cell_area_cell_set_valist" bind="False"/><!-- va_list -->
      <method id="gtk_cell_area_add_with_properties" bind="False"/><!-- varargs-->
      <method id="gtk_cell_area_cell_get" bind="False"/><!-- varargs-->
      <method id="gtk_cell_area_cell_set" bind="False"/><!-- varargs-->
      <method id="gtk_cell_area_get_cell_allocation">
         <parameter name="cell_area" direction="access" />
         <parameter name="allocation" direction="access" />
      </method>
      <method id="gtk_cell_area_get_focus_siblings" return="ObjectList"/>
      <method id="gtk_cell_area_get_cell_at_position" bind="False"/>
      <method id="::add-editable">
        <parameter name="cell_area" type="Gdk.Rectangle.Gdk_Rectangle"/>
      </method>
      <!-- bound manually below -->
      <extra>
        <spec>
   function Get_Area
      (Context : access Gtk_Cell_Area_Context_Record)
       return Gtk.Cell_Area.Gtk_Cell_Area;
   --  Fetches the Gtk.Cell_Area.Gtk_Cell_Area this Context was created by.
   --  This is generally unneeded by layouting widgets; however it is important
   --  for the context implementation itself to fetch information about the
   --  area it is being used for.
   --  For instance at GtkCellAreaContextClass.allocate time its important to
   --  know details about any cell spacing that the Gtk.Cell_Area.Gtk_Cell_Area
   --  is configured with in order to compute a proper allocation.
   --  Since: gtk+ 3.0

   function Get_Area
      (Cell_Layout : Gtk_Cell_Layout) return Gtk.Cell_Area.Gtk_Cell_Area;
   --  Returns the underlying Gtk.Cell_Area.Gtk_Cell_Area which might be
   --  Cell_Layout if called on a Gtk.Cell_Area.Gtk_Cell_Area or might be null
   --  if no Gtk.Cell_Area.Gtk_Cell_Area is used by Cell_Layout.
   --  Since: gtk+ 3.0

   procedure Get_Cell_At_Position
      (Self       : access Gtk_Cell_Area_Record;
       Context    : access Gtk.Cell_Area_Context.Gtk_Cell_Area_Context_Record'Class;
       Widget     : access Gtk.Widget.Gtk_Widget_Record'Class;
       Cell_Area  : Gdk.Rectangle.Gdk_Rectangle;
       X          : Gint;
       Y          : Gint;
       Alloc_Area : out Gdk.Rectangle.Gdk_Rectangle;
       Renderer   : out Gtk.Cell_Renderer.Gtk_Cell_Renderer);
   --  Gets the Gtk.Cell_Renderer.Gtk_Cell_Renderer at X and Y coordinates
   --  inside Area and optionally returns the full cell allocation for it
   --  inside Cell_Area.
   --  Since: gtk+ 3.0
   --  "context": the Gtk.Cell_Area_Context.Gtk_Cell_Area_Context used to hold
   --  sizes for Area.
   --  "widget": the Gtk.Widget.Gtk_Widget that Area is rendering on
   --  "cell_area": the whole allocated area for Area in Widget for this row
   --  "x": the x position
   --  "y": the y position
   --  "alloc_area": where to store the inner allocated area of the returned
   --  cell renderer, or null.
   --  "renderer": the rendered that was found.
        </spec>
        <body>
   --------------
   -- Get_Area --
   --------------

   function Get_Area
      (Context : access Gtk_Cell_Area_Context_Record)
       return Gtk.Cell_Area.Gtk_Cell_Area
   is
      function Internal (Context : System.Address) return System.Address;
      pragma Import (C, Internal, "gtk_cell_area_context_get_area");
      Stub_Gtk_Cell_Area : Gtk.Cell_Area.Gtk_Cell_Area_Record;
   begin
      return Gtk.Cell_Area.Gtk_Cell_Area
        (Get_User_Data (Internal (Get_Object (Context)), Stub_Gtk_Cell_Area));
   end Get_Area;

   --------------
   -- Get_Area --
   --------------

   function Get_Area
      (Cell_Layout : Gtk_Cell_Layout) return Gtk.Cell_Area.Gtk_Cell_Area
   is
      function Internal
         (Cell_Layout : Gtk_Cell_Layout) return System.Address;
      pragma Import (C, Internal, "gtk_cell_layout_get_area");
      Stub_Gtk_Cell_Area : Gtk.Cell_Area.Gtk_Cell_Area_Record;
   begin
      return Gtk.Cell_Area.Gtk_Cell_Area (Get_User_Data (Internal (Cell_Layout), Stub_Gtk_Cell_Area));
   end Get_Area;

   --------------------------
   -- Get_Cell_At_Position --
   --------------------------

   procedure Get_Cell_At_Position
      (Self       : access Gtk_Cell_Area_Record;
       Context    : access Gtk.Cell_Area_Context.Gtk_Cell_Area_Context_Record'Class;
       Widget     : access Gtk.Widget.Gtk_Widget_Record'Class;
       Cell_Area  : Gdk.Rectangle.Gdk_Rectangle;
       X          : Gint;
       Y          : Gint;
       Alloc_Area : out Gdk.Rectangle.Gdk_Rectangle;
       Renderer   : out Gtk.Cell_Renderer.Gtk_Cell_Renderer)
   is
      function Internal
         (Self           : System.Address;
          Context        : System.Address;
          Widget         : System.Address;
          Cell_Area      : Gdk.Rectangle.Gdk_Rectangle;
          X              : Gint;
          Y              : Gint;
          Acc_Alloc_Area : access Gdk.Rectangle.Gdk_Rectangle)
          return System.Address;
      pragma Import (C, Internal, "gtk_cell_area_get_cell_at_position");
      Acc_Alloc_Area         : aliased Gdk.Rectangle.Gdk_Rectangle;
      Stub_Gtk_Cell_Renderer : Gtk.Cell_Renderer.Gtk_Cell_Renderer_Record;
      Tmp_Return             : System.Address;
   begin
      Tmp_Return := Internal
        (Get_Object (Self), Get_Object (Context), Get_Object (Widget),
         Cell_Area, X, Y, Acc_Alloc_Area'Access);
      Alloc_Area := Acc_Alloc_Area;
      Renderer := Gtk.Cell_Renderer.Gtk_Cell_Renderer
        (Get_User_Data (Tmp_Return, Stub_Gtk_Cell_Renderer));
   end Get_Cell_At_Position;
        </body>
      </extra>
   </package>

   <!-- ###################################################
        Gtk.Cell_Area_Context
        ###################################################-->

   <package id="GtkCellAreaContext">
      <doc group="Layout Containers"/>
      <method id="gtk_cell_area_context_get_area" bind="False"/>
      <!-- in Gtk.Cell_Area -->
   </package>

   <!-- ################################################
        Gtk.Color_Selection
        ################################################-->

   <package id="GtkColorSelection">
      <doc testgtk="create_color_selection.adb"
           screenshot="gtk-colorsel"
           group="Drawing">
A Gtk_Color_Selection widget is a complex dialog that allows the user
to select a color based either on its (Red, Green, Blue) or its
(Hue, Saturation, Value).
An additional field is provided to select the opacity of the color (this
is usually called the alpha channel).

See Gtk.Color_Selection_Dialog for a version of this widget that comes with
its own dialog.

See Gtk.Extra.Color_Combo for a different way to select colors.
      </doc>
     <parameter name="self" ada="Colorsel"/>

     <!-- Bound manually below -->
     <method id="gtk_color_selection_palette_from_string" bind="False"/>
     <method id="gtk_color_selection_palette_to_string" bind="False"/>

     <extra>
        <spec>
   type Gtk_Color_Selection_Change_Palette_With_Screen_Func is access procedure
      (Screen   : System.Address;  --  Convert to Gdk_Screen with Get_User_Data
       Colors   : Gdk.Color.Gdk_Color_Unconstrained_Array;
       N_Colors : Gint);
   pragma Convention (C, Gtk_Color_Selection_Change_Palette_With_Screen_Func);
   --  This function should save the new palette contents, and update the
   --  Gtk_Settings property "gtk-color-palette" so all Gtk_Color_Selection
   --  widgets will be modified, including the current one. For instance, you
   --  would do:
   --    Set_String_Property
   --      (Get_Default, Gtk_Color_Palette, Palette_To_String (Colors), "Foo");

   function Palette_From_String
     (Str : String) return Gdk.Color.Gdk_Color_Array;
   --  Parses a color palette string. This string is a colon-separated list of
   --  color names readable by Gdk.Color.Parse.
   --  An empty array is returned if Str couldn't be parsed

   function Palette_To_String
     (Colors   : Gdk.Color.Gdk_Color_Array) return String;
   --  Encodes a palette as a string, useful for persistent storage.
        </spec>

        <with_body pkg="Gtkada.C"/>
        <with_body pkg="Gtkada.Types"/>

        <body>
   package Color_Arrays is new Gtkada.C.Unbounded_Arrays
     (Gdk.Color.Gdk_Color, Gdk.Color.Null_Color, Natural,
      Gdk.Color.Gdk_Color_Array);

   function Palette_From_String (Str : String) return Gdk_Color_Array is
      use Color_Arrays;
      function Internal
        (Str : String;
         Colors : access Unbounded_Array_Access; N : access Gint)
         return Gboolean;
      pragma Import (C, Internal, "gtk_color_selection_palette_from_string");

      N      : aliased Gint;
      Output : aliased Unbounded_Array_Access;
   begin
      if Internal (Str &amp; ASCII.NUL, Output'Access, N'Access) = 0 then
         Output := null;
      end if;

      declare
         Result : constant Gdk_Color_Array := To_Array (Output, Integer (N));
      begin
         g_free (Output);
         return Result;
      end;
   end Palette_From_String;

   function Palette_To_String (Colors : Gdk_Color_Array) return String is
      function Internal
        (Colors   : System.Address;
         N_Colors : Gint)
         return Gtkada.Types.Chars_Ptr;
      pragma Import (C, Internal, "gtk_color_selection_palette_to_string");
      Str : chars_ptr;
   begin
      if Colors'Length = 0 then
         return "";
      else
         Str := Internal (Colors (Colors'First)'Address, Colors'Length);
         declare
            Result : constant String := Value (Str);
         begin
            g_free (Str);
            return Result;
         end;
      end if;
   end Palette_To_String;
       </body>
     </extra>
   </package>

   <!-- ################################################
        Gtk.Color_Selection_Dialog
        ################################################-->

   <package id="GtkColorSelectionDialog">
      <doc group="Drawing">
The Gtk_Color_Selection_Dialog provides a standard dialog which allows the
user to select a color much like the Gtk_File_Selection provides a standard
dialog for file selection.
      </doc>
     <parameter name="self" ada="Color_Selection_Dialog"/>
     <method id="gtk_color_selection_dialog_get_color_selection"
         return="GtkColorSelection">
     </method>
   </package>

   <!-- ################################################
        Gtk.Combo_Box
        ################################################-->

   <package id="GtkComboBox">
     <doc group="Numeric/Text Data Entry"/>
     <parameter name="self" ada="Combo_Box"/>
     <method id="gtk_combo_box_popup_for_device" bind="False" />
     <method id="gtk_combo_box_get_popup_accessible" bind="False" />
     <method id="gtk_combo_box_get_active_iter" bind="False"/> <!-- below-->
     <extra>

         <with_body pkg="Gtk.GEntry" />
        <spec>
   function Get_Active_Iter
     (Combo_Box : not null access Gtk_Combo_Box_Record)
      return Gtk.Tree_Model.Gtk_Tree_Iter;
   --  Return the currently active iter

   function Get_Active_Text
     (Combo_Box : not null access Gtk_Combo_Box_Record)
      return UTF8_String;
   --  Return the text present in the entry if it has one, or the empty string

        </spec>
        <body>
   function Get_Active_Iter
     (Combo_Box : not null access Gtk_Combo_Box_Record) return Gtk_Tree_Iter
   is
      function Internal
        (Combo_Box : System.Address;
         Iter      : System.Address)
         return Gboolean;
      pragma Import (C, Internal, "gtk_combo_box_get_active_iter");
      Iter : aliased Gtk_Tree_Iter;
      Tmp  : constant Gboolean := Internal
        (Get_Object (Combo_Box), Iter'Address);
   begin
      if Tmp /= 0 then
         return Iter;
      else
         return Null_Iter;
      end if;
   end Get_Active_Iter;

   function Get_Active_Text
     (Combo_Box : not null access Gtk_Combo_Box_Record)
      return UTF8_String is
   begin
      if not Combo_Box.Get_Has_Entry then
         return "";
      end if;

      return Gtk_Entry (Combo_Box.Get_Child).Get_Text;
   end Get_Active_Text;

        </body>
     </extra>
   </package>

   <!-- ################################################
        Gtk.Combo_Box_Text
        ################################################-->

   <package id="GtkComboBoxText">
     <doc group="Numeric/Text Data Entry"/>
   </package>

   <!-- ################################################
        Gtk.EventBox
        ################################################-->

   <package id="GtkEventBox">
     <doc group="Layout Containers"/>
     <parameter name="self" ada="Event_Box"/>
     <method id="gtk_event_box_new">
         <doc>
Create a new box.

The box's child can then be set using the Gtk.Container.Add function.
         </doc>
     </method>
   </package>


   <!-- ################################################
        Gtk.Font_Selection
        ################################################-->

   <package id="GtkFontSelection">
      <doc testgtk="create_font_selection.adb"
           screenshot="gtk-fontsel"
           group="Selectors">
This widget provides a nice way for the user of your application to
select fonts.
It first searches on your system for the list of fonts available, and
displays a set of boxes to select them based on their name, their
weight, their size, etc.
This widget is provided in two forms, one widget that can be embedded
in any container, a Gtk_Font_Selection, whereas the other one comes
directly in its own separate window (to be popped up as a dialog).

Some filters can be applied to the widget, when you want the user to
select only a font only among a specific subset (like bitmap or
true-type fonts for instance).
There are two kinds of filters: a base filter, set in your application
and that the user can not change; a user filter that can be modified
interactively by the user.
      </doc>
     <parameter name="self" ada="Fontsel"/>
     <method id="gtk_font_selection_get_family" bind="False"/>
     <method id="gtk_font_selection_get_face" bind="False"/>
   </package>

   <!-- ################################################
        Gtk.Font_Selection_Dialog
        ################################################-->

   <package id="GtkFontSelectionDialog">
      <doc testgtk="create_font_selection.adb"
           screenshot="gtk-fontsel"
           group="Selectors">
This widget provides a dialog for selecting a font.
See also Gtk.Font_Selection.
      </doc>
     <parameter name="self" ada="Dialog"/>
   </package>

   <!-- ###################################################
        Gtk.Frame
        ###################################################-->
   <package id="GtkFrame">
      <doc screenshot="gtk-frame" testgtk="create_frame.adb"
           group="Ornaments">
This is a very convenient widget to visually group related widgets (like
groups of buttons for instance), possibly with a title to explain the
purpose of this group.

A Gtk_Frame has only one child, so you have to put a container like for
instance a Gtk_Box inside if you want the frame to surround multiple
widgets.
      </doc>
      <parameter name="self" ada="Frame"/>

      <method id="gtk_frame_new">
         <parameter name="label" default='""' allow-none="1"/>
      </method>
   </package>

   <!-- ################################################
        Gtk.Label
        ################################################-->

   <package id="GtkLabel">
      <doc screenshot="gtk-label" testgtk="create_label.adb"
           group="Display widgets"/>
      <parameter name="self" ada="Label"/>
      <method id="gtk_label_new">
         <parameter name="str" default='""'/>
      </method>
      <method id="gtk_label_get" bind="false"/>
      <method id="gtk_label_select_region">
         <parameter name="start_offset" default="-1"/>
         <parameter name="end_offset" default="-1"/>
      </method>
      <method id="gtk_label_get_selection_bounds"
         return_as_param="Has_Selection"/>
      <method id="gtk_label_set_pattern">
         <doc>
Change the underlines pattern.

Pattern is a simple string made of underscore and space characters,
matching the ones in the string. GtkAda will underline every letter
that matches an underscore.

An empty string disables the underlines.

example: If the text is FooBarBaz and the Pattern is "___   ___"
then both "Foo" and "Baz" will be underlined, but not "Bar".
         </doc>
      </method>
   </package>

   <!-- ###################################################
        Gtk.Notebook
        ###################################################-->

   <package id="GtkNotebook">
      <enum ctype="GtkNotebookTab"/>
      <doc screenshot="gtk-notebook" group="Layout containers"
           testgtk="create_notebook.adb"/>
      <parameter name="self" ada="Notebook"/>
      <method id="gtk_notebook_set_scrollable">
         <parameter name="scrollable" default="True" />
      </method>
      <method id="gtk_notebook_set_tab_reorderable">
         <parameter name="reorderable" default="True" />
      </method>
      <method id="gtk_notebook_set_current_page">
         <parameter name="page_num" default="-1" />
      </method>
      <method id="gtk_notebook_set_show_border">
         <parameter name="show_border" default="True" />
      </method>
      <method id="gtk_notebook_append_page_menu" return="void" />
      <method id="gtk_notebook_set_show_tabs">
         <parameter name="show_tabs" default="True" />
      </method>
      <method id="gtk_notebook_set_tab_detachable">
         <parameter name="detachable" default="True" />
      </method>
      <extra>
        <spec>
   procedure Append_Page
     (Notebook  : access Gtk_Notebook_Record;
      Child     : access Gtk.Widget.Gtk_Widget_Record'Class);
   procedure Append_Page
     (Notebook  : access Gtk_Notebook_Record;
      Child     : access Gtk.Widget.Gtk_Widget_Record'Class;
      Tab_Label : access Gtk.Widget.Gtk_Widget_Record'Class);
   procedure Prepend_Page
     (Notebook  : access Gtk_Notebook_Record;
      Child     : access Gtk.Widget.Gtk_Widget_Record'Class;
      Tab_Label : access Gtk.Widget.Gtk_Widget_Record'Class);
   --  Convenience functions, same as above but discarding the return value.
        </spec>
        <body>
   procedure Append_Page
     (Notebook  : access Gtk_Notebook_Record;
      Child     : access Gtk.Widget.Gtk_Widget_Record'Class)
   is
      Ignored : Gint;
      pragma Unreferenced (Ignored);
   begin
      Ignored := Append_Page (Notebook, Child, null);
   end Append_Page;

   procedure Append_Page
     (Notebook  : access Gtk_Notebook_Record;
      Child     : access Gtk.Widget.Gtk_Widget_Record'Class;
      Tab_Label : access Gtk.Widget.Gtk_Widget_Record'Class)
   is
      Ignored : Gint;
      pragma Unreferenced (Ignored);
   begin
      Ignored := Append_Page (Notebook, Child, Tab_Label);
   end Append_Page;

   procedure Prepend_Page
     (Notebook  : access Gtk_Notebook_Record;
      Child     : access Gtk.Widget.Gtk_Widget_Record'Class;
      Tab_Label : access Gtk.Widget.Gtk_Widget_Record'Class)
   is
      Ignored : Gint;
      pragma Unreferenced (Ignored);
   begin
      Ignored := Append_Page (Notebook, Child, Tab_Label);
   end Prepend_Page;
        </body>
      </extra>
   </package>

   <!-- ################################################
        Gtk.Paned
        ################################################-->

   <package id="GtkPaned">
      <doc screenshot="gtk-paned" testgtk="create_paned.adb"
           group="Layout container"/>
      <parameter name="self" ada="Paned"/>
      <method id="gtk_paned_pack1">
         <parameter name="self" ada="Paned"/>
         <parameter name="resize" default="False" />
         <parameter name="shrink" default="True" />
         <doc>
Add a child to the top or left pane.
You can not change dynamically the attributes Resize and Shrink.
Instead, you have to remove the child from the container, and put it
back with the new value of the attributes. You should also first
call Glib.Object.Ref on the child so as to be sure it is not destroyed
when you remove it, and Glib.Object.Unref it at the end. See the
example in testgtk/ in the GtkAda distribution.
         </doc>
      </method>
      <method id="gtk_paned_pack2">
         <parameter name="self" ada="Paned"/>
         <parameter name="resize" default="False" />
         <parameter name="shrink" default="False" />
      </method>
      <method id="gtk_paned_add1">
         <parameter name="self" ada="Paned"/>
         <doc>
Add the first child of the container.
The child will be displayed either in the top or in the left pane,
depending on the orientation of the container.
This is equivalent to using the Pack1 procedure with its default parameters.
         </doc>
      </method>
      <method id="gtk_paned_add2">
         <parameter name="self" ada="Paned"/>
         <doc>
Add the second child of the container.
It will be displayed in the bottom or right pane, depending on the
container's orientation.
This is equivalent to using Pack2 with its default parameters.
         </doc>
      </method>
   </package>

   <package id="GtkVPaned" into="GtkPaned">
      <type name="Gtk_Vpaned" subtype="true"/>
      <parameter name="self" ada="Paned"/>
      <method id="gtk_vpaned_new" ada="Gtk_New_Vpaned">
         <doc>The children will be displayed one on top of the other</doc>
      </method>
      <method id="gtk_vpaned_get_type" ada="Get_Type_Vpaned" />
   </package>

   <package id="GtkHPaned" into="GtkPaned">
      <type name="Gtk_Hpaned" subtype="true"/>
      <parameter name="self" ada="Paned"/>
      <method id="gtk_hpaned_new" ada="Gtk_New_Hpaned">
         <doc>The children will be displayed next to each other</doc>
      </method>
      <method id="gtk_hpaned_get_type" ada="Get_Type_Hpaned" />
   </package>


   <!-- ################################################
        Gtk.Box, Gtk.Vbox, Gtk.Hbox
        ################################################-->
   <package id="GtkBox">
      <doc screenshot="gtk-box" testgtk="create_box.adb"
           group="Layout containers">
See the testgtk example in the GtkAda distribution to see concrete examples
on how all the parameters for the boxes work.
      </doc>
      <method id="gtk_box_pack_start">
         <parameter name="self" ada="In_Box"/>
         <parameter name="expand" default="True"/>
         <parameter name="fill" default="True"/>
         <parameter name="padding" default="0"/>
      </method>
      <method id="gtk_box_pack_end">
         <parameter name="self" ada="In_Box"/>
         <parameter name="expand" default="True"/>
         <parameter name="fill" default="True"/>
         <parameter name="padding" default="0"/>
      </method>
      <parameter name="self" ada="Box"/>
      <method id="gtk_box_get_type">
         <doc extend="True">Used with Glib.Object.G_New, this creates a horizontal box</doc>
      </method>

      <extra>
         <gir:method c:identifier="ada_box_get_child" name="Get_Child"
                     version="GtkAda 1.0">
            <gir:doc>Return the Num-th child of the box, or null if there is no such child</gir:doc>
            <gir:return-value>
               <gir:type name="GtkWidget" c:type="GtkWidget*"/>
            </gir:return-value>
            <gir:parameters>
               <gir:parameter name="num">
                  <gir:type name="Gint" c:type="gint"/>
               </gir:parameter>
            </gir:parameters>
         </gir:method>
      </extra>
   </package>

   <package id="GtkVBox" into="GtkBox">
      <type name="Gtk_Vbox" subtype="true"/>
      <method id="gtk_vbox_new" ada="Gtk_New_Vbox">
         <parameter name="homogeneous" default="False"/>
         <parameter name="spacing" default="0"/>
      </method>
      <parameter name="self" ada="Box"/>
      <method id="gtk_vbox_get_type" ada="Get_Vbox_Type" />
   </package>

   <package id="GtkHBox" into="GtkBox">
      <type name="Gtk_Hbox" subtype="true"/>
      <method id="gtk_hbox_new" ada="Gtk_New_Hbox" >
         <parameter name="homogeneous" default="False"/>
         <parameter name="spacing" default="0"/>
      </method>
      <parameter name="self" ada="Box"/>
      <method id="gtk_hbox_get_type" ada="Get_Hbox_Type" />
   </package>

   <package id="GtkScale">
      <doc group="Numeric/Text Data Entry" screenshot="gtk-scale.png"/>
      <parameter name="self" ada="Scale"/>
   </package>
   <package id="GtkVScale" into="GtkScale">
      <parameter name="self" ada="Scale"/>
      <type name="Gtk_Vscale" subtype="true"/>
      <method id="gtk_vscale_new" ada="Gtk_New_Vscale">
         <parameter name="adjustment" default="null"/>
      </method>
      <method id="gtk_vscale_new_with_range" ada="Gtk_New_Vscale"/>
      <method id="gtk_vscale_get_type" ada="Vscale_Get_Type" />
   </package>
   <package id="GtkHScale" into="GtkScale">
      <parameter name="self" ada="Scale"/>
      <type name="Gtk_Hscale" subtype="true"/>
      <method id="gtk_hscale_new" ada="Gtk_New_Hscale">
         <parameter name="adjustment" default="null"/>
      </method>
      <method id="gtk_hscale_new_with_range" ada="Gtk_New_Hscale"/>
      <method id="gtk_hscale_get_type" ada="Hscale_Get_Type" />
   </package>

   <package id="GtkArrow">
      <doc screenshot="gtk-arrow" testgtk="create_arrow.adb"/>
      <parameter name="self" ada="Arrow"/>
   </package>

   <package id="GtkClipboard">
      <parameter name="self" ada="Clipboard"/>
      <method id="gtk_clipboard_get">
         <parameter name="selection" default="Gdk.Types.Gdk_None"/>
      </method>
      <method id="gtk_clipboard_get_for_display">
         <parameter name="selection" default="Gdk.Types.Gdk_None"/>
      </method>
      <method id="gtk_clipboard_request_rich_text">
         <parameter name="buffer" ctype="GObject*"/>
      </method>
      <method id="gtk_clipboard_wait_is_rich_text_available">
         <parameter name="buffer" ctype="GObject*"/>
      </method>
      <method id="gtk_clipboard_set_can_store">
         <parameter name="targets" type="Gtk.Target_List.Target_Entry_Array"/>
      </method>
      <method id="gtk_clipboard_set_text">
         <parameter name="text" ctype="char*"/>
         <parameter name="len" default="-1" ada=""/>
      </method>

      <method id="gtk_clipboard_set_with_data" bind="false" /> <!-- low-level -->
      <method id="gtk_clipboard_set_with_owner" bind="false" /> <!-- low-level -->
      <method id="gtk_clipboard_wait_for_rich_text" bind="false" /> <!--  Returns an array, not practical -->
      <method id="gtk_clipboard_wait_for_targets" bind="false" /> <!-- bound manually below -->
      <extra>
         <spec>
   function Wait_For_Targets
     (Clipboard : not null access Gtk_Clipboard_Record)
     return Gdk.Types.Gdk_Atom_Array;
   --  Returns a list of targets that are present on the clipboard, or an empty
   --  array if there aren't any targets available.
   --  This function waits for the data to be received using the main
   --  loop, so events, timeouts, etc, may be dispatched during the wait.
         </spec>
         <with_body pkg="Gtkada.C" />
         <body>
    package Atom_Arrays is new Gtkada.C.Unbounded_Arrays
     (Gdk.Types.Gdk_Atom, Gdk.Types.Gdk_None,
      Natural, Gdk.Types.Gdk_Atom_Array);

   ----------------------
   -- Wait_For_Targets --
   ----------------------

   function Wait_For_Targets
     (Clipboard : not null access Gtk_Clipboard_Record)
     return Gdk.Types.Gdk_Atom_Array
   is
      use Atom_Arrays;
      function Internal
        (Clipboard : System.Address;
         Targets   : access Unbounded_Array_Access;
         N_Targets : access Gint) return Gboolean;
      pragma Import (C, Internal, "gtk_clipboard_wait_for_targets");

      Output    : aliased Unbounded_Array_Access;
      N_Targets : aliased Gint;
   begin
      if Internal
        (Get_Object (Clipboard),
         Output'Unchecked_Access,
         N_Targets'Unchecked_Access) = 0
      then
         G_Free (Output);
         Output := null;
      end if;

      declare
         Result : constant Gdk_Atom_Array :=
           To_Array (Output, Integer (N_Targets));
      begin
         if Output /= null then
            G_Free (Output);
         end if;

         return Result;
      end;
   end Wait_For_Targets;
         </body>
      </extra>
   </package>

   <!-- #######################################################
        ## Gtk.Viewport
        #######################################################-->

   <package id="GtkViewport">
      <doc group="Scrolling"/>
      <parameter name="self" ada="Viewport"/>
      <method id="gtk_viewport_new">
         <parameter name="hadjustment" default="null"/>
         <parameter name="vadjustment" default="null"/>
      </method>

      <!-- These are now inherited from the Scrollable interface -->
      <method id="gtk_viewport_get_hadjustment" bind="false"/>
      <method id="gtk_viewport_get_vadjustment" bind="false"/>
      <method id="gtk_viewport_set_hadjustment" bind="false"/>
      <method id="gtk_viewport_set_vadjustment" bind="false"/>
   </package>

   <!-- #######################################################
        ## Gtk.Pixmap
        #######################################################-->

   <package id="GtkPixmap">
      <doc group="Obsolescent widgets"/>
      <parameter name="self" ada="Pixmap"/>
      <parameter name="pixmap" ada="Val"/>
      <method id="gtk_pixmap_set_build_insensitive">
         <doc>Whether the pixmap should be grayed out, as is done for insensitive widgets that do not accept user interaction</doc>
      </method>

      <extra>
         <with_spec pkg="Gtk.Widget" />
         <with_spec pkg="Gtk.Window" />
         <with_spec pkg="Gtkada.Types" />
         <with_body pkg="Gdk.Color" />
         <spec>
   function Create_Pixmap
     (Filename : String;
      Window   : access Gtk.Window.Gtk_Window_Record'Class) return Gtk_Pixmap;
      --  Create a pixmap given a window and a filename

   function Create_Pixmap
     (Data     : Gtkada.Types.Chars_Ptr_Array;
      Window   : access Gtk.Window.Gtk_Window_Record'Class) return Gtk_Pixmap;
   --  Create a pixmap given a window and a buffer.
            </spec>
            <body>
   Dummy_Pixmap : constant Gtkada.Types.chars_ptr_array :=
     (New_String ("1 1 1 1"),
      New_String ("c None"),
      New_String (" "));
   --  This is a dummy pixmap we use when a pixmap can't be found.

   function Create_Pixmap
     (Filename : String;
      Window   : access Gtk.Window.Gtk_Window_Record'Class) return Gtk_Pixmap
   is
      Gdkpixmap : Gdk.Pixmap.Gdk_Pixmap;
      Mask      : Gdk.Bitmap.Gdk_Bitmap;
      Pixmap    : Gtk_Pixmap;

      use Gtk.Widget;
      use Gtk.Window;

   begin
      if not Realized_Is_Set (Window) then
         Gtk.Window.Realize (Window);
      end if;

      if Filename = "" then
         Gdk.Pixmap.Create_From_Xpm_D
           (Gdkpixmap, Get_Window (Window), Mask,
            Gdk.Color.Null_Color, Dummy_Pixmap);
      else
         Gdk.Pixmap.Create_From_Xpm
           (Gdkpixmap, Get_Window (Window), Mask,
            Gdk.Color.Null_Color, Filename);
      end if;

      Gtk_New (Pixmap, Gdkpixmap, Mask);
      return Pixmap;
   end Create_Pixmap;

   function Create_Pixmap
     (Data   : Gtkada.Types.Chars_Ptr_Array;
      Window : access Gtk.Window.Gtk_Window_Record'Class) return Gtk_Pixmap
   is
      Gdkpixmap : Gdk.Pixmap.Gdk_Pixmap;
      Mask      : Gdk.Bitmap.Gdk_Bitmap;
      Pixmap    : Gtk_Pixmap;

      use Gtk.Widget;
      use Gtk.Window;

   begin
      if not Realized_Is_Set (Window) then
         Gtk.Window.Realize (Window);
      end if;

      Gdk.Pixmap.Create_From_Xpm_D
        (Gdkpixmap, Get_Window (Window), Mask, Gdk.Color.Null_Color, Data);
      Gtk_New (Pixmap, Gdkpixmap, Mask);

      return Pixmap;
   end Create_Pixmap;
         </body>
      </extra>
   </package>

   <package id="GtkMisc">
      <doc group="Abstract base classes"/>
      <parameter name="self" ada="Misc"/>
      <method id="gtk_misc_set_alignment">
         <doc>
Modify the alignment for the widget.
Xalign and Yalign are both values between 0.0 and 1.0 that specify the
alignment: if Xalign is 0.0, the widget will be left aligned; if it is
0.5, the widget will be centered; if it is 1.0 the widget will be
right aligned. Yalign is from top (0.0) to bottom (1.0).
Both Xalign and Yalign will be constrained to the range 0.0 .. 1.0
Note that if the widget fills its allocated area, these two parameters
won't have any effect.
         </doc>
      </method>
   </package>

   <package id="GtkBin">
      <doc group="Abstract base classes"/>
      <parameter name="self" ada="Bin"/>
   </package>

   <!-- #################################################################
        Gtk.Layout
        ################################################################ -->

   <package id="GtkLayout">
      <doc group="Layout containers" testgtk="create_layout.adb"
           screenshot="gtk-layout">
A Gtk_Layout is a widget that can have an almost infinite size, without
occupying a lot of memory. Its children can be located anywhere within
it, but will only appear on the screen if the visible area of the layout
contains them.
Just like a Gtk_Viewport, its visible area is indicated by two
Gtk_Adjustment widgets, and thus a Gtk_Layout can be put as is in a
Gtk_Scrolled_Window.
As for Gtk_Fixed containers, the children can be located anywhere in the
layout (no automatic organization is done). But, as opposed to Gtk_Fixed
widgets, a Gtk_Layout does not try to resize itself to show all its
children.

Starting from GtkAda 2.0, you have to call Set_Size and specify the maximum
size of the layout, otherwise children added with Put outside the size
defined for the layout will never be visible.
One way to do this is to systematically call Set_Size before calling Put,
and make sure you specify a size big enough for the layout.
      </doc>
      <parameter name="self" ada="Layout"/> <!-- for all methods -->
      <method id="gtk_layout_new">
         <parameter name="hadjustment" default="null"/>
         <parameter name="vadjustment" default="null"/>
      </method>
      <method id="gtk_layout_put">
         <doc>The child will be displayed on the screen only if at least part of it intersects the visible area of the layout. The layout does not resize itself to automatically show the widget. You also need to call Set_Size, if the size you initially defined is smaller than (X, Y), or the child will never be visible even if the layout is scrolled.</doc>
      </method>

      <!-- These are now inherited from the Scrollable interface -->
      <method id="gtk_layout_get_hadjustment" bind="false"/>
      <method id="gtk_layout_get_vadjustment" bind="false"/>
      <method id="gtk_layout_set_hadjustment" bind="false"/>
      <method id="gtk_layout_set_vadjustment" bind="false"/>
   </package>

   <package id="GtkRange">
      <doc testgtk="create_range.adb" screenshot="gtk-range"/>
      <parameter name="self" ada="The_Range"/>
   </package>

   <package id="GtkButtonBox">
      <doc testgtk="create_button_box.adb" screenshot="gtk-button_box"
           group="Layout containers">
A Gtk_Button_Box is a special type of Gtk_Box specially tailored to contain
buttons.

This is only a base class for Gtk_Hbutton_Box and Gtk_Vbutton_Box which
provide a way to arrange their children horizontally (resp. vertically).
You can not instantiate a Gtk_Button_Box directly, and have to use one the
above two instead.
      </doc>
      <parameter name="self" ada="Widget"/>
   </package>

   <package id="GtkHButtonBox">
      <doc group="Layout containers">
A Gtk_Hbutton_Box is a specific Gtk_Button_Box that organizes its
children horizontally.
The beginning of the box (when you add children with Gtk.Box.Pack_Start)
is on the left of the box. Its end (for Gtk.Box.Pack_End) is on the right.
      </doc>
      <parameter name="self" ada="Widget"/>
   </package>

   <package id="GtkVButtonBox">
      <doc group="Layout containers">
A Gtk_Vbutton_Box is a specific Gtk_Button_Box that organizes its
children vertically.
The beginning of the box (when you add children with Gtk.Box.Pack_Start)
is on the top of the box. Its end (for Gtk.Box.Pack_End) is on the bottom.
      </doc>
      <parameter name="self" ada="Widget"/>
   </package>

   <package id="GtkVolumeButton">
      <parameter name="self" ada="Widget"/>
   </package>

   <package id="GtkAboutDialog">
      <doc group="Windows" testgtk="create_about.adb"/>
      <parameter name="self" ada="About"/>
      <enum ctype="GtkLicense"/>
  </package>

  <package id="GtkEntry">
     <doc testgtk="create_entry.adb" group="Numeric/Text Data Entry"
          screenshot="gtk-gentry">
A Gtk_Entry is a single line text editing widget.
The text is automatically scrolled if it is longer than can be displayed
on the screen, so that the cursor position is visible at all times.

See Gtk_Text_View for a multiple-line text editing widget.
     </doc>
     <parameter name="self" ada="The_Entry"/>
     <enum ctype="GtkEntryIconPosition" prefix=""/>

     <method id="gtk_entry_set_invisible_char">
        <parameter name="ch" ada="Char"/>
     </method>
     <method id="gtk_entry_set_has_frame">
        <parameter name="setting" default="True"/>
     </method>
     <method id="gtk_entry_set_width_chars">
        <parameter name="n_chars" ada="Width"/>
     </method>

     <extra>
        <spec>subtype Gtk_GEntry is Gtk_Entry;</spec>
        <spec>
   procedure Insert_Text
      (Editable : access Gtk_Entry_Record;
       New_Text : UTF8_String;
       Position : in out Gint);
   --  Convenience subprogram, identical to Insert_Text above without
   --  the requirement to supply the New_Text_Length argument.
        </spec>
        <body>
   procedure Insert_Text
      (Editable : access Gtk_Entry_Record;
       New_Text : UTF8_String;
       Position : in out Gint) is
   begin
      Insert_Text
        (Editable, New_Text &amp; ASCII.NUL, New_Text'Length, Position);
   end Insert_Text;
        </body>
     </extra>
  </package>

  <package id="GtkDialog">
     <doc group="Windows" testgtk="create_dialog.adb"
          screenshot="gtk-dialog">
          See Gtkada.Dialogs for a higher level dialog interface.
     </doc>
     <parameter name="self" ada="Dialog" />
     <parameter name="response_id" type="Gtk_Response_Type"/>
     <method id="gtk_dialog_get_action_area" return="GtkBox*"/>
     <method id="gtk_dialog_get_content_area" return="GtkBox*"/>
     <method id="gtk_dialog_get_response_for_widget" return="GtkResponseType"/>
     <method id="gtk_dialog_run" return="GtkResponseType"/>
     <method id="gtkada_GtkDialog_get_vbox" bind="true" return="GtkBox*"/>
     <method id="gtk_dialog_add_button">
        <parameter name="button_text" ada="text"/>
     </method>

     <!-- Bound manually below -->
     <method id="gtk_dialog_set_alternative_button_order_from_array" bind="False"/>

     <!-- Following methods have varargs -->
     <method id="gtk_dialog_new_with_buttons" bind="False"/>
     <method id="gtk_dialog_add_buttons" bind="False"/>
     <method id="gtk_dialog_set_alternative_button_order" bind="False"/>

     <method id="ada_gtk_dialog_new_with_buttons">
        <parameter name="parent" default="null"/>
     </method>

     <extra>
        <gir:constructor c:identifier="ada_gtk_dialog_new_with_buttons"
             name="new" version="GtkAda 1.0">
             <gir:doc>Create a new dialog with a specific title, and specific attributes. Parent is the transient parent for the dialog (ie the one that is used for reference for the flag Destroy_With_Parent, or to compute the initial position of the dialog).</gir:doc>
           <gir:return-value>
              <gir:type name="GtkDialog" c:type="GtkDialog*"/>
           </gir:return-value>
           <gir:parameters>
              <gir:parameter name="title">
                 <gir:type name="utf8" c:type="gchar*"/>
              </gir:parameter>
              <gir:parameter name="parent">
                 <gir:type name="Window" c:type="GtkWindow*"/>
              </gir:parameter>
              <gir:parameter name="flags">
                 <gir:type name="DialogFlags" c:type="GtkDialogFlags"/>
              </gir:parameter>
           </gir:parameters>
        </gir:constructor>

        <with_spec pkg="Gdk.Screen" />
        <spec>
   procedure Set_Alternative_Button_Order_From_Array
     (Dialog    : access Gtk_Dialog_Record;
      New_Order : Response_Type_Array);
   --  Sets an alternative button order. If the gtk-alternative-button-order
   --  setting is set to %TRUE, the dialog buttons are reordered according to
   --  the order of the response ids passed to this function.
   --
   --  By default, GTK+ dialogs use the button order advocated by the Gnome
   --  Human Interface Guidelines with the affirmative button at the far right,
   --  and the cancel button left of it. But the builtin GTK+ dialogs and
   --  message dialogs' do provide an alternative button order, which is more
   --  suitable on some platforms, e.g. Windows.
   --
   --  Use this function after adding all the buttons to your dialog.

   function Gtk_Alternative_Dialog_Button_Order
     (Screen : Gdk.Screen.Gdk_Screen := null)  return Boolean;
   --  Returns True if dialogs are expected to use an alternative button order
   --  on the given screen (or current screen if null) . See
   --  Set_Alternative_Button_Order_From_Array for more details about
   --  alternative button order.
   --
   --  If you need to use this function, you should probably connect to the
   --  ::notify:gtk-alternative-button-order signal on the Gtk_Settings object
   --  associated to Screen, in order to be notified if the button order
   --  setting changes.
   --
   --  Returns: Whether the alternative button order should be used

   function Use_Header_Bar_From_Settings
      (Widget : access Gtk.Widget.Gtk_Widget_Record'Class := null)
      return Gtk_Dialog_Flags;
   --  Check in the gtk settings whether dialogs should display their action
   --  buttons in the header bar rather than in the action area at the bottom.
   --  Widget is used to retrieve the settings. If unspecified, the default
   --  settings are used.
   --  The value of the setting can be set in the file
   --    $HOME/.config/gtk-3.0/settings.ini
   --  with the following line:
   --    gtk-dialogs-use-header=0

   procedure G_New_Dialog
      (Self  : not null access Gtk_Dialog_Record'Class;
       Flags : Gtk_Dialog_Flags;
       Typ   : Glib.GType := Gtk.Dialog.Get_Type);
   --  Equivalent of Glib.Object.G_New for a dialog. This function should be
   --  used when you are subclassing the dialog class (for instance to add new
   --  signals). The Use_Header_Bar flag can only have an impact before the
   --  dialog is created, so this function will take that into account as
   --  appropriate. Other flags (Modal and Destroy_With_Parent) are ignored.
        </spec>

        <with_body pkg="Gtk.Settings" />
        <with_body pkg="Glib.Properties" />
        <body>
   procedure G_New_Dialog
      (Self  : not null access Gtk_Dialog_Record'Class;
       Flags : Gtk_Dialog_Flags;
       Typ   : Glib.GType := Gtk.Dialog.Get_Type)
   is
      function Internal
         (Typ : GType; Flags : Gtk_Dialog_Flags) return System.Address;
      pragma Import (C, Internal, "ada_g_dialog_new");
   begin
      if not Self.Is_Created then
         Set_Object (Self, Internal (Typ, Flags));
      end if;
   end G_New_Dialog;

   procedure Set_Alternative_Button_Order_From_Array
     (Dialog    : access Gtk_Dialog_Record;
      New_Order : Response_Type_Array)
   is
      procedure Internal
        (Dialog    : System.Address;
         N_Params  : Gint;
         New_Order : System.Address);
      pragma Import
        (C, Internal, "gtk_dialog_set_alternative_button_order_from_array");
   begin
      Internal (Get_Object (Dialog), New_Order'Length,
                New_Order (New_Order'First)'Address);
   end Set_Alternative_Button_Order_From_Array;

   function Gtk_Alternative_Dialog_Button_Order
     (Screen : Gdk.Screen.Gdk_Screen := null) return Boolean
   is
      function Internal (Screen : System.Address) return Gboolean;
      pragma Import (C, Internal, "gtk_alternative_dialog_button_order");
   begin
      return Boolean'Val (Internal (Get_Object (Screen)));
   end Gtk_Alternative_Dialog_Button_Order;

   function Use_Header_Bar_From_Settings
      (Widget : access Gtk.Widget.Gtk_Widget_Record'Class := null)
      return Gtk_Dialog_Flags
   is
      S : Gtk_Settings;
   begin
      if Widget = null then
         S := Gtk.Settings.Get_Default;
      else
         S := Get_Settings (Widget);
      end if;

      if Get_Property (S, Gtk_Dialogs_Use_Header_Property) then
         return Use_Header_Bar;
      else
         return 0;
      end if;
   end Use_Header_Bar_From_Settings;
        </body>

        <type ctype="GtkDialogFlags" ada="Gtk_Dialog_Flags">
   type Gtk_Dialog_Flags is mod 8;
   for Gtk_Dialog_Flags'Size use Gint'Size;
   pragma Convention (C, Gtk_Dialog_Flags);
   Modal               : constant Gtk_Dialog_Flags := 2 ** 0;
   Destroy_With_Parent : constant Gtk_Dialog_Flags := 2 ** 1;
   Use_Header_Bar      : constant Gtk_Dialog_Flags := 2 ** 2;
   --  Various flags that can be set for the dialog, with the following
   --  implications:
   --     - Modal : the dialog is modal, see Gtk.Window.Set_Modal
   --     - Destroy_With_Parent: The dialog is destroyed if its parent is
   --       destroyed. See Gtk.Window.Set_Destroy_With_Parent
   --     - Use_Header_Bar: create dialogs with actions in the header bar
   --       instead of action area (since 3.12)
        </type>

        <type ctype="GtkResponseType" ada="Gtk_Response_Type">
   type Gtk_Response_Type is new Gint;
   --  Type used for Response_Id's.
   --  Positive values are totally user-interpreted.
   --  GtkAda will sometimes return Gtk_Response_None if no Response_Id is
   --  available.
   --
   --  Typical usage is:
   --    if Gtk.Dialog.Run (Dialog) = Gtk_Response_Accept then
   --       blah;
   --    end if;

   Gtk_Response_None : constant Gtk_Response_Type := -1;
   --  GtkAda returns this if a response widget has no Response_Id,
   --  or if the dialog gets programmatically hidden or destroyed.

   Gtk_Response_Reject : constant Gtk_Response_Type := -2;
   Gtk_Response_Accept : constant Gtk_Response_Type := -3;
   --  GtkAda won't return these unless you pass them in
   --  as the response for an action widget. They are
   --  for your convenience.

   Gtk_Response_Delete_Event : constant Gtk_Response_Type := -4;
   --  If the dialog is deleted through the button in the titlebar

   Gtk_Response_OK     : constant Gtk_Response_Type := -5;
   Gtk_Response_Cancel : constant Gtk_Response_Type := -6;
   Gtk_Response_Close  : constant Gtk_Response_Type := -7;
   Gtk_Response_Yes    : constant Gtk_Response_Type := -8;
   Gtk_Response_No     : constant Gtk_Response_Type := -9;
   Gtk_Response_Apply  : constant Gtk_Response_Type := -10;
   Gtk_Response_Help   : constant Gtk_Response_Type := -11;
   --  These are returned from dialogs, and you can also use them
   --  yourself if you like.
        </type>

        <type ctype="GtkResponseType*" ada="Response_Type_Array">
   type Response_Type_Array is array (Natural range &lt;&gt;) of Gtk_Response_Type;
        </type>
     </extra>
  </package>

  <package id="GtkExpander">
     <doc group="Layout containers" screenshot="gtk-expanded"/>
     <parameter name="self" ada="Expander"/>
  </package>

  <package id="GtkDrawingArea">
     <doc group="Drawing" testgtk="libart_demo.adb">
See also the Double_Buffer widget provided in the GtkAda examples for an advanced example that demonstrates how to use double buffering, to avoid flickering in your drawings.</doc>
     <parameter name="self" ada="Drawing_Area"/>
  </package>

  <package id="GtkAdjustment">
     <doc group="Scrolling">
The meaning of the most important fields can be explained on the following figure (imagine this is a scrollbar):

[-------|=================|-------------------]

lower    value        value + page_size       upper
     </doc>
     <parameter name="self" ada="Adjustment"/>
     <method id="gtk_adjustment_new">
        <parameter name="page_size" default="0.0"/>
        <doc>Create a new adjustment. Value is the initial value of the adjustment. It must be in the range (Lower .. Upper) and the adjustment's value will never be outside this range. Step_Increment is the value used to make minor adjustments, such as when the user clicks on the arrows of a scrollbar. Page_Increment is used to make major adjustments, such as when the user clicks in the through on a scrollbar. Page_Size is deprecated, use the default value.</doc>
     </method>
     <method id="gtk_adjustment_clamp_page">
        <doc>Update the Adjustment value to ensure that the range between Lower and Upper is in the current page (i.e. between value and value + page_size). If the range is larger than the page size, then only the start of it will be in the current page. A "value_changed" signal will be emitted if the value is changed.</doc>
     </method>
  </package>

  <package id="GtkImage">
     <doc group="Display widgets" screenshot="gtk-image"/>
     <parameter name="self" ada="Image"/>
     <parameter name="image" ada="Val"/>
     <parameter name="size" type="Gtk.Enums.Gtk_Icon_Size"/>
     <method id="gtk_image_new_from_animation" ada="Gtk_New"/>
     <method id="gtk_image_new_from_file"      ada="Gtk_New"/>
     <method id="gtk_image_new_from_image"     ada="Gtk_New"/>
     <method id="gtk_image_new_from_pixbuf"    ada="Gtk_New"/>
     <method id="gtk_image_new_from_icon_set"  ada="Gtk_New"/>
     <method id="gtk_image_new_from_pixmap"    ada="Gtk_New"/>
     <method id="gtk_image_new_from_stock"     ada="Gtk_New"/>
     <method id="gtk_image_get_animation"      ada="Get"/>
     <method id="gtk_image_set_from_animation" ada="Set"/>
     <method id="gtk_image_get_image"          ada="Get"/>
     <method id="gtk_image_get" bind="False"/> <!-- same as get_image -->
     <method id="gtk_image_set_from_image"     ada="Set"/>
     <method id="gtk_image_set" bind="False"/> <!-- same as set_from_image -->
     <method id="gtk_image_get_pixbuf"         ada="Get"/>
     <method id="gtk_image_set_from_pixbuf"    ada="Set"/>
     <method id="gtk_image_get_icon_set"       ada="Get"/>
     <method id="gtk_image_set_from_icon_set"  ada="Set"/>
     <method id="gtk_image_get_pixmap"         ada="Get"/>
     <method id="gtk_image_set_from_pixmap"    ada="Set"/>
     <method id="gtk_image_get_stock"          ada="Get" bind="False"/>
     <method id="gtk_image_set_from_stock"     ada="Set"/>
     <method id="gtk_image_get_gicon"          ada="Get"/>
     <method id="gtk_image_set_from_gicon"     ada="Set"/>
     <method id="gtk_image_set_from_file"      ada="Set"/>
     <method id="gtk_image_get_icon_name"      ada="Get" bind="False"/>
     <enum ctype="GtkImageType"/>
     <extra>
        <with_spec pkg="GNAT.Strings"/>
        <spec>
   function Get
     (Image : access Gtk_Image_Record;
      Size  : access Gtk.Enums.Gtk_Icon_Size) return String;
   --  Get the stock_id for the image displayed

   procedure Get_Icon_Name
     (Image : access Gtk_Image_Record;
      Name  : out GNAT.Strings.String_Access;
      Size  : out Gtk.Enums.Gtk_Icon_Size);
        </spec>
        <body>
   procedure Get_Icon_Name
     (Image : access Gtk_Image_Record;
      Name  : out GNAT.Strings.String_Access;
      Size  : out Gtk_Icon_Size)
   is
      procedure Internal
        (Image : System.Address;
         Name  : out Gtkada.Types.Chars_Ptr;
         Size  : out Gtk_Icon_Size);
      pragma Import (C, Internal, "gtk_image_get_icon_name");
      Str : chars_ptr;
   begin
      Internal (Get_Object (Image), Str, Size);
      Name := new String'(Value (Str));
   end Get_Icon_Name;

   function Get
     (Image : access Gtk_Image_Record;
      Size  : access Gtk.Enums.Gtk_Icon_Size) return String
   is
      procedure Internal
        (Image    : System.Address;
         Stock_Id : out Gtkada.Types.Chars_Ptr;
         Size     : out Gint);
      pragma Import (C, Internal, "gtk_image_get_stock");

      Stock : Gtkada.Types.Chars_Ptr;
      Sze   : Gint;

   begin
      Internal (Get_Object (Image), Stock, Sze);
      Size.all := Gtk.Enums.Gtk_Icon_Size'Val (Sze);
      return Gtkada.Types.Value (Stock);
   end Get;
        </body>
     </extra>
  </package>

  <package id="GtkCalendar">
     <doc group="Selectors" testgtk="create_calendar.adb"
          screenshot="gtk-calendar"/>
     <parameter name="self" ada="Calendar"/>
     <enum ctype="GtkCalendarDisplayOptions" prefix="GTK_CALENDAR_"/>
  </package>

  <package id="GtkSizeGroup">
     <doc testgtk="create_size_groups.adb"/>
     <parameter name="self" ada="Size_Group" />
     <method id="gtk_size_group_new">
        <parameter name="mode" default="Both"/>
     </method>
     <method id="gtk_size_group_get_widgets" return="WidgetSList"/>
     <enum ctype="GtkSizeGroupMode" ada="Size_Group_Mode" prefix="GTK_SIZE_GROUP_"/>
  </package>

  <package id="GtkAlignment">
     <doc testgtk="create_alignment.adb" screenshot="gtk-alignment"/>
     <parameter name="self" ada="Alignment"/>
     <method id="gtkada_GtkAlignment_get_xalign" bind="True"/>
     <method id="gtkada_GtkAlignment_get_xscale" bind="True"/>
     <method id="gtkada_GtkAlignment_get_yalign" bind="True"/>
     <method id="gtkada_GtkAlignment_get_yscale" bind="True"/>
  </package>

  <package id="GtkStatusbar">
     <doc group="Display widgets" testgtk="create_status.adb"
          screenshot="gtk-status_bar"/>
     <parameter name="self" ada="Statusbar"/>
     <parameter name="context" type="Context_Id"/>
     <parameter name="context_id" ada="context" type="Context_Id"/>
     <parameter name="message_id" ada="Message" type="Message_Id"/>
     <method id="gtk_statusbar_get_context_id" return="Context_Id"/>
     <method id="gtkada_GtkStatusbar_get_messages" return="MessagesList"
             bind="True"/>
     <method id="gtk_statusbar_push" return="Message_Id"/>
     <extra>
        <type>
   type Context_Id is new Guint;
   type Message_Id is new Guint;
        </type>
     </extra>
  </package>

  <package id="GtkTable">
     <doc group="Layout containers"/>
     <parameter name="self" ada="Table"/>
     <method id="gtk_table_new">
        <doc>Create a new table. The width allocated to the table is divided into Columns columns, which all have the same width if Homogeneous is True. If Homogeneous is False, the width will be calculated with the children contained in the table. Same behavior for the rows.</doc>
     </method>
     <method id="gtk_table_attach">
        <doc>Insert a new widget in the table. All the attachments are relative to the separations between columns and rows (for instance, to insert a widget spanning the first two columns in the table, you should put Left_Attach=0 and Right_Attach=2). Same behavior for the rows. Xoptions and Yoptions indicate the behavior of the child when the table is resized (whether the child can shrink or expand). See the description in Gtk.Box for more information on the possible values. Xpadding and Ypadding are the amount of space left around the child.</doc>
        <parameter name="xoptions" default="Expand or Fill"/>
        <parameter name="yoptions" default="Expand or Fill"/>
        <parameter name="xpadding" default="0"/>
        <parameter name="ypadding" default="0"/>
     </method>
     <method id="gtk_table_attach_defaults">
        <doc>Insert a new widget in the table, with default values. No padding is put around the child, and the options are set to Expand and Fill. This call is similar to Attach with default values and is only provided for compatibility.</doc>
     </method>
     <method id="gtk_table_set_col_spacing">
        <doc>Set the spacing in pixels between Column and the next one.</doc>
     </method>
     <method id="gtk_table_set_homogeneous">
        <doc>Indicate the homogeneous status of the table. If Homogeneous is True, the rows and columns of the table will all be allocated the same width or height.</doc>
     </method>
  </package>

  <package id="GtkCheckButton">
     <doc screenshot="gtk-check_button" group="Buttons and Toggles"
        testgtk="create_check_buttons.adb"/>
     <parameter name="self" ada="Check_Button"/>
     <method id="gtk_check_button_new" bind="False"/>
     <method id="gtk_check_button_new_with_label" ada="Gtk_New" >
        <parameter name="label" default='""' allow-none="1"/>
        <doc>Create a check button. if Label is null, then no widget is associated with the button, and any widget can be added to the button (with Gtk.Container.Add).</doc>
     </method>
  </package>

  <package id="GtkToggleButton">
     <doc screenshot="gtk-toggle_button" group="Buttons and Toggles"
          testgtk="create_toggle_buttons.adb">
You should consider using a Gtk_Check_Button instead, since it looks nicer and provides more visual clues that the button can be toggled.
     </doc>
     <parameter name="self" ada="Toggle_Button"/>
     <method id="gtk_toggle_button_new" bind="False"/>
     <method id="gtk_toggle_button_new_with_label" ada="Gtk_New" >
        <doc>Initialize a button. If Label is "", then no label is created inside the button and you will have to provide your own child through a call to Gtk.Container.Add. This is the recommended way to put a pixmap inside a toggle button.</doc>
        <parameter name="label" default='""' allow-none="1"/>
     </method>
     <method id="gtk_toggle_button_set_active">
        <doc>Change the state of the button. When Is_Active is True, the button is drawn as a pressed button</doc>
     </method>
     <method id="gtk_toggle_button_set_inconsistent">
        <parameter name="Setting" default="True"/>
     </method>
  </package>

  <package id="GtkAccelGroup">
     <parameter name="self" ada="Accel_Group"/>
     <method id="gtk_accel_group_new">
        <doc>Creates a new Gtk.Accel_Group.Gtk_Accel_Group.
Remember to call Gtk.Window.Add_Accel_Group to active the group.</doc>
     </method>
     <method id="gtk_accel_group_connect">
        <parameter name="closure" type="C_Gtk_Accel_Group_Activate"/>
     </method>
     <method id="gtk_accel_group_disconnect">
        <parameter name="closure" type="C_Gtk_Accel_Group_Activate"/>
     </method>
     <method id="gtk_accel_group_connect_by_path">
        <parameter name="closure" type="C_Gtk_Accel_Group_Activate"/>
     </method>
     <method id="gtk_accel_group_query" bind="False"/>
        <!-- ???Would be nice -->
     <method id="gtk_accel_group_from_accel_closure">
        <parameter name="closure" type="C_Gtk_Accel_Group_Activate"/>
     </method>
     <function id="gtk_accel_groups_activate">
        <parameter name="accel_key" type="Gdk.Types.Gdk_Key_Type"/>
     </function>
     <function id="gtk_accel_groups_from_object" ada="From_Object"
               return="ObjectSList"/>
     <function id="gtk_accelerator_valid">
        <parameter name="keyval" type="Gdk.Types.Gdk_Key_Type"/>
     </function>
     <function id="gtk_accelerator_parse">
        <parameter name="accelerator_key" ctype="GdkKeyType*"/>
     </function>
     <function id="gtk_accelerator_name">
        <parameter name="accelerator_key" type="Gdk.Types.Gdk_Key_Type"/>
     </function>
     <function id="gtk_accelerator_get_label">
        <parameter name="accelerator_key" type="Gdk.Types.Gdk_Key_Type"/>
     </function>
     <function id="gtk_accelerator_set_default_mod_mask"
               ada="Set_Default_Mod_Mask" />
     <function id="gtk_accelerator_get_default_mod_mask"
               return="GdkModifierType" ada="Get_Default_Mod_Mask"/>
     <enum ctype="GtkAccelFlags" prefix="GTK_"/>
     <record ctype="GtkAccelKey">
       <field name="accel_key" ctype="GdkKeyType"/>
       <field name="accel_flags" ctype="GtkAccelFlags"/>
     </record>
     <extra>
        <type ctype="GtkAccelGroupActive" ada="Gtk_Accel_Group_Activate">
   type Gtk_Accel_Group_Activate is access function
     (Accel_Group   : access Gtk_Accel_Group_Record'Class;
      Acceleratable : Glib.Object.GObject;
      Keyval        : Gdk.Types.Gdk_Key_Type;
      Modifier      : Gdk.Types.Gdk_Modifier_Type) return Boolean;

   type C_Gtk_Accel_Group_Activate is access function
     (Accel_Group   : System.Address;
      Acceleratable : System.Address;
      Keyval        : Gdk.Types.Gdk_Key_Type;
      Modifier      : Gdk.Types.Gdk_Modifier_Type) return Boolean;
   pragma Convention (C, C_Gtk_Accel_Group_Activate);
   --  Same as Gtk_Accel_Group_Activate, but passing directly the C values.
   --  You must use Get_User_Data to convert to the Ada types.
        </type>
     </extra>
  </package>

  <package id="GtkRadioButton">
     <doc screenshot="gtk-radio_button" group="Buttons and Toggles"
          testgtk="create_radio_button.adb"/>
     <parameter name="self" ada="Radio_Button"/>
     <parameter name="radio_group_member" ada="Group"/>
     <method id="gtk_radio_button_new" bind="False"/>
     <method id="gtk_radio_button_new_from_widget" bind="False"/>
     <method id="gtk_radio_button_new_with_label" ada="Gtk_New" >
        <doc>Creates or initializes a new radio button, belonging to Group. If Label is left as the empty string, then the button will not have any child and you are free to put any thing you want in it, including a pixmap. To initialize the group (when creating the first button), leave Group to the Null_List. You can later get the new group that is created with a call to the Get_Group subprogram below.</doc>
        <parameter name="group" default="Widget_SList.Null_List" ctype="WidgetSList"/>
        <parameter name="label" default='""' allow-none="1"/>
     </method>
     <method id="gtk_radio_button_new_with_label_from_widget" ada="Gtk_New" >
        <parameter name="radio_group_member" allow-none="1"/>
        <parameter name="label" default='""' allow-none="1"/>
     </method>
     <method id="gtk_radio_button_new_with_mnemonic">
        <parameter name="group" default="Widget_SList.Null_List" ctype="WidgetSList"/>
     </method>
     <method id="gtk_radio_button_new_with_mnemonic_from_widget" ada="Gtk_New_With_Mnemonic">
        <doc extend="true">To initialize a new group (when creating the first button), you should pass it null or a button that has not been created with Gtk_New, as in the example below.</doc>
        <parameter name="radio_group_member" allow-none="1"/>
     </method>
     <method id="gtk_radio_button_get_group" return="WidgetSList"/>
     <method id="gtk_radio_button_set_group">
        <parameter name="group" ctype="WidgetSList"/>
     </method>
  </package>

  <package id="GtkRadioAction">
     <doc group="Action-based menus" see="Gtk_Action"/>
     <parameter name="self" ada="Action"/>
     <method id="gtk_radio_action_new">
        <parameter name="label" default='""'/>
        <parameter name="tooltip" default='""'/>
        <parameter name="stock_id" default='""'/>
     </method>
     <method id="gtk_radio_action_set_group">
        <parameter name="group" ctype="WidgetSList"/>
        <doc extend="true">A common way to set up a group of radio group is the following:

__PRE__      Group  : GSlist := null;
      Action : Gtk_Radio_Action;
      while ... loop
         Gtk_New (Action, ...);
         Set_Group (Action, Group);
         Group := Get_Group (Action);
      end loop;</doc>
     </method>
     <method id="gtk_radio_action_get_group" return="WidgetSList"/>
  </package>

  <package id="GtkSeparator">
      <doc group="Ornaments" screenshot="gtk-separator"/>
      <parameter name="self" ada="Separator"/>
  </package>
  <package id="GtkVSeparator" into="GtkSeparator">
      <type name="Gtk_Vseparator" subtype="true"/>
      <method id="gtk_vseparator_new" ada="Gtk_New_Vseparator"/>
      <parameter name="self" ada="Separator"/>
      <method id="gtk_vseparator_get_type" ada="Vseparator_Get_Type" />
  </package>
  <package id="GtkHSeparator" into="GtkSeparator">
      <type name="Gtk_Hseparator" subtype="true"/>
      <method id="gtk_hseparator_new" ada="Gtk_New_Hseparator"/>
      <parameter name="self" ada="Separator"/>
      <method id="gtk_hseparator_get_type" ada="Hseparator_Get_Type" />
  </package>

  <package id="GtkSeparatorMenuItem">
     <doc group="Menus and Toolbars"/>
     <parameter name="self" ada="Widget" />
  </package>

  <package id="GtkSeparatorToolItem">
     <doc group="Menus and Toolbars"/>
     <parameter name="self" ada="Item" />
  </package>

  <package id="GtkRuler">
     <doc group="Drawing" testgtk="create_rulers.adb"
          screenshot="gtk-rulers">
 This widget is generally put on the sides of a drawing area to help the user measure distances. It indicates the current position of the mouse cursor within the drawing area, and can be graduated in multiple units.</doc>
     <parameter name="self" ada="Ruler" />
     <method id="gtk_ruler_set_metric">
        <doc>Set or get the units used for a Gtk_Ruler. See Set_Metric</doc>
     </method>
  </package>
  <package id="GtkVRuler" into="GtkRuler">
      <type name="Gtk_Vruler" subtype="true"/>
      <method id="gtk_vruler_new" ada="Gtk_New_Vruler"/>
      <parameter name="self" ada="Ruler"/>
      <method id="gtk_vruler_get_type" ada="Vruler_Get_Type" />
  </package>
  <package id="GtkHRuler" into="GtkRuler">
      <type name="Gtk_Hruler" subtype="true"/>
      <method id="gtk_hruler_new" ada="Gtk_New_Hruler"/>
      <parameter name="self" ada="Ruler"/>
      <method id="gtk_hruler_get_type" ada="Hruler_Get_Type" />
  </package>

  <package id="GtkFixed">
      <doc group="Layout containers" testgtk="create_fixed.adb"
           screenshot="gtk-fixed"/>
      <parameter name="self" ada="Fixed" />
      <method id="gtk_fixed_put">
         <doc>Add Widget to a Fixed container at the given position. X indicates the horizontal position to place the widget at. Y is the vertical position to place the widget at.</doc>
      </method>
      <method id="gtk_fixed_move">
         <doc>Move a child of a GtkFixed container to the given position. X indicates the horizontal position to place the widget at. Y is the vertical position to place the widget at.</doc>
      </method>
      <method id="gtk_fixed_set_has_window">
         <parameter name="has_window" default="False"/>
      </method>
  </package>

  <package id="GtkCellEditable">
     <doc group="Trees and Lists"/>
     <parameter name="self" ada="Cell_Editable"/>
  </package>

  <package id="GtkBuildable">
     <virtual-method id='*' bind='False'/>
     <method id="gtk_buildable_custom_tag_start" bind="False"/>
  </package>

  <package id="GtkFileChooser">
     <doc group="Selectors">
This package provides an interface implemented by Gtk.File_Chooser_Widget and Gtk.File_Chooser_Button, and by your own file selection widgets if you wish to expose a standard interface.

Gtk_File_Chooser allows for shortcuts to various places in the filesystem.  In the default implementation these are displayed in the left pane. It may be a bit confusing at first that these shortcuts come from various sources and in various flavours, so lets explain the terminology here:

__PRE__  - Bookmarks
    are created by the user, by dragging folders from the right pane to the
    left pane, or by using the "Add". Bookmarks can be renamed and deleted
    by the user.
  - Shortcuts
    can be provided by the application or by the underlying filesystem
    abstraction (e.g. both the gnome-vfs and the Windows filesystems
    provide "Desktop" shortcuts). Shortcuts cannot be modified by the user.
  - Volumes
    are provided by the underlying filesystem abstraction. They are the
    "roots" of the filesystem.

File Names and Encodings

When the user is finished selecting files in a Gtk_File_Chooser, your program can get the selected names either as filenames or as URIs. For URIs, the normal escaping rules are applied if the URI contains non-ASCII characters. However, filenames are always returned in the character set specified by the G_FILENAME_ENCODING environment variable. Please see the Glib documentation for more details about this variable.

Important: This means that while you can pass the result of Get_Filename to low-level file system primitives , you will need to convert it to UTF-8 before using it in a Gtk_Label for instance. Conversion is done through Glib.Convert.Filename_To_UTF8.

You can add a custom preview widget to a file chooser and then get notification about when the preview needs to be updated. To install a preview widget, use gtk_file_chooser_set_preview_widget(). Then, connect to the GtkFileChooser::update-preview signal to get notified when you need to update the contents of the preview.

Preview widgets

You can add a custom preview widget to a file chooser and then get notification about when the preview needs to be updated. To install a preview widget, use Set_Preview_Widget. Then, connect to the GtkFileChooser::update-preview signal to get notified when you need to
update the contents of the preview.

Your callback should use Get_Preview_Filename to see what needs previewing.  Once you have generated the preview for the corresponding file, you must call Set_Preview_Widget_Active with a boolean flag that indicates whether your callback could successfully generate a preview.

Adding Extra Widgets

You can add extra widgets to a file chooser to provide options that are not present in the default design. For example, you can add a toggle button to give the user the option to open a file in read-only mode. You can use Set_Extra_Widget to insert additional widgets in a file chooser.

If you want to set more than one extra widget in the file chooser, you can a container such as a GtkVBox or a GtkTable and include your widgets in it.  Then, set the container as the whole extra widget.

Key bindings

The following default key bindings are provided, but you can use a gtkrc file to override them if you need (see gtk-rc.ads).

__PRE__
   Signal name    | Key binding
   location-popup | Control-L  (empty path)
                  | /          (path of "/")
                  | ~          (home directory)
   up-folder      | Alt-Up  or backspace
   down-folder    | Alt-Down
   home-folder    | Alt-Home
   desktop-folder | Alt-D
   quick-bookmark | Alt-1 through Alt-0
     </doc>
  </package>

  <package id="GtkCellLayout">
     <virtual-method id='*' bind='False'/>  <!--  circular dep with Gtk.Cell_Area -->
     <doc group="Trees and Lists" testgtk="create_cell_view.adb"/>
     <parameter name="self" ada="Cell_Layout"/>
     <method id="gtk_cell_layout_get_area" bind="False"/>
     <!-- in Gtk.Cell_Area -->

     <method id="gtk_cell_layout_set_attributes" bind="False"/>
     <method id="gtk_cell_layout_get_cells" return="GtkCellRendererList"/>
  </package>

  <package id="GtkAssistant">
     <doc group="Windows" testgtk="create_assistant.adb"/>
     <parameter name="self" ada="Assistant"/>
     <enum ctype="GtkAssistantPageType" prefix=""/>
  </package>

  <package id="GtkSpinner">
     <doc group="Ornaments"/>
     <parameter name="self" ada="Spinner"/>
  </package>

  <package id="GtkEntryCompletion">
     <doc group="Numeric/Text Data Entry"/>
     <parameter name="self" ada="Completion"/>
  </package>

  <package id="GtkScrollable">
     <doc group="Interfaces"/>
  </package>

  <package id="GtkProgressBar">
     <doc testgtk="create_progress.adb"
          screenshot="gtk-progress_bar"
          group="Display widgets"/>
     <parameter name="self" ada="Progress_Bar"/>
  </package>

  <package id="GtkColorButton">
     <doc group="Buttons and Toggles"/>
     <parameter name="self" ada="Button"/>

     <method id="gtk_color_button_get_rgba" bind="False"/><!--from interface now-->
     <method id="gtk_color_button_set_rgba" bind="False"/><!--from interface now-->
     <method id="gtk_color_button_get_use_alpha" bind="False"/><!--from interface now-->
     <method id="gtk_color_button_set_use_alpha" bind="False"/><!--from interface now-->
  </package>

  <package id="GtkLinkButton">
     <doc group="Buttons and Toggles"/>
     <parameter name="self" ada="Widget" />
  </package>

  <package id="GtkFileFilter">
     <enum ctype="GtkFileFilterFlags"/>
     <record ctype="GtkFileFilterInfo"/>
  </package>

  <package id="GtkFileChooser">
     <doc group=""/>
     <parameter name="self" ada="Chooser"/>
     <enum ctype="GtkFileChooserAction" prefix="GTK_FILE_CHOOSER_"/>
     <enum ctype="GtkFileChooserConfirmation" prefix="GTK_FILE_CHOOSER_"/>
     <enum ctype="GtkFileChooserError" prefix="GTK_FILE_CHOOSER_"/>

     <!-- we won't bind any of these internal functions which pass GFile
          types -->
     <method id="gtk_file_chooser_get_file" bind="False"/>
     <method id="gtk_file_chooser_get_files" bind="False"/>
     <method id="gtk_file_chooser_get_current_folder_file" bind="False"/>
     <method id="gtk_file_chooser_get_preview_file" bind="False"/>
     <method id="gtk_file_chooser_select_file" bind="False"/>
     <method id="gtk_file_chooser_set_current_folder_file" bind="False"/>
     <method id="gtk_file_chooser_set_file" bind="False"/>
     <method id="gtk_file_chooser_unselect_file" bind="False"/>

     <method id="gtk_file_chooser_get_filenames" return="StringSList"/>
     <method id="gtk_file_chooser_get_uris" return="StringSList"/>
     <method id="gtk_file_chooser_list_shortcut_folder_uris"
             return="StringSList"/>
     <method id="gtk_file_chooser_list_shortcut_folders"
             return="StringSList"/>
     <method id="gtk_file_chooser_list_filters" return="ObjectSList"/>
  </package>

  <package id="GtkFileChooserButton">
     <doc group="Buttons and Toggles"/>
     <parameter name="self" ada="Button"/>
  </package>

  <package id="GtkToolbar">
     <parameter name="self" ada="Toolbar"/>
     <method id="gtk_toolbar_set_show_arrow">
        <parameter name="show_arrow" default="True"/>
     </method>
     <method id="gtk_toolbar_insert">
        <parameter name="pos" default="-1"/>
     </method>
     <method id="gtk_tool_shell_get_orientation" bind="False"/>
     <method id="gtk_tool_shell_get_icon_size" bind="False"/>
     <method id="gtk_tool_shell_get_relief_style" bind="False"/>
     <method id="gtk_tool_shell_get_style" bind="False"/>
  </package>

  <package id="GtkEditable">
     <parameter name="self" ada="Editable"/>
     <method id="::insert-text">
        <parameter name="position" direction="access"/>
     </method>
     <method id="gtk_editable_select_region">
        <parameter name="end_pos" default="-1"/>
     </method>
     <method id="gtk_editable_delete_text">
        <parameter name="end_pos" default="-1"/>
     </method>
     <method id="gtk_editable_get_chars">
        <parameter name="end_pos" default="-1"/>
     </method>
     <extra>
        <spec>
   procedure Insert_Text
     (Editable : Gtk_Editable;
      New_Text : UTF8_String;
      Position : in out Gint);
   --  Convenience subprogram, identical to Insert_Text above without
   --  the requirement to supply the New_Text_Length argument.
        </spec>
        <body>
   procedure Insert_Text
     (Editable : Gtk_Editable;
      New_Text : UTF8_String;
      Position : in out Gint) is
   begin
      Insert_Text
        (Editable, New_Text &amp; ASCII.NUL, New_Text'Length, Position);
   end Insert_Text;
        </body>
     </extra>
     <method id="gtk_editable_get_selection_bounds"
             return_as_param="Has_Selection"/>
  </package>

  <package id="GtkToolItem">
     <parameter name="self" ada="Tool_Item"/>
     <method id="gtk_tool_item_retrieve_proxy_menu_item" return="GtkMenuItem"/>
     <method id="gtk_tool_item_get_proxy_menu_item" return="GtkMenuItem"/>
     <method id="gtk_tool_item_set_proxy_menu_item">
        <parameter name="menu_item" ctype="GtkMenuItem"/>
     </method>
  </package>

   <package id="GtkScrollbar">
      <parameter name="self" ada="Scrollbar"/>
   </package>

   <package id="GtkHScrollbar" into="GtkScrollbar">
      <parameter name="self" ada="Scrollbar"/>
      <type name="Gtk_Hscrollbar" subtype="true"/>
      <method id="gtk_hscrollbar_new" ada="Gtk_New_Hscrollbar"/>
      <method id="gtk_hscrollbar_get_type" ada="Hscrollbar_Get_Type"/>
   </package>

   <package id="GtkVScrollbar" into="GtkScrollbar">
      <parameter name="self" ada="Scrollbar"/>
      <type name="Gtk_Vscrollbar" subtype="true"/>
      <method id="gtk_vscrollbar_new" ada="Gtk_New_Vscrollbar"/>
      <method id="gtk_vscrollbar_get_type" ada="Vscrollbar_Get_Type"/>
   </package>

   <package id="GtkCellRenderer">
      <parameter name="self" ada="Cell"/>
      <enum ctype="GtkCellRendererState"/>
      <enum ctype="GtkCellRendererMode"/>
      <method id="gtk_cell_renderer_get_size">
         <!-- hack to make cell_area an in-out parameter -->
         <parameter name="cell_area" ctype="GdkRectangle**"/>
      </method>
      <list ada="Cell_Renderer_List" ctype="GtkCellRenderer"/>
   </package>

   <package id="GtkStatusIcon">
      <parameter name="self" ada="Status_Icon"/>
      <!-- ??? inclusion of below method is pending on L117-038 -->
      <method id="gtk_status_icon_get_geometry" bind="False"/>

      <method id="gtk_status_icon_position_menu">
        <parameter name="user_data" ada="Icon" type="Glib.Object.GObject"/>
        <parameter name="x" direction="out"/>
        <parameter name="y" direction="out"/>
        <body>
      procedure Internal
         (Menu    : System.Address;
          X       : out Gint;
          Y       : out Gint;
          Push_In : out Integer;
          Icon    : System.Address);
      pragma Import (C, Internal, "gtk_status_icon_position_menu");
      --  Custom body because we need to initialize to 0 here (on OSX).
      Tmp_Push_In : aliased Integer := 0;
   begin
      Internal (Get_Object (Menu), X, Y, Tmp_Push_In, Get_Object (Icon));
      Push_In := Tmp_Push_In /= 0;
        </body>
      </method>
   </package>

   <package id="GtkMenuItem">
      <parameter name="self" ada="Menu_Item"/>
      <method id="gtk_menu_item_select" ada="Gtk_Select"/>
      <method id="gtk_menu_item_set_right_justified">
         <parameter name="right_justified" default="True"/>
      </method>
      <extra>
         <spec>
   procedure Gtk_New
      (Menu_Item : out Gtk_Menu_Item;
       Label     : UTF8_String) renames Gtk_New_With_Label;
   procedure Initialize
      (Menu_Item : access Gtk_Menu_Item_Record'Class;
       Label     : UTF8_String) renames Initialize_With_Label;
   --  For backwards compatibility.
         </spec>
      </extra>
   </package>

   <package id="GtkRecentFilter">
     <parameter name="self" ada="Filter"/>
     <enum ctype="GtkRecentFilterFlags" />
     <record ctype="GtkRecentFilterInfo" />
     <slist ada="Gtk_Recent_Filter_List" ctype="GtkRecentFilter"/>
   </package>

   <package id="GtkFileChooserDialog">
      <parameter name="self" ada="Dialog"/>
      <method id="gtk_file_chooser_dialog_new" ada="Gtk_New" bind="False"/> <!-- varargs -->

      <extra>
         <gir:constructor name="new"
                          c:identifier="ada_gtk_file_chooser_dialog_new"
                          version="2.4"
                          introspectable="0">
            <gir:doc xml:whitespace="preserve">Creates a new #GtkFileChooserDialog.  This function is analogous to gtk_dialog_new_with_buttons().</gir:doc>
            <gir:return-value transfer-ownership="none">
               <gir:doc xml:whitespace="preserve">a new #GtkFileChooserDialog</gir:doc>
               <gir:type name="Widget" c:type="GtkWidget*"/>
            </gir:return-value>
            <gir:parameters>
               <gir:parameter name="title" transfer-ownership="none" allow-none="1">
                  <gir:doc xml:whitespace="preserve">Title of the dialog, or %NULL</gir:doc>
                  <gir:type name="utf8" c:type="gchar*"/>
               </gir:parameter>
               <gir:parameter name="parent" transfer-ownership="none" allow-none="1">
                  <gir:doc xml:whitespace="preserve">Transient parent of the dialog, or %NULL</gir:doc>
                  <gir:type name="Window" c:type="GtkWindow*"/>
               </gir:parameter>
               <gir:parameter name="action" transfer-ownership="none">
                  <gir:doc xml:whitespace="preserve">Open or save mode for the dialog</gir:doc>
                  <gir:type name="FileChooserAction" c:type="GtkFileChooserAction"/>
               </gir:parameter>
            </gir:parameters>
         </gir:constructor>
      </extra>
   </package>

   <package id="GtkHandleBox" obsolescent="True">
     <parameter name="self" ada="Handle_Box"/>
   </package>

   <package id="GtkScaleButton">
      <parameter name="self" ada="Button"/>
  </package>

   <package id="GtkRecentManager">
     <doc>
In case the default screen is being used, adding a new recently used file is as
simple as:

__PRE__
     declare
        Manager : constant Gtk_Recent_Manager := Get_Default;
     begin
        Add_Item (Manager, File_URI);
     end;

While looking up a recently used file is as simple as using:

__PRE__
     declare
        Manager : constant Gtk_Recent_Manager := Get_Default;
        Info    : Gtk_Recent_Info;
        Error   : Glib.Error.GError;
     begin
        Lookup_Item (Info, Manager, File_URI, Error);
        if Error /= null then
           --  Use the info object
           Unref (Info);
        else
           Put_Line
             ("Could not find the file: " &amp; Glib.Error.Get_Message (Error));
           Glib.Error.Error_Free (Error);
        end if;
     end;
     </doc>
     <param name="self" ada="Manager" />
     <record ctype="GtkRecentData" />
     <method id="gtk_recent_manager_get_items" return="GtkRecentInfoList"/>
     <list ada="Gtk_Recent_Info_List" ctype="GtkRecentInfo"/>

     <!-- Bound below -->
     <method id="gtk_recent_manager_add_full" bind="False" />

     <extra>
       <with_spec pkg="GNAT.Strings" />
       <with_body pkg="Gtkada.Bindings" />
       <spec>
   function Add_Full
     (Manager      : access Gtk_Recent_Manager_Record;
      Uri          : UTF8_String;
      Display_Name : UTF8_String := "";
      Description  : UTF8_String := "";
      Mime_Type    : UTF8_String;
      App_Name     : UTF8_String;
      App_Exec     : UTF8_String;
      Groups       : GNAT.Strings.String_List;
      Is_Private   : Boolean)
      return Boolean;
   --  Manager      : the Gtk_Recent_Manager on which to operate
   --  Uri          : pointer to resource
   --  Display_Name : a UTF-8 encoded string, containing the name of the
   --                 recently used resource to be displayed, or "".
   --  Description  : a UTF-8 encoded string, containing a short description
   --                 of the resource, or "".
   --  Mime_Type    : the MIME type of the resource.
   --  App_Name     : the name of the application that is registering this
   --                 recently used resource.
   --  App_Exec     : command line used to launch this resource; may contain
   --                 the "%f" and "%u" escape characters which will be
   --                 expanded to the resource file path and URI, respectively,
   --                 when the command line is retrieved.
   --  Groups       : a vector of strings containing groups names.
   --  Is_Private   : whether this resource should be displayed only by the
   --                 applications that have registered it or not.
   --
   --  Adds a new resource, pointed by Uri, into the recently used
   --  resources list, using the metadata specified.
   --
   --  The passed URI will be used to identify this resource inside the
   --  list.
   --
   --  In order to register the new recently used resource, metadata about
   --  the resource must be passed as well as the URI.  This metadata must
   --  contain the MIME type of the resource pointed by the URI; the name of
   --  the application that is registering the item, and a command line to be
   --  used when launching the item.
   --
   --  Optionally, it is possible to specify a UTF-8 string to be used when
   --  viewing the item instead of the last component of the URI; a short
   --  description of the item; whether the item should be considered private -
   --  that is, should be displayed only by the applications that have
   --  registered it.
   --
   --  Returns True if the new item was successfully added to the recently
   --  used resources list, False otherwise.
       </spec>
       <body>
   function Add_Full
     (Manager      : access Gtk_Recent_Manager_Record;
      Uri          : UTF8_String;
      Display_Name : UTF8_String := "";
      Description  : UTF8_String := "";
      Mime_Type    : UTF8_String;
      App_Name     : UTF8_String;
      App_Exec     : UTF8_String;
      Groups       : GNAT.Strings.String_List;
      Is_Private   : Boolean)
      return Boolean
   is
      function Internal
        (Manager     : System.Address;
         Uri         : String;
         Recent_Data : System.Address)
         return Gboolean;
      pragma Import (C, Internal, "gtk_recent_manager_add_full");

      type Gtk_Recent_Data_Record is record
         display_name : chars_ptr;
         description  : chars_ptr;
         mime_type    : chars_ptr;
         app_name     : chars_ptr;
         app_exec     : chars_ptr;
         groups       : System.Address;
         is_private   : Gboolean;
      end record;
      pragma Convention (C, Gtk_Recent_Data_Record);
      --  Internal record that matches struct _GtkRecentData in
      --  gtkrecentmanager.h

      C_Groups : aliased chars_ptr_array := From_String_List (Groups);
      --  Temporary variable to aid translation

      GRD : aliased Gtk_Recent_Data_Record;
      --  Data to feed in to gtk_recent_manager_add_full()

      Result : Gboolean;
   begin
      --  Set up.
      GRD.display_name := String_Or_Null (Display_Name);
      GRD.description  := String_Or_Null (Description);
      GRD.mime_type    := New_String (Mime_Type);
      GRD.app_name     := New_String (App_Name);
      GRD.app_exec     := New_String (App_Exec);
      GRD.is_private   := Boolean'Pos (Is_Private);

      if C_Groups'Length > 0 then
         GRD.groups := C_Groups (C_Groups'First)'Address;
      else
         GRD.groups := System.Null_Address;
      end if;
      --  Invoke function.
      Result := Internal (Get_Object (Manager), Uri &amp; ASCII.NUL, GRD'Address);

      --  Clean up, making sure to avoid double-deallocations where such
      --  may be possible.
      if GRD.display_name /= Null_Ptr then
         g_free (GRD.display_name);
      end if;
      if GRD.description /= Null_Ptr then
         g_free (GRD.description);
      end if;
      Free (GRD.mime_type);
      Free (GRD.app_name);
      Free (GRD.app_exec);
      for I in C_Groups'Range loop
         if C_Groups (I) /= Null_Ptr then
            Free (C_Groups (I));
         end if;
      end loop;

      --  Return result.
      return Boolean'Val (Result);
   end Add_Full;
       </body>
     </extra>
   </package>

   <package id="GtkRecentInfo">  <!-- into="GtkRecentManager">-->
     <method id="gtk_recent_info_ref" return="void" />

     <!-- ??? Disabled for now, we are creating an unconstrained local var -->
     <method id="gtk_recent_info_get_application_info" return="void" bind="False"/>

     <!-- These functions return the length separately, not needed in Ada-->
     <method id="gtk_recent_info_get_applications" bind="False" />
     <method id="gtk_recent_info_get_groups" bind="False" />

     <extra>
       <type>
   subtype time_t is Long_Integer;
   --  Type to interface with C's time_t type.  To convert this to/from
   --  an Ada type, look at Ada.Calendar.Conversion_Operations and be
   --  sure to pay special attention to the ranges each type is capable
   --  of representing.
       </type>
     </extra>
   </package>

   <package id="GtkRecentChooser">
     <virtual-method id='*' bind='False'/>
     <parameter name="self" ada="Chooser" />
     <method id="gtk_recent_chooser_get_items" return="RecentInfoList"/>
     <enum ctype="GtkRecentSortType" />

     <!-- These functions return the length separately, not needed in Ada-->
     <method id="gtk_recent_chooser_get_uris" bind="False" />

     <method id="gtk_recent_chooser_list_filters" return="RecentFilterSList"/>
   </package>

   <package id="GtkWidgetClass" into="GtkWidget" bindtype="false">
     <method id="gtk_widget_class_find_style_property"/>
     <method id="gtk_widget_class_install_style_property" >
       <parameter name="pspec" ctype="GParamSpec"/>
     </method>
     <method id="gtk_widget_class_set_accessible_role" bind="False" /> <!--  needs atk -->
     <method id="gtk_widget_class_set_accessible_type" bind="False" /> <!--  needs atk -->

     <method id="gtk_widget_class_install_style_property_parser" bind="False" />
     <method id="gtk_widget_class_list_style_properties" bind="False" />

     <method id="gtk_widget_class_set_template" bind="False"/> <!-- needs GBytes -->
     <method id="gtk_widget_class_set_template_from_resource" bind="False"/> <!-- needs GBytes -->
     <method id="gtk_widget_class_bind_template_callback_full" bind="False"/> <!-- useless withouth gtk_widget_class_set_template -->
   </package>

   <package id="GtkWidget" needs_merge="false">
     <parameter name="self" ada="Widget" />
     <enum ctype="GtkAlign"/>
     <enum ctype="GtkWidgetHelpType" />
     <record ctype="GtkRequisition"/>
     <record ctype="GtkWidgetPath"/>
     <list ada="Widget_List" ctype="Widget"/>
     <slist ada="Widget_SList" ctype="Widget"/>

     <method id="::query-tooltip">
        <parameter name="tooltip" ctype="GObject*"/>
     </method>

     <method id="gtk_widget_new" bind="False" /> <!-- varargs -->
     <method id="gtk_widget_style_get" bind="False" /> <!-- varargs -->
     <method id="gtk_widget_style_get_valist" bind="False"/><!-- varargs -->
     <method id="gtk_widget_list_accel_closures" bind="False"/><!-- We do not expose Closures-->
     <method id="gtk_widget_get_style_context" bind="False"/><!-- in Gtk.Style_Context-->
     <method id="gtk_widget_get_accessible" bind="False"/> <!-- Requires ATK -->
     <method id="gtk_widget_get_clipboard" bind="False"/><!-- in Gtk.Clipboard -->
     <method id="gtk_widget_get_settings" bind="False"/><!-- in Gtk.Settings -->
     <method id="gtk_widget_modify_style" bind="False"/><!-- in Gtk.RC -->
     <method id="gtk_widget_get_modifier_style" bind="False"/><!-- in Gtk.RC -->
     <method id="gtk_widget_class_path" bind="False"/><!-- deprecated -->
     <method id="gtk_widget_path" bind="False"/><!-- deprecated -->
     <method id="gtk_drag_source_set_icon_gicon" bind="False"/><!-- does not exist in quartz backend-->
     <method id="gtk_drag_source_get_target_list" bind="False"/><!-- in Gtk.Dnd -->
     <method id="gtk_drag_source_set_target_list" bind="False"/><!-- in Gtk.Dnd-->
     <method id="gtk_drag_begin" bind="False"/><!-- in Gtk.Dnd -->
     <method id="gtk_drag_dest_find_target" bind="False"/><!-- in Gtk.Dnd-->
     <method id="gtk_drag_dest_get_target_list" bind="False"/><!-- in Gtk.Dnd-->
     <method id="gtk_drag_dest_set_target_list" bind="False"/><!-- in Gtk.Dnd-->
     <method id="gtk_drag_dest_set" bind="False"/><!-- in Gtk.Dnd -->
     <method id="gtk_drag_source_set" bind="False"/><!-- in Gtk.Dnd -->
     <method id="gtk_widget_modify_base" obsolescent="True"/>
     <method id="gtk_widget_modify_fg" obsolescent="True">
        <doc extend="true">
         Only states between State_Normal and State_Insensitive are valid.
        </doc>
     </method>
     <method id="gtk_widget_modify_bg" obsolescent="True"/>
     <method id="gtk_widget_modify_text" obsolescent="True"/>
     <method id="gtk_widget_modify_font" obsolescent="True"/>
     <method id="gtk_widget_insert_action_group" bind="False"/> <!--  needs GAction -->
     <method id="gtk_widget_set_sensitive">
       <parameter name="Sensitive" default="True"/>
     </method>
     <method id="gtk_widget_size_allocate">
        <parameter name="allocation" ctype="GtkAllocation" />
     </method>
     <method id="gtk_widget_set_size_request">
       <parameter name="Width" default="-1" />
       <parameter name="Height" default="-1" />
     </method>
     <method id="gtk_widget_add_accelerator">
       <parameter name="Accel_Key" ctype="GdkKeyType" />
       <parameter name="Accel_Signal" ctype="SignalName" />
     </method>
     <method id="gtk_widget_remove_accelerator">
       <parameter name="Accel_Key" ctype="GdkKeyType" />
     </method>
     <method id="gtk_widget_add_events">
       <parameter name="Events" ctype="GdkEventMask"/>
     </method>
     <method id="gtk_widget_set_events">
       <parameter name="Events" ctype="GdkEventMask"/>
     </method>
     <method id="gtk_widget_get_events" return="GdkEventMask"/>
     <method id="gtk_widget_get_tooltip_window" return="GtkWidget*" />
     <method id="gtk_widget_set_tooltip_window">
       <parameter name="Custom_Window" ctype="GtkWidget*"/>
     </method>
     <method id="gtk_widget_list_mnemonic_labels" return="WidgetList" />
     <method id="gtk_widget_render_icon">
       <parameter name="Detail" default='""'/>
     </method>
     <method id="gtk_widget_create_pango_layout">
       <parameter name="Text" allow-none="1"/>
     </method>
     <method id="gtk_widget_intersect">
       <parameter name="Intersection" direction="access"/>
     </method>
     <method id="gtk_widget_translate_coordinates" return_as_param="Result"/>
     <method id="gtk_widget_destroy">
       <body>
      procedure Internal (Widget : System.Address);
      pragma Import (C, Internal, "gtk_widget_destroy");

      procedure Unref_Internal (Widget : System.Address);
      pragma Import (C, Unref_Internal, "g_object_unref");
      --  External binding: g_object_unref

      Ptr : constant System.Address := Get_Object (Widget);

      use type System.Address;
   begin
      --  Keep a reference on the object, so that the Ada structure is
      --  never automatically deleted when the C object is.
      --  We can't reset the content of Widget to System.Null_Address before
      --  calling the C function, because we want the user's destroy
      --  callbacks to be called with the appropriate object.
      Ref (Widget);
      Internal (Ptr);

      --  We then can make sure that the object won't be referenced any
      --  more, (The Ada structure won't be free before the ref count goes
      --  down to 0, and we don't want the user to use a deleted object...).
      Set_Object (Widget, System.Null_Address);

      --  Free the reference we had. In most cases, this results in the
      --  object being freed. We can't use directly Unref, since the Ptr
      --  field for Object is Null_Address.
      Unref_Internal (Ptr);
       </body>
     </method>

     <function id="gtk_cairo_transform_to_window" ada="Transform_To_Window" />
     <function id="gtk_cairo_should_draw_window" ada="Should_Draw_Window" />
     <extra>
       <with_spec pkg="Gdk.Rectangle"/>
       <type>
   subtype Gtk_Allocation is Gdk.Rectangle.Gdk_Rectangle;
       </type>
       <spec>
   ------------------------------------
   -- Override default size handling --
   ------------------------------------

   type Gtk_Requisition_Access is access all Gtk_Requisition;
   type Gtk_Allocation_Access is access all Gtk_Allocation;
   pragma Convention (C, Gtk_Requisition_Access);
   pragma Convention (C, Gtk_Allocation_Access);

   function Get_Requisition
     (Value : Glib.Values.GValue) return Gtk_Requisition_Access;
   function Get_Allocation
     (Value : Glib.Values.GValue) return Gtk_Allocation_Access;
   --  Convert values received as callback parameters

   type Size_Allocate_Handler is access procedure
     (Widget : System.Address; Allocation : Gtk_Allocation);
   pragma Convention (C, Size_Allocate_Handler);
   --  Widget is the gtk+ C widget, that needs to be converted to Ada through
   --  a call to:
   --    declare
   --       Stub : Gtk_Widget_Record; --  or the exact type you expect
   --    begin
   --       My_Widget := Gtk_Widget (Glib.Object.Get_User_Data (Widget, Stub);
   --    end;

   procedure Set_Default_Size_Allocate_Handler
     (Klass   : Glib.Object.GObject_Class;
      Handler : Size_Allocate_Handler);
   pragma Import (C, Set_Default_Size_Allocate_Handler,
                  "ada_WIDGET_CLASS_override_size_allocate");
   --  Override the default size_allocate handler for this class. This handler
   --  is automatically called in several cases (when a widget is dynamically
   --  resized for instance), not through a signal. Thus, if you need to
   --  override the default behavior provided by one of the standard
   --  containers, you can not simply use Gtk.Handlers.Emit_Stop_By_Name, and
   --  you must override the default handler. Note also that this handler
   --  is automatically inherited by children of this class.
   --
   --  This function is not needed unless you are writting your own
   --  widgets, and should be reserved for advanced customization of the
   --  standard widgets.

   type Preferred_Size_Handler is access procedure
      (Widget       : System.Address;
       Minimum_Size : out Glib.Gint;
       Natural_Size : out Glib.Gint);
   pragma Convention (C, Preferred_Size_Handler);

    type Preferred_Size_For_Handler is access procedure
      (Widget       : System.Address;
       Ref          : Glib.Gint;   --  known width or height
       Minimum_Size : out Glib.Gint;
       Natural_Size : out Glib.Gint);
   pragma Convention (C, Preferred_Size_For_Handler);

   procedure Set_Default_Get_Preferred_Width_Handler
      (Klass   : Glib.Object.GObject_Class;
       Handler : Preferred_Size_Handler);
   procedure Set_Default_Get_Preferred_Height_Handler
      (Klass   : Glib.Object.GObject_Class;
       Handler : Preferred_Size_Handler);
   procedure Set_Default_Get_Preferred_Height_For_Width_Handler
      (Klass   : Glib.Object.GObject_Class;
       Handler : Preferred_Size_For_Handler);
   procedure Set_Default_Get_Preferred_Width_For_Height_Handler
      (Klass   : Glib.Object.GObject_Class;
       Handler : Preferred_Size_For_Handler);
   pragma Import (C, Set_Default_Get_Preferred_Width_Handler,
                  "ada_WIDGET_CLASS_override_get_preferred_width");
   pragma Import (C, Set_Default_Get_Preferred_Height_Handler,
                  "ada_WIDGET_CLASS_override_get_preferred_height");
   pragma Import (C, Set_Default_Get_Preferred_Height_For_Width_Handler,
                  "ada_WIDGET_CLASS_override_get_preferred_height_for_width");
   pragma Import (C, Set_Default_Get_Preferred_Width_For_Height_Handler,
                  "ada_WIDGET_CLASS_override_get_preferred_width_for_height");
   --  Override the computation of a widget's preferred sizes.
   --  You will only need to override this computation if you are writting
   --  your own container widgets.

   procedure Inherited_Get_Preferred_Width
      (Klass      : Glib.Object.Ada_GObject_Class;
       Widget     : access Gtk_Widget_Record'Class;
       Minimum_Size, Natural_Size : out Glib.Gint);
   procedure Inherited_Get_Preferred_Width_For_Height
      (Klass      : Glib.Object.Ada_GObject_Class;
       Widget     : access Gtk_Widget_Record'Class;
       Height     : Glib.Gint;
       Minimum_Size, Natural_Size : out Glib.Gint);
   procedure Inherited_Get_Preferred_Height
      (Klass      : Glib.Object.Ada_GObject_Class;
       Widget     : access Gtk_Widget_Record'Class;
       Minimum_Size, Natural_Size : out Glib.Gint);
   procedure Inherited_Get_Preferred_Height_For_Width
      (Klass      : Glib.Object.Ada_GObject_Class;
       Widget     : access Gtk_Widget_Record'Class;
       Width      : Glib.Gint;
       Minimum_Size, Natural_Size : out Glib.Gint);
   --  Call the default implementation

   procedure Inherited_Size_Allocate
      (Klass      : Glib.Object.Ada_GObject_Class;
       Widget     : access Gtk_Widget_Record'Class;
       Allocation : Gtk_Allocation);
   --  Call the inherited size_allocate. This is useful if you have overloaded it in
   --  your own class, but still need to call the standard implementation.

   type Realize_Handler is access procedure (Widget : System.Address);
   pragma Convention (C, Realize_Handler);
   procedure Set_Default_Realize_Handler
      (Klass   : Glib.Object.GObject_Class;
       Handler : Realize_Handler);
   pragma Import (C, Set_Default_Realize_Handler,
                  "ada_WIDGET_CLASS_override_realize");
   --  Override the handler for the "realize" signal. This handler should
   --  create the window for the widget

   procedure Inherited_Realize
      (Klass      : Glib.Object.Ada_GObject_Class;
       Widget     : access Gtk_Widget_Record'Class);
   --  Call the inherited realize.

   ---------------------------
   -- Override Draw handler --
   ---------------------------

   generic
       with function Draw
          (W  : access Gtk_Widget_Record'Class;
           Cr : Cairo.Cairo_Context) return Boolean;
   function Proxy_Draw
      (W  : System.Address; Cr : Cairo.Cairo_Context) return Gboolean;
   pragma Convention (C, Proxy_Draw);

   type Draw_Handler is access function
     (W  : System.Address;
      Cr : Cairo.Cairo_Context) return Gboolean;
   pragma Convention (C, Draw_Handler);
   --  A function responsible for drawing a widget.

   procedure Set_Default_Draw_Handler
      (Klass : Glib.Object.GObject_Class; Handler : Draw_Handler);
   --  Override the default drawing function. This in general gives more
   --  control than connection to Signal_Draw, however a widget is responsible
   --  for drawing its children.
   --  Use the generic Proxy_Draw to create a suitable callback.

   function Inherited_Draw
      (Klass  : Glib.Object.Ada_GObject_Class;
       Widget : access Gtk_Widget_Record'Class;
       Cr     : Cairo.Cairo_Context) return Boolean;
   --  Call the inherited draw. This is useful if you have overloaded draw in
   --  your own class, but still need to draw the child widgets that do not
   --  have their own window (the others will already get their own "draw"
   --  event.
   --  See http://developer.gnome.org/gtk3/3.0/chap-drawing-model.html
   --  for an explanation of the gtk+ drawing model.
       </spec>
       <with_body pkg="Ada.Unchecked_Conversion" use="False"/>
       <body>
   function Convert is new Ada.Unchecked_Conversion
      (Draw_Handler, System.Address);

   function Proxy_Draw
      (W  : System.Address;
       Cr : Cairo.Cairo_Context) return Gboolean
   is
      Stub : Gtk_Widget_Record;
      W2 : constant Gtk_Widget := Gtk_Widget (Get_User_Data (W, Stub));
   begin
      return Boolean'Pos (Draw (W2, Cr));
   end Proxy_Draw;

   function Inherited_Draw
      (Klass  : Glib.Object.Ada_GObject_Class;
       Widget : access Gtk_Widget_Record'Class;
       Cr     : Cairo.Cairo_Context) return Boolean
   is
       function Internal (Klass : Ada_GObject_Class;
                          Widget : System.Address;
                          Cr : Cairo.Cairo_Context) return Gboolean;
       pragma Import (C, Internal, "ada_inherited_WIDGET_CLASS_draw");
   begin
      return Internal (Klass, Widget.Get_Object, Cr) /= 0;
   end Inherited_Draw;

   procedure Inherited_Get_Preferred_Width
      (Klass  : Glib.Object.Ada_GObject_Class;
       Widget     : access Gtk_Widget_Record'Class;
       Minimum_Size, Natural_Size : out Glib.Gint)
   is
       procedure Internal (Klass : Ada_GObject_Class;
                           Widget : System.Address;
                           Min, Nat : out Glib.Gint);
       pragma Import
          (C, Internal, "ada_inherited_WIDGET_CLASS_get_preferred_width");
   begin
       Internal (Klass, Widget.Get_Object, Minimum_Size, Natural_Size);
   end Inherited_Get_Preferred_Width;

   procedure Inherited_Get_Preferred_Width_For_Height
      (Klass  : Glib.Object.Ada_GObject_Class;
       Widget     : access Gtk_Widget_Record'Class;
       Height     : Glib.Gint;
       Minimum_Size, Natural_Size : out Glib.Gint)
   is
       procedure Internal (Klass    : Ada_GObject_Class;
                           Widget   : System.Address;
                           Height   : Glib.Gint;
                           Min, Nat : out Glib.Gint);
       pragma Import
          (C, Internal, "ada_inherited_WIDGET_CLASS_get_preferred_width_for_height");
   begin
       Internal (Klass, Widget.Get_Object, Height, Minimum_Size, Natural_Size);
   end Inherited_Get_Preferred_Width_For_Height;

   procedure Inherited_Get_Preferred_Height
      (Klass  : Glib.Object.Ada_GObject_Class;
       Widget     : access Gtk_Widget_Record'Class;
       Minimum_Size, Natural_Size : out Glib.Gint)
   is
       procedure Internal (Klass : Ada_GObject_Class;
                           Widget : System.Address;
                           Min, Nat : out Glib.Gint);
       pragma Import
          (C, Internal, "ada_inherited_WIDGET_CLASS_get_preferred_height");
   begin
       Internal (Klass, Widget.Get_Object, Minimum_Size, Natural_Size);
   end Inherited_Get_Preferred_Height;

   procedure Inherited_Get_Preferred_Height_For_Width
      (Klass  : Glib.Object.Ada_GObject_Class;
       Widget     : access Gtk_Widget_Record'Class;
       Width      : Glib.Gint;
       Minimum_Size, Natural_Size : out Glib.Gint)
   is
       procedure Internal (Klass : Ada_GObject_Class;
                           Widget : System.Address;
                           Width      : Glib.Gint;
                           Min, Nat : out Glib.Gint);
       pragma Import
          (C, Internal, "ada_inherited_WIDGET_CLASS_get_preferred_height_for_width");
   begin
       Internal (Klass, Widget.Get_Object, Width, Minimum_Size, Natural_Size);
   end Inherited_Get_Preferred_Height_For_Width;

   procedure Inherited_Size_Allocate
      (Klass      : Glib.Object.Ada_GObject_Class;
       Widget     : access Gtk_Widget_Record'Class;
       Allocation : Gtk_Allocation)
   is
       procedure Internal (Klass : Ada_GObject_Class;
                           Widget : System.Address;
                           Allocation : Gtk_Allocation);
       pragma Import
          (C, Internal, "ada_inherited_WIDGET_CLASS_size_allocate");
   begin
       Internal (Klass, Widget.Get_Object, Allocation);
   end Inherited_Size_Allocate;

   procedure Inherited_Realize
      (Klass      : Glib.Object.Ada_GObject_Class;
       Widget     : access Gtk_Widget_Record'Class)
   is
       procedure Internal (Klass : Ada_GObject_Class;
                           Widget : System.Address);
       pragma Import
          (C, Internal, "ada_inherited_WIDGET_CLASS_realize");
   begin
       Internal (Klass, Widget.Get_Object);
   end Inherited_Realize;

   procedure Set_Default_Draw_Handler
      (Klass : Glib.Object.GObject_Class; Handler : Draw_Handler)
   is
      procedure Internal (K : GObject_Class; H : System.Address);
      pragma Import (C, Internal, "ada_WIDGET_CLASS_override_draw");
   begin
      Internal (Klass, Convert (Handler));
   end Set_Default_Draw_Handler;

   function Get_Allocation
     (Value : Glib.Values.GValue) return Gtk_Allocation_Access
   is
      pragma Warnings (Off);
      --  This UC is safe aliasing-wise, so kill warning
      function To_Allocation is new
        Ada.Unchecked_Conversion (System.Address, Gtk_Allocation_Access);
      pragma Warnings (On);
   begin
      return To_Allocation (Glib.Values.Get_Address (Value));
   end Get_Allocation;

   function Get_Requisition
     (Value : Glib.Values.GValue) return Gtk_Requisition_Access
   is
      pragma Warnings (Off);
      --  This UC is safe aliasing-wise, so kill warning
      function To_Requisition is new
        Ada.Unchecked_Conversion (System.Address, Gtk_Requisition_Access);
      pragma Warnings (On);
   begin
      return To_Requisition (Glib.Values.Get_Address (Value));
   end Get_Requisition;
       </body>
     </extra>
   </package>

   <package id="PangoEnums">
     <enum ctype="PangoAlignment" ada="Alignment"/>
     <enum ctype="PangoAttrType" ada="Attr_Type"/>
     <enum ctype="PangoCoverageLevel" ada="Coverage_Level"/>
     <enum ctype="PangoDirection" ada="Direction"/>
     <enum ctype="PangoFontMask" ada="Font_Mask"/>
     <enum ctype="PangoGravity" ada="Gravity"/>
     <enum ctype="PangoGravityHint" ada="GravityHint"/>
     <enum ctype="PangoStretch" ada="Stretch"/>
     <enum ctype="PangoStyle" ada="Style"/>
     <enum ctype="PangoUnderline" ada="Underline"/>
     <enum ctype="PangoVariant" ada="Variant"/>
     <enum ctype="PangoWeight" ada="Weight"/>
     <enum ctype="PangoWrapMode" ada="Wrap_Mode"/>

     <extra>
       <with_spec pkg="Glib"/>
       <spec>
   Pango_Scale : constant := 1024;
   --  All internal units in Pango are expressed in terms of this unit. A
   --  typical pango size must be divided by Pango_Scale to get the equivalent
   --  in pixels.

   function To_Pixels (Pango_Units : Gint) return Gint;
   --  Convert a size in pango units to pixels. This is a rounding of
   --  Pango_Units divided by Pango_Scale

   --  Enum types are bound with the following algorithm:
   --    + the "Pango" prefix of the type name is stripped
   --    + Each word of the type name is separated by '_'
   --    + the full enum name is kept, but capitalized.

   --  All enums types should be sorted by alphabetical order...
       </spec>
       <body>
   function To_Pixels (Pango_Units : Gint) return Gint is
   begin
      if Pango_Units > 0 then
         return (Pango_Units + Pango_Scale / 2) / Pango_Scale;
      else
         return (Pango_Units - Pango_Scale / 2) / Pango_Scale;
      end if;
   end To_Pixels;
       </body>
     </extra>
   </package>

   <package id="GtkEnums">
     <enum ctype="GtkArrowType"/>
     <enum ctype="GtkAttachOptions"/>
     <enum ctype="GtkButtonBoxStyle"/>
     <enum ctype="GtkCornerType"/>
     <enum ctype="GtkDeleteType"/>
     <enum ctype="GtkDirectionType"/>
     <enum ctype="GtkDragResult"/>
     <enum ctype="GtkExpanderStyle"/>
     <enum ctype="GtkIconSize" asbitfield="True"/>
     <enum ctype="GtkJunctionSides"/>
     <enum ctype="GtkBaselinePosition"/>
     <enum ctype="GtkJustification"/>
     <enum ctype="GtkMenuDirectionType"/>
     <enum ctype="GtkMovementStep"/>
     <enum ctype="GtkInputHints"/>
     <enum ctype="GtkInputPurpose"/>
     <enum ctype="GtkNumberUpLayout" prefix="GTK_NUMBER_UP_LAYOUT_"/>
     <enum ctype="GtkOrientation"/>
     <enum ctype="GtkPackDirection"/>
     <enum ctype="GtkPackType"/>
     <enum ctype="GtkPageOrientation"/>
     <enum ctype="GtkPageSet"/>
     <enum ctype="GtkPanDirection"/>
     <enum ctype="GtkPopoverConstraint"/>
     <enum ctype="GtkPropagationPhase"/>
     <enum ctype="GtkEventSequenceState"/>
     <enum ctype="GtkLevelBarMode"/>
     <enum ctype="GtkPathPriorityType"/>
     <enum ctype="GtkPathType"/>
     <enum ctype="GtkPolicyType"/>
     <enum ctype="GtkPositionType"/>
     <enum ctype="GtkPrintDuplex"/>
     <enum ctype="GtkPrintPages"/>
     <enum ctype="GtkPrintQuality"/>
     <enum ctype="GtkRegionFlags"/>
     <enum ctype="GtkReliefStyle"/>
     <enum ctype="GtkResizeMode"/>
     <enum ctype="GtkScrollStep"/>
     <enum ctype="GtkScrollType"/>
     <enum ctype="GtkScrollablePolicy"/>
     <enum ctype="GtkSelectionMode"/>
     <enum ctype="GtkSensitivityType"/>
     <enum ctype="GtkShadowType"/>
     <enum ctype="GtkSizeRequestMode" prefix="GTK_SIZE_REQUEST_"/>
     <enum ctype="GtkSortType"/>
     <enum ctype="GtkStateFlags" prefix=""/>
     <enum ctype="GtkStateType"/>
     <enum ctype="GtkTargetFlags" prefix=""/>
     <enum ctype="GtkTextDirection"/>
     <enum ctype="GtkTextWindowType"/>
     <enum ctype="GtkTreeViewGridLines" prefix="GTK_TREE_VIEW_"/>
     <enum ctype="GtkToolbarSpaceStyle"/>
     <enum ctype="GtkToolbarStyle"/>
     <enum ctype="GtkUnit" prefix="GTK_UNIT_"/>
     <enum ctype="GtkWindowPosition"/>
     <enum ctype="GtkWindowType"/>
     <enum ctype="GtkWrapMode"/>

     <extra>
       <with_spec pkg="Glib.Glist"/>
       <with_spec pkg="Glib.GSlist"/>
       <spec>
   function Convert (S : String) return System.Address;
   function Convert (S : System.Address) return String;
   package String_List is new Glib.Glist.Generic_List (UTF8_String);
   package String_SList is new Glib.GSlist.Generic_SList (UTF8_String);
   --  Warning: when you create this list, new memory gets allocated for
   --  all the strings. You should use the function Free_String_List
   --  instead of Glib.Glist.Free to be sure to free this memory.

   procedure Free_String_List (List : in out String_List.Glist);
   procedure Free_String_List (List : in out String_SList.GSlist);
   --  Free the memory occupied by all the strings in the list, as well
   --  as the memory occupied by the list itself.
       </spec>
       <with_body pkg="Ada.Unchecked_Conversion" use="False"/>
       <with_body pkg="Gtkada.Types" use="False"/>
       <body>
   function Convert (S : String) return System.Address is
      function Internal is new
        Ada.Unchecked_Conversion (Gtkada.Types.Chars_Ptr, System.Address);
   begin
      return Internal (Gtkada.Types.New_String (S));
   end Convert;

   function Convert_Chars_Ptr is new
     Ada.Unchecked_Conversion (System.Address, Gtkada.Types.Chars_Ptr);

   function Convert (S : System.Address) return String is
   begin
      return Gtkada.Types.Value (Convert_Chars_Ptr (S));
   end Convert;

   procedure Free_String_List (List : in out String_List.Glist) is
      use type String_List.Glist;
      Tmp   : String_List.Glist := List;
      Chars : Gtkada.Types.Chars_Ptr;
   begin
      while Tmp /= String_List.Null_List loop
         Chars := Convert_Chars_Ptr (String_List.Get_Data_Address (Tmp));
         Gtkada.Types.g_free (Chars);
         Tmp := String_List.Next (Tmp);
      end loop;

      String_List.Free (List);
      List := String_List.Null_List;
   end Free_String_List;

   procedure Free_String_List (List : in out String_SList.GSlist) is
      use type String_SList.GSlist;

      Tmp   : String_SList.GSlist := List;
      Chars : Gtkada.Types.Chars_Ptr;
   begin
      while Tmp /= String_SList.Null_List loop
         Chars := Convert_Chars_Ptr (String_SList.Get_Data_Address (Tmp));
         Gtkada.Types.g_free (Chars);
         Tmp := String_SList.Next (Tmp);
      end loop;

      String_SList.Free (List);
      List := String_SList.Null_List;
   end Free_String_List;
       </body>
     </extra>
   </package>

   <package id="GtkContainer">
     <parameter name="self" ada="Container"/>
     <method id="gtk_container_add_with_properties" bind="False"/><!-- varargs -->
     <method id="gtk_container_child_get" bind="False"/> <!-- varargs -->
     <method id="gtk_container_child_get_valist" bind="False"/> <!-- varargs -->
     <method id="gtk_container_child_set" bind="False"/> <!-- varargs -->
     <method id="gtk_container_child_set_valist" bind="False"/> <!-- varargs -->
     <method id="gtk_container_get_children" return="WidgetList"/>
     <method id="gtk_container_set_focus_chain">
       <parameter name="focusable_widgets" ctype="WidgetList"/>
     </method>
     <method id="gtk_container_child_set_property">
       <parameter name="value" direction="in" ctype="GValue"/>
     </method>

     <!-- ??? Binding needs testing -->
     <method id="gtk_container_get_focus_chain" return_as_param="Success" bind="false">
       <parameter name="focusable_widgets" ctype="WidgetList*" direction="out"/>
     </method>
   </package>

   <package id="GtkSpinButton">
     <parameter name="self" ada="Spin_Button"/>
     <enum ctype="GtkSpinType"/>
     <enum ctype="GtkSpinButtonUpdatePolicy"/>
     <method id="gtk_spin_button_new_with_range" ada="Gtk_New"/>
     <method id="gtk_spin_button_new">
       <parameter name="digits" default="0"/>
     </method>
   </package>

   <package id="GtkAction">
     <parameter name="self" ada="Action"/>
     <method id="gtk_action_get_accel_closure" bind="False" /> <!-- Closures not handled-->
     <method id="gtk_action_get_proxies" return="WidgetSList*"/>
   </package>

   <package id="GtkMenu">
     <parameter name="self" ada="Menu"/>
     <callback id="Gtk_Menu_Position_Func">
        <parameter name="x" direction="out"/>
        <parameter name="y" direction="out"/>
     </callback>
     <method id="gtk_menu_get_active" return="GtkMenuItem"/>
     <method id="gtk_menu_popup">
       <parameter name="parent_menu_shell" ctype="GtkMenuShell" default="null"/>
       <parameter name="parent_menu_item" ctype="GtkMenuItem" default="null"/>
       <parameter name="func" default="null"/>
       <parameter name="button" default="1"/>
       <parameter name="activate_time" default="0"/>
     </method>
     <method id="gtk_menu_get_for_attach_widget" return="WidgetList*"/>
   </package>

   <package id="GtkMenuBar">
     <parameter name="self" ada="Menu_Bar"/>
   </package>

   <package id="GtkMenuShell">
     <parameter name="self" ada="Menu_Shell"/>
   </package>

   <package id="GtkMenuToolButton">
     <parameter name="self" ada="Button"/>
     <method id="gtk_menu_tool_button_new">
       <parameter name="self" ada="Menu"/>
       <parameter name="icon_widget" default="null"/>
     </method>
     <method id="gtk_menu_tool_button_new_from_stock">
       <parameter name="self" ada="Menu"/>
     </method>
     <method id="gtk_menu_tool_button_get_menu" return="GtkMenu"/>
   </package>

   <package id="GtkImageMenuItem">
     <method id="gtk_image_menu_item_new"/>
     <method id="gtk_image_menu_item_new_with_label" ada="Gtk_New"/>
   </package>

   <package id="GtkCheckMenuItem">
     <parameter name="self" ada="Check_Menu_Item"/>
      <method id="gtk_check_menu_item_new" bind="False"/>
      <method id="gtk_check_menu_item_new_with_label" ada="Gtk_New" >
         <parameter name="label" default='""' allow-none="1"/>
      </method>
   </package>

   <package id="GdkRGBA">
     <method id="gdk_rgba_equal">
       <parameter name="p2" ctype="GdkRGBA*"/>
     </method>
     <method id="gdk_rgba_parse" return_as_param="Success">
       <parameter name="self" direction="out"/>
     </method>
     <extra>
       <with_spec pkg="Glib.Values" />
       <with_spec pkg="Glib.Object" />
       <spec>
   type array_of_Gdk_RGBA is array (Natural range &lt;&gt;) of Gdk_RGBA;

   Null_RGBA  : constant Gdk_RGBA := (0.0, 0.0, 0.0, 0.0);
   Black_RGBA : constant Gdk_RGBA := (0.0, 0.0, 0.0, 1.0);
   White_RGBA : constant Gdk_RGBA := (1.0, 1.0, 1.0, 1.0);

   type Property_RGBA is new Glib.Property;
   procedure Set_Property
     (Object : access Glib.Object.GObject_Record'Class;
      Name   : Property_RGBA;
      Value  : Gdk_RGBA);
   function Get_Property
     (Object : access Glib.Object.GObject_Record'Class;
      Name   : Property_RGBA) return Gdk_RGBA;

   function Gdk_RGBA_Or_Null (Val : System.Address) return System.Address;
   --  Used for the GtkAda binding itself.
   --  Return either a Null_Address or a pointer to Val, depending on
   --  whether Val is the null value for the type.
   --  In all cases, Val is supposed to be an access to the type mentioned in
   --  the name of the subprogram.
   --  In Ada2012, these could be replaced with expression functions instead.

   procedure Set_Value (Value : in out Glib.Values.GValue; Val : Gdk_RGBA);
   function  Get_Value (Value : Glib.Values.GValue) return Gdk_RGBA;
   --  Conversion functions for storing a Gdk_RGBA as a GValue.
       </spec>
       <with_body pkg="Glib.Generic_Properties" />
       <body>
   function To_Address
     (Val : Gdk_RGBA; Addr : System.Address) return System.Address;
   package RGBA_Properties is new Generic_Internal_Boxed_Property
     (Gdk_RGBA, Gdk.RGBA.Get_Type, To_Address);

   procedure Set_Property
     (Object : access Glib.Object.GObject_Record'Class;
      Name   : Property_RGBA;
      Value  : Gdk_RGBA) is
   begin
      RGBA_Properties.Set_Property
         (Object, RGBA_Properties.Property (Name), Value);
   end Set_Property;

   function Get_Property
     (Object : access Glib.Object.GObject_Record'Class;
      Name   : Property_RGBA) return Gdk_RGBA is
   begin
      return RGBA_Properties.Get_Property
        (Object, RGBA_Properties.Property (Name));
   end Get_Property;

   function Gdk_RGBA_Or_Null (Val : System.Address) return System.Address is
      function Internal is new Gtkada.Bindings.Generic_To_Address_Or_Null
        (Gdk_RGBA, Null_RGBA);
   begin
      return Internal (Val);
   end Gdk_RGBA_Or_Null;

   function Get_Value (Value : Glib.Values.GValue) return Gdk_RGBA
     renames RGBA_Properties.Get_Value;
   procedure Set_Value (Value : in out Glib.Values.GValue; Val : Gdk_RGBA)
     renames RGBA_Properties.Set_Value;

   function To_Address
     (Val : Gdk_RGBA; Addr : System.Address) return System.Address is
   begin
      if Val = Null_RGBA then
         return System.Null_Address;
      else
         return Addr;
      end if;
   end To_Address;
       </body>
     </extra>
   </package>

   <package id="GtkScrolledWindow">
     <parameter name="self" ada="Scrolled_Window"/>
     <method id="gtk_scrolled_window_new">
       <parameter name="hadjustment" default="null"/>
       <parameter name="vadjustment" default="null"/>
     </method>
     <method id="gtk_scrolled_window_get_hscrollbar" return="GtkScrollbar"/>
     <method id="gtk_scrolled_window_get_vscrollbar" return="GtkScrollbar"/>
   </package>

   <package id="GtkWindow">
     <parameter name="self" ada="Window"/>
     <method id="gtk_window_new">
       <parameter name="type" default="Gtk.Enums.Window_Toplevel"/>
     </method>
     <method id="gtk_window_set_opacity" bind="False"/> <!-- would hide Gtk.Widget.Set_Opacity-->
     <method id="gtk_window_get_opacity" bind="False"/> <!-- would hide Gtk.Widget.Get_Opacity-->
     <method id="gtk_window_list_toplevels" return="WidgetList"/>
     <method id="gtk_window_get_icon_list" return="ObjectList"/>
     <method id="gtk_window_set_icon_list">
       <parameter name="list" ctype="ObjectList"/>
     </method>
     <method id="gtk_window_get_default_icon_list" return="ObjectList"/>
     <method id="gtk_window_set_default_icon_list">
       <parameter name="list" ctype="ObjectList"/>
     </method>
     <method id="gtk_window_add_mnemonic">
       <parameter name="keyval" ctype="GdkKeyType"/>
     </method>
     <method id="gtk_window_remove_mnemonic">
       <parameter name="keyval" ctype="GdkKeyType"/>
     </method>
     <method id="gtk_window_mnemonic_activate">
       <parameter name="keyval" ctype="GdkKeyType"/>
     </method>
     <method id="gtk_window_get_resize_grip_area" return_as_param="retrieved"/>
     <method id="gtk_window_set_modal">
       <parameter name="modal" default="True"/>
     </method>

     <method id="gtk_window_get_application" bind="False"/> <!-- Circular dependency -->
     <method id="gtk_window_set_application" bind="False"/> <!-- Circular dependency -->
   </package>

   <package id="GtkWindowGroup" into="GtkWindow">
     <parameter name="self" ada="Window_Group"/>
     <method id="gtk_window_group_get_type" ada="Group_Get_Type"/>
     <method id="gtk_window_group_list_windows" return="WidgetList"/>
   </package>

   <package id="GtkPaperSize">
     <parameter name="self" ada="Widget"/>
     <list ada="Gtk_Paper_Size_Glist" ctype="GtkPaperSize" section="Functions"/>
     <method id="gtk_paper_size_get_paper_sizes" return="GtkPaperSizeList"/>
     <extra>
       <spec>
   --  Common names, from PWG 5101.1-2002 PWG: Standard for Media Standardized
   --  Names
   Gtk_Paper_Name_A3        : constant String := "iso_a3";
   Gtk_Paper_Name_A4        : constant String := "iso_a4";
   Gtk_Paper_Name_A5        : constant String := "iso_a5";
   Gtk_Paper_Name_B5        : constant String := "iso_b5";
   Gtk_Paper_Name_Letter    : constant String := "na_letter";
   Gtk_Paper_Name_Executive : constant String := "na_executive";
   Gtk_Paper_Name_Legal     : constant String := "na_legal";
       </spec>
     </extra>
   </package>

   <package id="GtkRecentAction">
     <parameter name="self" ada="Widget"/>
     <method id="gtk_recent_action_new_for_manager">
       <parameter name="manager" default="Gtk.Recent_Manager.Get_Default"/>
     </method>
   </package>

   <package id="GtkTearoffMenuItem">
     <parameter name="self" ada="Menu_Item"/>
   </package>

   <package id="GtkRecentChooserDialog">
     <parameter name="self" ada="Widget"/>
     <extra>
       <gir:constructor c:identifier="ada_gtk_recent_chooser_dialog_new" name="new">
         <gir:return-value>
           <gir:type name="GtkWidget" c:type="GtkWidget*"/>
         </gir:return-value>
         <gir:parameters>
           <gir:parameter name="title" allow-none="1">
             <gir:type name="utf8" c:type="gchar*"/>
           </gir:parameter>
           <gir:parameter name="parent" allow-none="1">
             <gir:type name="Window" c:type="GtkWindow*"/>
           </gir:parameter>
         </gir:parameters>
       </gir:constructor>
       <gir:constructor c:identifier="ada_gtk_recent_chooser_dialog_new_for_manager" name="new_for_manager">
         <gir:return-value>
           <gir:type name="GtkWidget" c:type="GtkWidget*"/>
         </gir:return-value>
         <gir:parameters>
           <gir:parameter name="title" allow-none="1">
             <gir:type name="utf8" c:type="gchar*"/>
           </gir:parameter>
           <gir:parameter name="parent" allow-none="1">
             <gir:type name="Window" c:type="GtkWindow*"/>
           </gir:parameter>
           <gir:parameter name="manager" allow-none="1">
             <gir:type name="RecentManager" c:type="GtkRecentManager*"/>
           </gir:parameter>
         </gir:parameters>
       </gir:constructor>
     </extra>
   </package>

   <package id="GtkRecentChooserMenu">
   </package>

   <package id="GtkRecentChooserWidget">
     <parameter name="self" ada="Widget"/>
   </package>

   <package id="GtkToggleAction">
     <parameter name="self" ada="Action"/>
   </package>

   <package id="GtkToggleToolButton">
     <parameter name="self" ada="Button"/>
   </package>

   <package id="GtkStyle">
     <parameter name="self" ada="Style"/>
      <method id="gtk_style_get_valist" bind="False"/><!-- va_list -->
      <method id="gtk_style_lookup_color"
              return_as_param="Found"/>

      <method id="gtk_style_render_icon" bind="False"/>  <!-- need icon_source -->
      <method id="gtk_style_lookup_icon_set" bind="False"/>  <!-- need icon_factory -->
   </package>

   <package id="GtkSymbolicColor">
     <method id="gtk_symbolic_color_resolve" bind="False"/> <!-- circular dep with StyleProperties -->
   </package>

   <package id="GtkStyleProvider">
      <virtual-method id='*' bind='False'/>  <!--  circular dep with StyleProperties -->
     <method id="gtk_style_provider_get_style" bind="False" /> <!-- circular dep with StyleProperties -->
     <method id="gtk_style_provider_get_style_property"
             return_as_param="Found"/>
     <method id="gtk_style_provider_get_icon_factory" bind="False" /> <!-- in GtkIconFactory -->
     <extra>
       <spec>
         subtype Priority is Glib.Guint;

         Priority_Fallback : constant Priority := 1;
         --  Used when no theme is defined

         Priority_Theme : constant Priority := 200;
         --  Used for style information provided by the theme

         Priority_Settings : constant Priority := 400;
         --  Used for information provided via Gtk_Settings

         Priority_Application : constant Priority := 600;
         --  For application-specific information

         Priority_User : constant Priority := 800;
         --  Used for the style information from ~/.gtk-3.0.css
       </spec>
     </extra>
   </package>

   <package id="GtkStyleProperties">
      <virtual-method id='*' bind='False'/>  <!--  circular dep with StyleProvider -->
     <method id="gtk_style_properties_get_property"
             return_as_param="Exists"/>
     <method id="gtk_style_properties_set_valist" bind="False"/> <!-- need valist -->
     <method id="gtk_style_properties_get_valist" bind="False"/> <!-- need valist -->
     <method id="gtk_style_properties_lookup_property" bind="False"/> <!-- need StylePropertyParser -->
     <method id="gtk_style_properties_register_property" bind="False"/> <!-- need StylePropertyParser -->
   </package>

   <package id="GtkStyleContext">
     <enum ctype="GtkStyleContextPrintFlags"/>
     <method id="gtk_style_context_has_region"
             return_as_param="Is_Defined"/>
     <method id="gtk_style_context_list_classes" return="StringList"/>
     <method id="gtk_style_context_list_regions" return="StringList"/>
     <method id="gtk_style_context_get_valist" bind="False"/> <!-- needs valist -->
     <method id="gtk_style_context_get_style_valist" bind="False"/> <!-- needs valist -->
     <method id="gtk_style_context_lookup_color" return_as_param="Found"/>
     <method id="gtk_style_context_state_is_running"
             return_as_param="Is_Running"/>
     <method id="gtk_style_context_lookup_icon_set" bind="False"/> <!--  in GtkIconSet-->
     <function id="gtk_render_handle"/>
     <function id="gtk_render_check" />
     <function id="gtk_render_option" />
     <function id="gtk_render_arrow" />
     <function id="gtk_render_background" />
     <function id="gtk_render_frame" />
     <function id="gtk_render_expander" />
     <function id="gtk_render_focus" />
     <function id="gtk_render_layout" />
     <function id="gtk_render_line" />
     <function id="gtk_render_slider" />
     <function id="gtk_render_frame_gap" />
     <function id="gtk_render_extension" />
     <function id="gtk_render_activity" />
     <!--  <function id="gtk_render_icon_pixbuf" /> -->
     <function id="gtk_render_icon" />
     <function id="gtk_render_icon_surface" />
     <extra>
       <spec>
   function Get_Style_Context
      (Widget : not null access Gtk_Widget_Record'Class)
       return Gtk_Style_Context;
   --  Returns the style context associated to Widget.
   --  must not be freed.
       </spec>
       <body>
   function Get_Style_Context
      (Widget : not null access Gtk_Widget_Record'Class)
       return Gtk_Style_Context
   is
      function Internal (Widget : System.Address) return System.Address;
      pragma Import (C, Internal, "gtk_widget_get_style_context");
      Stub_Gtk_Style_Context : Gtk_Style_Context_Record;
   begin
      return Gtk_Style_Context
         (Get_User_Data (Internal (Get_Object (Widget)), Stub_Gtk_Style_Context));
   end Get_Style_Context;
       </body>
     </extra>
   </package>

   <package id="GtkToolButton">
     <parameter name="self" ada="Button"/>
     <method id="gtk_tool_button_new">
       <parameter name="icon_widget" default="null" />
     </method>
   </package>

   <package id="GtkFontButton">
     <parameter name="self" ada="Font_Button"/>
   </package>

   <package id="GtkFontChooser">
     <enum ctype="GtkFontChooserLevel"/>
   </package>

   <package id="GtkTextBuffer">
     <parameter name="self" ada="Buffer"/>

      <!-- the following involve a complex callback type and are not needed -->
     <method id="gtk_text_buffer_register_serialize_format" bind="False"/>
     <method id="gtk_text_buffer_register_deserialize_format" bind="False"/>
     <method id="gtk_text_buffer_serialize" bind="False"/>
     <method id="gtk_text_buffer_deserialize" bind="False"/>
     <method id="gtk_text_buffer_get_serialize_formats" bind="False"/>
     <method id="gtk_text_buffer_get_deserialize_formats" bind="False"/>

     <method id="gtk_text_buffer_new">
        <parameter name="table" default="null"/>
     </method>

     <method id="gtk_text_buffer_create_mark">
        <parameter name="left_gravity" default="True"/>
     </method>

     <method id="gtk_text_buffer_get_text">
        <parameter name="include_hidden_chars" default="False"/>
     </method>

     <method id="gtk_text_buffer_get_slice">
        <parameter name="include_hidden_chars" default="False"/>
     </method>

     <method id="gtk_text_buffer_paste_clipboard">
        <parameter name="override_location" ada="" ctype="gpointer" default="System.Null_Address"/>
        <parameter name="default_editable" default="True"/>
     </method>

     <method id="gtk_text_buffer_get_selection_bounds" return_as_param="Result">
        <parameter name="start" direction="out"/>
        <parameter name="end" direction="out"/>
     </method>

     <method id="gtk_text_buffer_delete">
        <parameter name="start" direction="inout"/>
        <parameter name="end" direction="inout"/>
     </method>

     <method id="gtk_text_buffer_delete_interactive" return_as_param="Result">
        <parameter name="start" direction="inout"/>
        <parameter name="end" direction="inout"/>
     </method>

     <method id="gtk_text_buffer_insert">
        <parameter name="iter" direction="inout"/>
        <parameter name="len" default="-1" ada=""/>
     </method>

     <method id="gtk_text_buffer_insert_interactive">
        <parameter name="iter" direction="inout"/>
        <parameter name="len" default="-1" ada=""/>
     </method>

     <method id="gtk_text_buffer_insert_interactive_at_cursor">
        <parameter name="len" default="-1" ada=""/>
     </method>

     <method id="gtk_text_buffer_set_text">
        <parameter name="len" default="-1" ada=""/>
     </method>

     <method id="gtk_text_buffer_insert_at_cursor">
        <parameter name="len" default="-1" ada=""/>
     </method>

     <method id="gtk_text_buffer_create_tag" bind="False"/><!-- vararg, bound manually below -->
     <method id="gtk_text_buffer_insert_with_tags" bind="False"/><!-- vararg, bound manually below -->

      <!-- body bound manually to add safety check -->
     <method id="gtk_text_buffer_get_iter_at_line_offset">
        <body>
      procedure Internal
         (Buffer      : System.Address;
          Iter        : out Gtk.Text_Iter.Gtk_Text_Iter;
          Line_Number : Gint;
          Char_Offset : Gint);
      pragma Import (C, Internal, "gtk_text_buffer_get_iter_at_line_offset");
      Result   : Boolean;
   begin
      --  Prevent critical crashes from gtk+ if Char_Offset is invalid
      Internal (Get_Object (Buffer), Iter, Line_Number, 0);

      if not Ends_Line (Iter) then
         Forward_To_Line_End (Iter, Result);

         if Char_Offset &lt;= Get_Line_Offset (Iter) then
            Internal (Get_Object (Buffer), Iter, Line_Number, Char_Offset);
         end if;
      end if;
       </body>
     </method>

     <extra>
       <with_spec pkg="Gtkada.Types"/>
       <spec>
   procedure Insert
     (Buffer : access Gtk_Text_Buffer_Record;
      Iter   : in out Gtk.Text_Iter.Gtk_Text_Iter;
      Text   : Gtkada.Types.Chars_Ptr);
   --  More efficient version of Insert, which doesn't require a string copy.

   procedure Insert_At_Cursor
     (Buffer : access Gtk_Text_Buffer_Record;
      Text   : Gtkada.Types.Chars_Ptr;
      Len    : Gint := -1);
   --  Call Buffer_Insert, using the current cursor position
   --  as the insertion point.
   --  Text: UTF-8 format C string to insert.

   function Get_Text
     (Buffer               : access Gtk_Text_Buffer_Record;
      Start                : Gtk.Text_Iter.Gtk_Text_Iter;
      The_End              : Gtk.Text_Iter.Gtk_Text_Iter;
      Include_Hidden_Chars : Boolean := False) return Gtkada.Types.Chars_Ptr;
   --  Same as Get_Text above, but return a pointer to a C string, for
   --  efficiency.
   --  The caller is responsible for freeing (using Gtkada.Types.g_free) the
   --  returned pointer.

   function Selection_Exists
     (Buffer : access Gtk_Text_Buffer_Record) return Boolean;
   --  Return True if some text in the buffer is currently selected.

   procedure Insert_With_Tags
     (Buffer : access Gtk_Text_Buffer_Record;
      Iter   : in out Gtk.Text_Iter.Gtk_Text_Iter;
      Text   : UTF8_String;
      Tag    : Gtk_Text_Tag);
   procedure Insert_With_Tags
     (Buffer : access Gtk_Text_Buffer_Record;
      Iter   : in out Gtk.Text_Iter.Gtk_Text_Iter;
      Text   : Gtkada.Types.Chars_Ptr;
      Tag    : Gtk.Text_Tag.Gtk_Text_Tag);
   --  Same as Insert, but specifies the tag to apply to the range.

   function Get_Buffer
      (Iter : Gtk_Text_Iter) return Gtk.Text_Buffer.Gtk_Text_Buffer;
   --  Returns the Gtk.Text_Buffer.Gtk_Text_Buffer this iterator is associated
   --  with.

   function Get_Buffer
      (Mark : Gtk_Text_Mark)
       return Gtk.Text_Buffer.Gtk_Text_Buffer;
   --  Gets the buffer this mark is located inside, or null if the mark is
   --  deleted.

   function Create_Tag
     (Buffer              : access Gtk_Text_Buffer_Record;
      Tag_Name            : String := "")
      return Gtk.Text_Tag.Gtk_Text_Tag;
   --  Creates a tag and adds it to the tag table for Buffer. Equivalent to
   --  calling gtk.text_tag.gtk_new and then adding the tag to the buffer's tag
   --  table. The returned tag is owned by the buffer's tag table, so the ref
   --  count will be equal to one.
   --
   --  If Tag_Name is NULL, the tag is anonymous, otherwise a tag called
   --  Tag_Name must not already exist in the tag table for this buffer.
       </spec>
       <body>
   ------------
   -- Insert --
   ------------

   procedure Insert
     (Buffer : access Gtk_Text_Buffer_Record;
      Iter   : in out Gtk.Text_Iter.Gtk_Text_Iter;
      Text   : Gtkada.Types.Chars_Ptr)
   is
      procedure Internal
        (Buffer : System.Address;
         Iter   : Gtk.Text_Iter.Gtk_Text_Iter;
         Text   : Gtkada.Types.Chars_Ptr;
         Len    : Gint := -1);
      pragma Import (C, Internal, "gtk_text_buffer_insert");

   begin
      Internal (Get_Object (Buffer), Iter, Text);
   end Insert;

   procedure Insert_At_Cursor
     (Buffer : access Gtk_Text_Buffer_Record;
      Text   : Gtkada.Types.Chars_Ptr;
      Len    : Gint := -1)
   is
      procedure Internal
        (Buffer : System.Address;
         Text   : Gtkada.Types.Chars_Ptr;
         Len    : Gint);
      pragma Import (C, Internal, "gtk_text_buffer_insert_at_cursor");

   begin
      Internal (Get_Object (Buffer), Text, Len);
   end Insert_At_Cursor;

   procedure Insert_With_Tags
     (Buffer : access Gtk_Text_Buffer_Record;
      Iter   : in out Gtk.Text_Iter.Gtk_Text_Iter;
      Text   : UTF8_String;
      Tag    : Gtk_Text_Tag)
   is
      procedure Internal
        (Buffer : System.Address;
         Iter   : in out Gtk.Text_Iter.Gtk_Text_Iter;
         Text   : UTF8_String;
         Len    : Gint;
         Tag    : System.Address);
      pragma Import (C, Internal, "ada_gtk_text_buffer_insert_with_tags");

   begin
      Internal
        (Get_Object (Buffer), Iter, Text, Text'Length, Get_Object (Tag));
   end Insert_With_Tags;

   procedure Insert_With_Tags
     (Buffer : access Gtk_Text_Buffer_Record;
      Iter   : in out Gtk.Text_Iter.Gtk_Text_Iter;
      Text   : Gtkada.Types.Chars_Ptr;
      Tag    : Gtk.Text_Tag.Gtk_Text_Tag)
   is
      procedure Internal
        (Buffer : System.Address;
         Iter   : in out Gtk.Text_Iter.Gtk_Text_Iter;
         Text   : Gtkada.Types.Chars_Ptr;
         Len    : Gint := -1;
         Tag    : System.Address);
      pragma Import (C, Internal, "ada_gtk_text_buffer_insert_with_tags");

   begin
      Internal (Get_Object (Buffer), Iter, Text, Tag => Get_Object (Tag));
   end Insert_With_Tags;

   --------------
   -- Get_Text --
   --------------

   function Get_Text
     (Buffer               : access Gtk_Text_Buffer_Record;
      Start                : Gtk.Text_Iter.Gtk_Text_Iter;
      The_End              : Gtk.Text_Iter.Gtk_Text_Iter;
      Include_Hidden_Chars : Boolean := False) return Gtkada.Types.Chars_Ptr
   is
      function Internal
        (Buffer               : System.Address;
         Start                : Gtk.Text_Iter.Gtk_Text_Iter;
         The_End              : Gtk.Text_Iter.Gtk_Text_Iter;
         Include_Hidden_Chars : Gboolean)
         return Gtkada.Types.Chars_Ptr;
      pragma Import (C, Internal, "gtk_text_buffer_get_text");

   begin
      return Internal
        (Get_Object (Buffer),
         Start,
         The_End,
         Boolean'Pos (Include_Hidden_Chars));
   end Get_Text;

   function Selection_Exists
     (Buffer : access Gtk_Text_Buffer_Record) return Boolean
   is
      Ignored_A, Ignored_B : Gtk_Text_Iter;
      Has_Selection : Boolean;
   begin
      Get_Selection_Bounds (Buffer, Ignored_A, Ignored_B, Has_Selection);
      return Has_Selection;
   end Selection_Exists;

   ----------------
   -- Get_Buffer --
   ----------------

   function Get_Buffer
      (Iter : Gtk_Text_Iter) return Gtk.Text_Buffer.Gtk_Text_Buffer
   is
      function Internal (Iter : Gtk_Text_Iter) return System.Address;
      pragma Import (C, Internal, "gtk_text_iter_get_buffer");
      Stub_Gtk_Text_Buffer : Gtk.Text_Buffer.Gtk_Text_Buffer_Record;
   begin
      return Gtk.Text_Buffer.Gtk_Text_Buffer (Get_User_Data (Internal (Iter), Stub_Gtk_Text_Buffer));
   end Get_Buffer;

   ----------------
   -- Get_Buffer --
   ----------------

   function Get_Buffer
      (Mark : Gtk_Text_Mark)
       return Gtk.Text_Buffer.Gtk_Text_Buffer
   is
      function Internal (Mark : System.Address) return System.Address;
      pragma Import (C, Internal, "gtk_text_mark_get_buffer");
      Stub_Gtk_Text_Buffer : Gtk.Text_Buffer.Gtk_Text_Buffer_Record;
   begin
      return Gtk.Text_Buffer.Gtk_Text_Buffer (Get_User_Data (Internal (Get_Object (Mark)), Stub_Gtk_Text_Buffer));
   end Get_Buffer;

   ----------------
   -- Create_Tag --
   ----------------

   function Create_Tag
     (Buffer              : access Gtk_Text_Buffer_Record;
      Tag_Name            : String := "")
      return Gtk_Text_Tag
   is
      function Internal
        (Buffer              : System.Address;
         Tag_Name            : Gtkada.Types.Chars_Ptr)
         return System.Address;
      pragma Import (C, Internal, "ada_gtk_text_buffer_create_tag");
      Stub : Gtk_Text_Tag_Record;
      Str  : Gtkada.Types.Chars_Ptr := String_Or_Null (Tag_Name);
      Tag  : Gtk_Text_Tag;
   begin
      Tag := Gtk_Text_Tag
        (Get_User_Data (Internal (Get_Object (Buffer), Str), Stub));
      Free (Str);
      return Tag;
   end Create_Tag;
       </body>
     </extra>
   </package>

   <package id="GtkTextMark">
     <parameter name="self" ada="Mark"/>
     <method id="gtk_text_mark_get_buffer" bind="False"/><!-- circular dependency, added manually in Gtk.Text_Buffer -->

     <extra>
       <with_spec pkg="Glib.Values"/>
       <spec>
   -------------------------------
   -- Converting to/from GValue --
   -------------------------------

   procedure Set_Text_Mark
     (Val  : in out Glib.Values.GValue;
      Mark : access Gtk_Text_Mark_Record);
   function Get_Text_Mark (Val : Glib.Values.GValue) return Gtk_Text_Mark;
   --  Set the value of the given GValue to Mark.

       </spec>
       <body>
   -------------------
   -- Set_Text_Mark --
   -------------------

   procedure Set_Text_Mark
     (Val  : in out Glib.Values.GValue;
      Mark : access Gtk_Text_Mark_Record) is
   begin
      Glib.Values.Set_Address (Val, Get_Object (Mark));
   end Set_Text_Mark;

   -------------------
   -- Get_Text_Mark --
   -------------------

   function Get_Text_Mark (Val  : Glib.Values.GValue) return Gtk_Text_Mark is
      Stub : Gtk_Text_Mark_Record;
   begin
      return Gtk_Text_Mark
        (Get_User_Data_Fast (Glib.Values.Get_Address (Val), Stub));
   end Get_Text_Mark;
       </body>
     </extra>
   </package>

   <package id="GtkTextChildAnchor">
     <parameter name="self" ada="Anchor"/>
     <method id="gtk_text_child_anchor_get_widgets" return="WidgetSList"/>
   </package>

   <package id="GtkTextTag">
     <parameter name="self" ada="Tag"/>
     <method id="::event" bind="False" />
     <method id="gtk_text_tag_new">
       <doc extend="true">
Newly created tags must be added to the tags table for the buffer you
intend to use them in, as in:
 "Gtk.Text_Tag_Table.Add (Get_Tag_Table (Buffer), Tag)".
See also Gtk.Text_Buffer.Create_Tag which is a more convenient way of
creating a tag.
       </doc>
     </method>
     <method id="gtk_text_tag_event" bind="false"/> <!-- circular dep with text_iter-->
     <slist ada="Text_Tag_List" ctype="GtkTextTag"/>
   </package>

   <package id="GtkCssProvider">
     <method id="::parsing-error" bind="False" />
     <method id="gtk_css_provider_load_from_data">
       <parameter name="data" ctype="char*"/>
       <parameter name="length" default="-1" ada=""/>
       <parameter name="error" direction="access"/>
     </method>
     <method id="gtk_css_provider_load_from_path">
       <parameter name="error" direction="access"/>
     </method>
     <method id="gtk_css_provider_load_from_file" bind="False"/> <!--  needs GFile -->
   </package>

   <package id="GtkMain">
     <function id="gtk_get_major_version" />
     <function id="gtk_get_minor_version" />
     <function id="gtk_get_micro_version" />
     <function id="gtk_get_binary_age" />
     <function id="gtk_get_interface_age" />
     <function id="gtk_check_version" />
     <function id="gtk_parse_args" bind="False" /> <!-- no access to argc argv -->x
     <function id="gtk_init" bind="False" /> <!--  custom -->
     <function id="gtk_init_check" bind="False" /> <!-- custom -->
     <function id="gtk_init_with_args" bind="False" />
     <function id="gtk_disable_setlocale"/>
     <function id="gtk_get_default_language"/>
     <function id="gtk_events_pending"/>
     <function id="gtk_main_do_event"/>
     <function id="gtk_main"/>
     <function id="gtk_main_level"/>
     <function id="gtk_main_quit"/>
     <function id="gtk_main_iteration" />
     <function id="gtk_main_iteration_do"/>
     <function id="gtk_true" />
     <function id="gtk_false" />
     <function id="gtk_grab_add" bind="False" />  <!--  in GtkWidget -->
     <function id="gtk_grab_get_current" />
     <function id="gtk_grab_remove" bind="False"/>  <!--  in GtkWidget -->
     <function id="gtk_device_grab_add" />
     <function id="gtk_device_grab_remove" />
     <function id="gtk_key_snooper_install" />
     <function id="gtk_key_snooper_remove" />
     <function id="gtk_get_current_event" />
     <function id="gtk_get_current_event_time" />
     <function id="gtk_get_current_event_state"
               return_as_param="Has_Current_Event">
       <parameter name="state" direction="out" />
     </function>
     <function id="gtk_get_current_event_device" />
     <function id="gtk_get_event_widget" />
     <function id="gtk_propagate_event" />

     <extra>
       <with_body pkg="Interfaces.C"/>
       <spec>
   procedure Init;
   --  Initialize GtkAda's internal structures.
   --  This subprogram should be called before any other one in GtkAda.
   --  If GtkAda could not be initialized (no access to the display, etc.), the
   --  application exits with an error

   function Init_Check return Boolean;
   --  Initialize GtkAda's internal structures.
   --  Return False if there was an error (no access to the display, etc.)
       </spec>
       <body>
   gnat_argc : Interfaces.C.int;
   pragma Import (C, gnat_argc);

   gnat_argv : System.Address;
   pragma Import (C, gnat_argv);

   procedure Init is
      procedure Internal (argc : System.Address; argv : System.Address);
      pragma Import (C, Internal, "gtk_init");

   begin
      Internal (gnat_argc'Address, gnat_argv'Address);
   end Init;

   function Init_Check return Boolean is
      function Internal
        (argc : System.Address; argv : System.Address) return Gboolean;
      pragma Import (C, Internal, "gtk_init_check");
   begin
      return Boolean'Val (Internal (gnat_argc'Address, gnat_argv'Address));
   end Init_Check;
       </body>
     </extra>
   </package>

   <package id="GdkCursor" bindtype="False">
     <enum ctype="GdkCursorType" prefix="GDK_"/>

     <method id="gdk_cursor_new_from_pixbuf" bind="False" />  <!--  in gdk.pixbuf -->
     <method id="gdk_cursor_get_image" bind="False" />  <!--  in gdk.pixbuf -->

     <method id="gdk_cursor_unref" bind="False" />  <!--  obsolete -->
     <method id="gdk_cursor_ref" bind="False" />  <!--  obsolete -->

     <method id="gdk_cursor_get_surface" return_as_param="Surface"/>

     <extra>
       <spec>
   procedure Ref (Self : Gdk.Gdk_Cursor);
   pragma Import (C, Ref, "g_object_ref");

   procedure Unref (Self : Gdk.Gdk_Cursor);
   pragma Import (C, Unref, "g_object_unref");
       </spec>
     </extra>
   </package>

   <package id="GtkTextAttributes">
     <parameter name="self" ada="Text_Attr"/>
     <record ctype="GtkTextAppearance"/>

   </package>

   <package id="GtkTextTagTable">
     <parameter name="self" ada="Table"/>
     <method id='gtk_text_tag_table_add' return='void'/> <!--  backward compatibility -->
   </package>

   <package id="GtkTextView">
     <parameter name="self" ada="View"/>
     <enum ctype="GtkTextViewLayer" />
     <enum ctype="GtkTextExtendSelection"/>

     <!-- These are now inherited from the Scrollable interface -->
     <method id="gtk_text_view_get_hadjustment" bind="false"/>
     <method id="gtk_text_view_get_vadjustment" bind="false"/>
     <method id="gtk_text_view_set_hadjustment" bind="false"/>
     <method id="gtk_text_view_set_vadjustment" bind="false"/>

     <method id="gtk_text_view_new_with_buffer" ada="Gtk_New"/>

     <virtual-method id='draw_layer' bind='True'>
        <doc>
The draw_layer virtual function is called before and after the text
view is drawing its own text. Applications can override this vfunc
in a subclass to draw customized content underneath or above the
text. Since: 3.14
        </doc>
     </virtual-method>
   </package>

   <package id="GdkWindow" bindtype="False">
     <record ctype="GdkGeometry"/>
     <enum ctype="GdkWindowWindowClass" prefix="GDK_" ada="Gdk_Window_Class"/>
     <enum ctype="GdkWindowEdge" prefix="GDK_"/>
     <enum ctype="GdkWindowType" prefix="GDK_"/>
     <enum ctype="GdkWindowAttributesType" prefix="GDK_"/>
     <enum ctype="GdkWindowHints" prefix="GDK_"/>
     <enum ctype="GdkWindowTypeHint" prefix="GDK_"/>
     <enum ctype="GdkWMDecoration" prefix="GDK_"/>
     <enum ctype="GdkWMFunction" prefix="GDK_"/>
     <enum ctype="GdkGravity" prefix="GDK_"/>
     <enum ctype="GdkFullscreenMode" prefix="GDK_FULLSCREEN_" />
     <enum ctype="GdkAnchorHints" prefix="GDK_"/>
     <list ada="Gdk_Window_List" ctype="GdkWindow"/>
     <method id="::pick-embedded-child" bind="False" />
     <method id="::from-embedder" bind="False" />
     <method id="::to-embedder" bind="False" />
     <method id="::create-surface" bind="False" />
     <method id="::moved-to-rect" bind="False" />
     <method id="gdk_window_add_filter" bind="False" />   <!-- dangerous -->
     <method id="gdk_window_remove_filter" bind="False" />   <!-- dangerous -->
     <method id="gdk_window_get_children" return="GdkWindowList"/>
     <method id="gdk_window_get_decorations" return_as_param="Has_Decorations"/>
     <method id="gdk_window_get_device_position" return_as_param="Window"/>
     <method id="gdk_window_get_origin" return="void"/>
     <method id="gdk_window_get_pointer" return_as_param="Window"/>
     <method id="gdk_window_peek_children" return="GdkWindowList" />
     <method id="gdk_window_at_pointer" return_as_param="Window"/>
     <method id="gdk_window_new">
        <parameter name="attributes_mask" ctype="GdkWindowAttributesType"/>
     </method>

<!--     <method id="gdk_window_get_events" bind="False" /> <!- circular dep with GdkEvent -->
<!--     <method id="gdk_window_set_events" bind="False" /> <!- circular dep with GdkEvent -->
<!--     <method id="gdk_window_get_device_events" bind="False" /> <!- circular dep with GdkEvent -->
<!--     <method id="gdk_window_set_device_events" bind="False" /> <!- circular dep with GdkEvent -->
<!--     <method id="gdk_window_get_source_events" bind="False" /> <!- circular dep with GdkEvent -->
<!--     <method id="gdk_window_set_source_events" bind="False" /> <!- circular dep with GdkEvent -->

     <method id="gdk_window_set_icon_list" bind="False"/> <!--  needs PixbufList -->
     <method id="gdk_window_get_drag_protocol" return_as_param="Protocol" bind="False"/> <!--  circular dep with GdkDragContent -->

     <method id="gdk_window_get_user_data" bind="False"/>  <!-- see below -->
     <method id="gdk_window_get_children_with_user_data" bind="False"/> <!-- low-level -->

     <extra>
       <spec>
   function Get_User_Data (Window : Gdk_Window) return Glib.Object.GObject;
   --  Return the widget to which events are reported when they happen on
   --  Window. This is the widget that was set through the call to
   --  Set_User_data.

   procedure Set_User_Data
     (Window : Gdk_Window;
      Widget : access Glib.Object.GObject_Record'Class);
   --  Sets a special field in the window.
   --  All the events reported by the Xserver (or the Windows server) for
   --  Window will be redirected to Widget through the standard signals
   --  "expose_event", "button_press_event", ...
   --  You almost always need to call this function after creating a new
   --  Gdk_Window yourself, or you won't be able to handle the events.

   procedure Ref (Window : Gdk_Window);
   procedure Unref (Window : Gdk_Window);
   pragma Import (C, Ref, "g_object_ref");
   pragma Import (C, Unref, "g_object_unref");
       </spec>
       <body>
   function Get_User_Data (Window : Gdk_Window) return Glib.Object.GObject is
      procedure Internal (Window : Gdk_Window; Widget : System.Address);
      pragma Import (C, Internal, "gdk_window_get_user_data");
      Data : aliased System.Address;
      Stub : GObject_Record;
   begin
      Internal (Window, Data'Address);
      return Get_User_Data (Data, Stub);
   end Get_User_Data;

   procedure Set_User_Data
     (Window : Gdk_Window;
      Widget : access Glib.Object.GObject_Record'Class)
   is
      procedure Internal (Window : Gdk_Window; Widget : System.Address);
      pragma Import (C, Internal, "gdk_window_set_user_data");
   begin
      Internal (Window, Get_Object (Widget));
   end Set_User_Data;
       </body>
     </extra>
   </package>

   <package id="GtkIconView">
     <parameter name="self" ada="Icon_View"/>
     <enum ctype="GtkIconViewDropPosition" prefix="GTK_ICON_VIEW_"/>
     <method id="gtk_icon_view_get_cursor" return_as_param="Cursor_Is_Set"/>
     <method id="gtk_icon_view_get_dest_item_at_pos" return_as_param="Has_Item"/>
     <method id="gtk_icon_view_get_item_at_pos" return_as_param="Has_Item"/>
     <method id="gtk_icon_view_get_selected_items" return="TreePathList"/>
     <method id="gtk_icon_view_get_tooltip_context" return_as_param="Success"/>
     <method id="gtk_icon_view_get_visible_range" return="void"/>

     <method id="gtk_icon_view_enable_model_drag_source" bind="False"/> <!-- see below -->
     <method id="gtk_icon_view_enable_model_drag_dest" bind="False"/> <!-- see below -->
     <extra>
       <with_spec pkg="Gtk.Target_List"/>
       <with_spec pkg="Gdk.Dnd"/>
       <with_spec pkg="Gdk.Types"/>
       <spec>
   procedure Enable_Model_Drag_Dest
     (Icon_View : access Gtk_Icon_View_Record;
      Targets   : Gtk.Target_List.Target_Entry_Array;
      Actions   : Gdk.Dnd.Drag_Action);
   --  Turns Icon_view into a drop destination for automatic DND.
   --  Targets is the list of targets that the drag will support.

   procedure Enable_Model_Drag_Source
     (Icon_View         : access Gtk_Icon_View_Record;
      Start_Button_Mask : Gdk.Types.Gdk_Modifier_Type;
      Targets           : Gtk.Target_List.Target_Entry_Array;
      Actions           : Gdk.Dnd.Drag_Action);
   --  Turns Icon_view into a drag source for automatic DND.
   --  Start_Button_Mask is the allowed buttons to start drag.
       </spec>
       <body>
   procedure Enable_Model_Drag_Dest
     (Icon_View : access Gtk_Icon_View_Record;
      Targets   : Target_Entry_Array;
      Actions   : Drag_Action)
   is
      procedure Internal
        (Icon_View : System.Address;
         Targets   : System.Address;
         N_Targets : Gint;
         Actions   : Drag_Action);
      pragma Import (C, Internal, "gtk_icon_view_enable_model_drag_dest");
   begin
      Internal (Get_Object (Icon_View),
                Targets (Targets'First)'Address, Targets'Length,
                Actions);
   end Enable_Model_Drag_Dest;

   procedure Enable_Model_Drag_Source
     (Icon_View         : access Gtk_Icon_View_Record;
      Start_Button_Mask : Gdk_Modifier_Type;
      Targets           : Target_Entry_Array;
      Actions           : Drag_Action)
   is
      procedure Internal
        (Icon_View         : System.Address;
         Start_Button_Mask : Gdk_Modifier_Type;
         Targets           : System.Address;
         N_Targets         : Gint;
         Actions           : Drag_Action);
      pragma Import (C, Internal, "gtk_icon_view_enable_model_drag_source");
   begin
      Internal (Get_Object (Icon_View), Start_Button_Mask,
                Targets (Targets'First)'Address, Targets'Length,
                Actions);
   end Enable_Model_Drag_Source;
       </body>
     </extra>
   </package>

   <package id="GdkEvent">
     <enum ctype="GdkEventType" prefix="GDK_" ignore="GDK_DOUBLE_BUTTON_PRESS GDK_TRIPLE_BUTTON_PRESS"/>
     <enum ctype="GdkEventMask" prefix="GDK_"/>
     <enum ctype="GdkVisibilityState" prefix="GDK_"/>
     <enum ctype="GdkScrollDirection" prefix="GDK_"/>
     <enum ctype="GdkNotifyType" prefix="GDK_"/>
     <enum ctype="GdkCrossingMode" prefix="GDK_"/>
     <enum ctype="GdkPropertyState" prefix="GDK_"/>
     <enum ctype="GdkWindowState" prefix="GDK_"/>
     <enum ctype="GdkSettingAction" prefix="GDK_"/>
     <enum ctype="GdkOwnerChange" prefix="GDK_"/>
     <record ctype="GdkEventSequence"/>
     <record ctype="GdkEventAny"/>
     <record ctype="GdkEventButton"/>
     <record ctype="GdkEventExpose"/>
     <record ctype="GdkEventVisibility"/>
     <record ctype="GdkEventMotion"/>
     <record ctype="GdkEventScroll"/>
     <record ctype="GdkEventKey"/>
     <record ctype="GdkEventCrossing"/>
     <record ctype="GdkEventFocus"/>
     <record ctype="GdkEventConfigure"/>
     <record ctype="GdkEventProperty"/>
     <record ctype="GdkEventSelection"/>
     <record ctype="GdkEventOwnerChange"/>
     <record ctype="GdkEventProximity"/>
     <record ctype="GdkEventDND"/>
     <record ctype="GdkEventWindowState"/>
     <record ctype="GdkEventSetting"/>
     <record ctype="GdkEventTouch"/>
     <record ctype="GdkEventGrabBroken"/>
     <record ctype="GdkEventGrabBroken"/>
     <record ctype="GdkEventTouchpadSwipe"/>
     <record ctype="GdkEventTouchpadPinch"/>
     <record ctype="GdkEventPadButton"/>
     <record ctype="GdkEventPadAxis"/>
     <record ctype="GdkEventPadGroupMode"/>

     <record ctype="GdkEvent" ada="Gdk_Event_Record">
       <union value="GDK_NOTHING" field="any"/>
       <union value="GDK_DELETE" field="any"/>
       <union value="GDK_DESTROY" field="any" />
       <union value="GDK_EXPOSE" field="expose" />
       <union value="GDK_MOTION_NOTIFY" field="motion" />
       <union value="GDK_BUTTON_PRESS" field="button" />
       <union value="GDK_2BUTTON_PRESS" field="button" />
       <union value="GDK_3BUTTON_PRESS" field="button" />
       <union value="GDK_BUTTON_RELEASE" field="button" />
       <union value="GDK_KEY_PRESS" field="key" />
       <union value="GDK_KEY_RELEASE" field="key" />
       <union value="GDK_ENTER_NOTIFY" field="crossing" />
       <union value="GDK_LEAVE_NOTIFY" field="crossing" />
       <union value="GDK_FOCUS_CHANGE" field="focus_change" />
       <union value="GDK_CONFIGURE" field="configure" />
       <union value="GDK_MAP" field="any" />
       <union value="GDK_UNMAP" field="any" />
       <union value="GDK_PROPERTY_NOTIFY" field="property" />
       <union value="GDK_SELECTION_CLEAR" field="selection" />
       <union value="GDK_SELECTION_REQUEST" field="selection" />
       <union value="GDK_SELECTION_NOTIFY" field="selection" />
       <union value="GDK_PROXIMITY_IN" field="proximity" />
       <union value="GDK_PROXIMITY_OUT" field="proximity" />
       <union value="GDK_DRAG_ENTER" field="dnd" />
       <union value="GDK_DRAG_LEAVE" field="dnd" />
       <union value="GDK_DRAG_MOTION" field="dnd" />
       <union value="GDK_DRAG_STATUS" field="dnd" />
       <union value="GDK_DROP_START" field="dnd" />
       <union value="GDK_DROP_FINISHED" field="dnd" />
       <union value="GDK_CLIENT_EVENT" field="any" />
       <union value="GDK_VISIBILITY_NOTIFY" field="visibility" />
       <union value="GDK_SCROLL" field="scroll" />
       <union value="GDK_WINDOW_STATE" field="window_state" />
       <union value="GDK_SETTING" field="setting" />
       <union value="GDK_OWNER_CHANGE" field="owner_change" />
       <union value="GDK_GRAB_BROKEN" field="grab_broken" />
       <union value="GDK_DAMAGE" field="expose" />
       <union value="GDK_TOUCH_BEGIN" field="touch" />
       <union value="GDK_TOUCH_UPDATE" field="touch" />
       <union value="GDK_TOUCH_END" field="touch" />
       <union value="GDK_TOUCH_CANCEL" field="touch" />
       <union value="GDK_TOUCHPAD_SWIPE" field="touchpad_swipe" />
       <union value="GDK_TOUCHPAD_PINCH" field="touchpad_pinch" />
       <union value="GDK_PAD_BUTTON_PRESS" field="pad_button" />
       <union value="GDK_PAD_BUTTON_RELEASE" field="pad_button" />
       <union value="GDK_PAD_RING" field="pad_axis" />
       <union value="GDK_PAD_STRIP" field="pad_axis" />
       <union value="GDK_PAD_GROUP_MODE" field="pad_group_mode" />
     </record>

     <method id="gdk_event_get_coords" return="void"/>
     <method id="gdk_event_get_root_coords" return="void"/>
     <method id="gdk_event_get_axis" return="void"/>
     <method id="gdk_event_get_scroll_direction" return="void"/>
     <method id="gdk_event_get_scroll_deltas" return="void"/>

     <!--  These are getters provided by gtk+ itself. They are reused from our
           own misc.c file, because we want GtkAda to raise exceptions instead.
           See <extra> below
     -->
     <method id="gdk_event_get_button" bind="False"/>
     <method id="gdk_event_get_state" bind="False"/>
     <method id="gdk_event_get_click_count" bind="False"/>
     <method id="gdk_event_get_keyval" bind="False"/>
     <method id="gdk_event_get_keycode" bind="False"/>

     <!--  Avoid circular dependencies  Event->Device->Display->Event -->
     <method id="gdk_event_get_device" bind="False"/>
     <method id="gdk_event_get_source_device" bind="False"/>
     <method id="gdk_event_set_device" bind="False"/>
     <method id="gdk_event_set_source_device" bind="False"/>
     <method id="gdk_event_get_screen" bind="False"/>
     <method id="gdk_event_set_screen" bind="False"/>
     <method id="gdk_event_get_seat" return="GObject*"/>

     <function id="gdk_events_pending" ada="Events_Pending"/>
     <method id="gdk_events_get_angle" ada="Get_Angle"/>
     <method id="gdk_events_get_center" ada="Get_Center"/>
     <method id="gdk_events_get_distance" ada="Get_Distance"/>
     <function id="gdk_set_show_events" ada="Set_Show_Events"/>
     <function id="gdk_get_show_events" ada="Get_Show_Events"/>

     <extra>
       <gir:method name="Get_Button" c:identifier="ada_gdk_event_get_button">
         <gir:doc>Extract the button number from an event</gir:doc>
         <gir:return-value><gir:type name="guint" c:type="guint"/></gir:return-value>
       </gir:method>
       <gir:method name="Get_State" c:identifier="ada_gdk_event_get_state">
         <gir:doc>State of the mouse buttons and keyboard keys just prior to the event</gir:doc>
         <gir:return-value><gir:type name="GdkModifierType" c:type="GdkModifierType"/></gir:return-value>
       </gir:method>
       <gir:method name="Get_Key_Val" c:identifier="ada_gdk_event_get_keyval">
         <gir:doc>Code of the key that was pressed (and that generated the event)</gir:doc>
         <gir:return-value><gir:type name="GdkKeyType" c:type="GdkKeyType"/></gir:return-value>
       </gir:method>
       <gir:method name="Get_Keycode" c:identifier="ada_gdk_event_get_keycode">
         <gir:doc>Hardware key code of the key that was pressed</gir:doc>
         <gir:return-value><gir:type name="guint" c:type="guint"/></gir:return-value>
       </gir:method>

       <type ctype="GdkEvent*" ada="Gdk_Event">
         type Gdk_Event is access all Gdk_Event_Record;
         pragma No_Strict_Aliasing (Gdk_Event);
       </type>
       <with_spec pkg="Glib.Values" />
       <spec>
         Double_Button_Press : constant Gdk_Event_Type := Gdk_2button_Press;
         Triple_Button_Press : constant Gdk_Event_Type := Gdk_3button_Press;

         Button_Primary   : constant Gint := 1;
         Button_Secondary : constant Gint := 3;
         Button_Middle    : constant Gint := 2;
         --  The primary button is typically the left mouse button, or the
         --  right button in a left-handed setup. The secondary button is the
         --  other one.

         function From_Address (C : System.Address) return Gdk_Event;
         --  Convert a C handler to the matching Event structure.

         function To_Address (C : Gdk_Event) return System.Address;
         --  Convert an event to the underlying C handler.

         function Get_Event (Value : Glib.Values.GValue) return Gdk_Event;
         --  Convert a value into a Gdk_Event.

         function To_Event (Event : access Gdk_Event_Button) return Gdk_Event;
         function To_Event (Event : access Gdk_Event_Key) return Gdk_Event;
         --  Cast Event into a Gdk_Event, which can be used to call some of
         --  subprograms in the API. The return value is a pointer to Event,
         --  which should therefore remain valid as long as the pointer is in
         --  use.

   -------------------------------
   -- Some constants used below --
   -------------------------------
   --  This constants have the '-1' since in some cases gtk itself uses
   --  the extrema to return some meaningful value (for instance, the result
   --  of Get_Area can have the values Guint16'Last to mean the whole area).

   Invalid_Gdouble_Value : constant Gdouble := Gdouble'Last - 1.0;
   Invalid_Gint_Value    : constant Gint    := Gint'Last - 1;
   Invalid_Guint_Value   : constant Guint   := Guint'Last - 1;
   Invalid_Guint32_Value : constant Guint32 := Guint32'Last - 1;
   Invalid_Gulong_Value  : constant Gulong  := Gulong'Last - 1;

   pragma Export (C, Invalid_Gdouble_Value, "ada_gdk_invalid_gdouble_value");
   pragma Export (C, Invalid_Gint_Value, "ada_gdk_invalid_gint_value");
   pragma Export (C, Invalid_Guint_Value, "ada_gdk_invalid_guint_value");
   pragma Export (C, Invalid_Guint32_Value, "ada_gdk_invalid_guint32_value");
   pragma Export (C, Invalid_Gulong_Value, "ada_gdk_invalid_gulong_value");
       </spec>
       <body>
   function From_Address (C : System.Address) return Gdk_Event is
      function Convert is new Ada.Unchecked_Conversion
           (Glib.C_Proxy, Gdk_Event);
   begin
      return Convert (Glib.C_Proxy'(Glib.To_Proxy (C)));
   end From_Address;

   function To_Address (C : Gdk_Event) return System.Address is
      function Convert is new Ada.Unchecked_Conversion
           (Gdk_Event, Glib.C_Proxy);
   begin
      return Glib.To_Address (Convert (C));
   end To_Address;

   function Get_Event (Value : Glib.Values.GValue) return Gdk_Event is
      function Convert is new Ada.Unchecked_Conversion
           (Glib.C_Proxy, Gdk_Event);
   begin
      return Convert (Glib.Values.Get_Proxy (Value));
   end Get_Event;

   function To_Event (Event : access Gdk_Event_Button) return Gdk_Event is
      type Gdk_Event_Button_Access is access all Gdk_Event_Button;
      function Convert is new Ada.Unchecked_Conversion
           (Gdk_Event_Button_Access, Gdk_Event);
   begin
      return Convert (Gdk_Event_Button_Access (Event));
   end To_Event;

   function To_Event (Event : access Gdk_Event_Key) return Gdk_Event is
      type Gdk_Event_Key_Access is access all Gdk_Event_Key;
      function Convert is new Ada.Unchecked_Conversion
         (Gdk_Event_Key_Access, Gdk_Event);
   begin
      return Convert (Gdk_Event_Key_Access (Event));
   end To_Event;
       </body>
     </extra>

     <doc group="Gdk, the low-level API"/>
     <parameter name="self" ada="Event"/>
   </package>

   <package id="GtkRadioToolButton">
     <method id="gtk_radio_tool_button_new">
       <parameter name="group" ctype="WidgetSList"/>
     </method>
     <method id="gtk_radio_tool_button_new_from_stock">
       <parameter name="group" ctype="WidgetSList"/>
     </method>
     <method id="gtk_radio_tool_button_set_group">
       <parameter name="group" ctype="WidgetSList"/>
     </method>
     <method id="gtk_radio_tool_button_get_group" return="WidgetSList"/>
     <method id="gtk_radio_tool_button_new_from_widget" bind="False"/> <!-- gir file misses Group parameter-->
     <method id="gtk_radio_tool_button_new_with_stock_from_widget" bind="False"/> <!-- gir file misses Group parameter-->
   </package>

   <package id="GtkSelectionData">
     <parameter name="self" ada="Selection"/>

     <method id="gtk_selection_data_targets_include_rich_text" bind="False"/> <!-- circular dependency on gtk.text_buffer -->
     <method id="gtk_selection_data_get_data_with_length" bind="False"/> <!-- not convenient, has an access gint and returns an array -->
     <method id="gtk_selection_data_set" bind="False"/> <!-- manual binding below -->
     <method id="gtk_selection_data_get_targets" bind="False"/> <!-- manual binding below -->

     <method id="gtk_selection_data_get_data" return="System.Address"/>

     <extra>
        <spec>
   ---------------
   -- Selection --
   ---------------

   function Make_Atom (Num : Gulong) return Gdk.Types.Gdk_Atom;
   pragma Import (C, Make_Atom, "ada_make_atom");
   --  Auxiliary subprogram

   subtype Gdk_Selection is Gdk.Types.Gdk_Atom;
   --  These are predefined atom values for several common selections.
   --  You are of course free to create new ones, but most of the time you
   --  should simply use Selection_Primary unless you foresee the need for
   --  multiple simultaneous selections.
   --  To access the clipboard on windows machines, you might need to create
   --  a new selection with Gdk.Property.Atom_Intern ("CLIPBOARD");

   Selection_Primary   : constant Gdk_Selection := Make_Atom (1);
   Selection_Secondary : constant Gdk_Selection := Make_Atom (2);

   procedure Selection_Data_Set
     (Selection : Gtk_Selection_Data;
      The_Type  : Gdk.Types.Gdk_Atom;
      Format    : Gint;
      Data      : System.Address;
      Length    : Gint);
   --  General form of Selection_Data_Set.
   --  Any data can be transmitted. Length is the number of bytes in Data.

   procedure Selection_Data_Set
     (Selection : Gtk_Selection_Data;
      The_Type  : Gdk.Types.Gdk_Atom;
      Format    : Gint;
      Data      : String);
   --  Set the data for a selection (special case for strings)
   --  This function is generally called when a drag-and-drop operation
   --  ask the source widget for the data to be transmitted. In that case,
   --  a Selection_Data was already transmitted and is given as a handler
   --  parameter for the signal "drag_data_get". The_Type can simply be
   --  extracted from the Selection_Data.

   function Get_Targets
     (Selection : Gtk_Selection_Data) return Gdk.Types.Gdk_Atom_Array;
   --  Gets the contents of Selection_Data as an array of targets.
   --  This can be used to interpret the results of getting
   --  the standard TARGETS target that is always supplied for
   --  any selection.
   --  This is different from Get_Target, which indicate the current format
   --  that the selection contains. Get_Targets only applies when Get_Target
   --  is "TARGETS".

   function Get_Data_As_String (Selection : Gtk_Selection_Data) return String;
   --  Return the data as a string.
   --  This is only a convenience function, since it simply creates a string
   --  from the return of Get_Data.
        </spec>

        <with_body pkg="Gtkada.C" />
        <body>
   package Atom_Arrays is new Gtkada.C.Unbounded_Arrays
     (Gdk.Types.Gdk_Atom, Gdk.Types.Gdk_None,
      Natural, Gdk.Types.Gdk_Atom_Array);

   ------------------------
   -- Selection_Data_Set --
   ------------------------

   procedure Selection_Data_Set
     (Selection : Gtk_Selection_Data;
      The_Type  : Gdk.Types.Gdk_Atom;
      Format    : Gint;
      Data      : System.Address;
      Length    : Gint)
   is
      procedure Internal
        (Selection : System.Address;
         The_Type  : Gdk.Types.Gdk_Atom;
         Format    : Gint;
         Data      : System.Address;
         Length    : Gint);
      pragma Import (C, Internal, "gtk_selection_data_set");

   begin
      Internal (Get_Object (Selection), The_Type, Format, Data, Length);
   end Selection_Data_Set;

   procedure Selection_Data_Set
     (Selection : Gtk_Selection_Data;
      The_Type  : Gdk.Types.Gdk_Atom;
      Format    : Gint;
      Data      : String) is
   begin
      Selection_Data_Set
        (Selection, The_Type, Format, Data'Address, Data'Length);
   end Selection_Data_Set;

   -----------------
   -- Get_Targets --
   -----------------

   function Get_Targets
     (Selection : Gtk_Selection_Data) return Gdk.Types.Gdk_Atom_Array
   is
      use Atom_Arrays;
      function Internal
        (Selection : System.Address;
         Targets   : access Unbounded_Array_Access;
         N_Atoms   : access Gint) return Gboolean;
      pragma Import (C, Internal, "gtk_selection_data_get_targets");

      Output    : aliased Unbounded_Array_Access;
      N         : aliased Gint;
   begin
      if Internal
         (Get_Object (Selection),
          Output'Unchecked_Access,
          N'Unchecked_Access) = 0
      then
         Output := null;
      end if;

      declare
         Result : constant Gdk_Atom_Array := To_Array (Output, Integer (N));
      begin
         G_Free (Output);
         return Result;
      end;
   end Get_Targets;

   ------------------------
   -- Get_Data_As_String --
   ------------------------

   function Get_Data_As_String
     (Selection : Gtk_Selection_Data) return String
   is
      function Internal
        (Selection : System.Address) return Gtkada.Types.Chars_Ptr;
      pragma Import (C, Internal, "gtk_selection_data_get_data");
   begin
      return Gtkada.Types.Value (Internal (Get_Object (Selection)));
   end Get_Data_As_String;
        </body>
     </extra>
   </package>


   <package id="GtkTargetEntry">
     <parameter name="self" ada="Target_Entry"/>

     <record ctype="GtkTargetEntry">
       <field name="flags" ctype="GtkTargetFlags"/>
     </record>

     <method id="gtk_target_entry_copy" bind="False"/> <!-- requires From_Object -->

     <method id="gtk_target_entry_new">
        <parameter name="Flags" ctype="GtkTargetFlags"/>
     </method>
   </package>

   <package id="GtkTargetList">
     <parameter name="self" ada="List"/>
     <enum ctype="GtkAccelFlags" prefix="GTK_"/>

     <method id="gtk_target_list_add_rich_text_targets" bind="False"/> <!-- circular dependency clipboard, text_buffer -->

     <method id="gtk_target_list_new" bind="False"/> <!-- manual binding below -->
     <method id="gtk_target_list_add_table" bind="False"/> <!-- manual binding below -->

     <method id="gtk_target_list_find"
         return_as_param="Found" />

     <extra>
       <with_spec pkg="Gtk.Target_Entry" />
       <spec>
   type Target_Entry_Array is array (Natural range &lt;&gt;) of Gtk_Target_Entry;

   No_Target_Entry : Target_Entry_Array (1 .. 0);
   --  To be used for drop sites that accept no data.
   --  You will in general need to call Gtk.Dnd.Add_Text_Targets or some such

   Any_Target_Entry : constant Target_Entry_Array := No_Target_Entry;
   pragma Obsolescent (Any_Target_Entry);
   --  Old name for this constant, which leads to confusion. You should use
   --  No_Target_Entry instead.

   procedure Gtk_New
      (List   : out Gtk_Target_List;
      Targets : Target_Entry_Array);
   --  Creates a new Gtk.Target_List.Gtk_Target_List from an array of
   --  Gtk.Target_Entry.Gtk_Target_Entry.

   procedure Add_Table
      (List    : Gtk_Target_List;
       Targets : Target_Entry_Array);
   --  Prepends a table of Gtk.Target_Entry.Gtk_Target_Entry to a target list.
       </spec>
       <body>
   -------------
   -- Gtk_New --
   -------------

   procedure Gtk_New
      (List   : out Gtk_Target_List;
       Targets : Target_Entry_Array)
   is
      function Internal
         (Targets  : System.Address;
          Ntargets : Guint) return System.Address;
      pragma Import (C, Internal, "gtk_target_list_new");
   begin
      List.Set_Object (Internal (Targets'Address, Targets'Length));
   end Gtk_New;

   ---------------
   -- Add_Table --
   ---------------

   procedure Add_Table
      (List    : Gtk_Target_List;
       Targets : Target_Entry_Array)
   is
      procedure Internal
         (List     : System.Address;
          Targets  : System.Address;
          Ntargets : Guint);
      pragma Import (C, Internal, "gtk_target_list_add_table");
   begin
      Internal (Get_Object (List), Targets'Address, Targets'Length);
   end Add_Table;
       </body>
     </extra>
   </package>

   <package id="GtkTooltip"/>

   <package id="GtkRadioMenuItem">
     <parameter name="self" ada="Radio_Menu_Item" />

     <!-- Merge two Gtk_New together -->
     <method id="gtk_radio_menu_item_new" bind="False"/>
     <method id="gtk_radio_menu_item_new_with_label" ada="Gtk_New" >
       <parameter name="label" default='""' allow-none="0"/>
       <parameter name="group" ctype="WidgetSList"/>
      </method>
     <method id="gtk_radio_menu_item_new_with_mnemonic" >
       <parameter name="group" ctype="WidgetSList"/>
      </method>
     <method id="gtk_radio_menu_item_set_group">
       <parameter name="group" ctype="WidgetSList"/>
     </method>
     <method id="gtk_radio_menu_item_get_group" return="WidgetSList"/>
     <method id="gtk_radio_menu_item_new_from_widget" bind="False"/> <!-- gir file misses Group parameter-->
     <method id="gtk_radio_menu_item_new_with_label_from_widget" bind="False"/> <!-- gir file misses Group parameter-->
     <method id="gtk_radio_menu_item_new_with_mnemonic_from_widget" bind="False"/> <!-- gir file misses Group parameter-->
     <extra>
       <spec>
   function Selected_Button (In_Group : Widget_SList.GSlist) return Natural;
   --  Return the button number of the selected button in the group.
   --  Note: This function is not part of Gtk+ itself, but is provided as a
   --  convenient function
       </spec>
       <body>
   function Selected_Button
     (In_Group : Widget_SList.GSlist) return Natural
   is
      use Widget_SList;
      J   : Natural := 0;
      Tmp : Widget_SList.GSlist := In_Group;
   begin
      while Tmp /= Widget_SList.Null_List loop
         exit when Get_Active (Gtk_Radio_Menu_Item (Get_Data (Tmp)));
         Tmp := Next (Tmp);
         J := J + 1;
      end loop;

      return J;
   end Selected_Button;
       </body>
     </extra>
   </package>

   <package id="GtkPrintContext">
     <parameter name="self" ada="Context"/>
   </package>

   <package id="PangoFontMetrics">
   </package>

   <package id="PangoFontset">
     <doc>an object containing a set of pango.Font objects</doc>
   </package>

   <package id="PangoLanguage">
     <enum ctype="PangoScript"/>

     <method id="pango_language_get_preferred" bind="False"/><!-- more recent than 1.44 -->

     <extra>
       <type ctype="Pango_Script_Array" ada="Pango_Script_Array">
         type Pango_Script_Array is array (Natural range &lt;&gt;) of Pango_Script;
       </type>
     </extra>

     <method id="pango_language_get_scripts" return="Pango_Script_Array">
       <parameter name="num_scripts" ada=""/>
       <body>
      type script_array_bounded is array (Natural) of Pango_Script;
      type script_array_access is access script_array_bounded;

      function Internal
         (Self     : System.Address;
          Size     : access Gint) return script_array_access;
      pragma Import (C, Internal, "pango_language_get_scripts");

      Scripts : script_array_access;
      Size : aliased Gint;
   begin
      Scripts := Internal (Self.Get_Object, Size'Access);

      declare
         Result : Pango_Script_Array (1 .. Integer (Size));
      begin
         for R in 0 .. Integer (Size) - 1 loop
             Result (R + 1) := Scripts (R);
         end loop;
         return Result;
      end;
       </body>
     </method>
   </package>

   <package id="PangoFontMap">
     <doc>An object that represents the set of fonts available for a particular
     rendering system</doc>

     <method id="pango_font_map_get_family" bind="False"/><!-- more recent than 1.44 -->

     <extra>
       <with_spec pkg="Pango.Font_Family"/>
     </extra>

     <method id="pango_font_map_list_families" return="Pango_Font_Family_Array">
       <parameter name="families" ada=""/>
       <parameter name="n_families" ada=""/>
       <body>
      type font_family_array_bounded is array (Natural) of System.Address;

      procedure Internal
         (Self     : System.Address;
          Families : System.Address;
          Size     : access Gint);
      pragma Import (C, Internal, "pango_font_map_list_families");

      procedure g_free (s : access font_family_array_bounded);
      pragma Import (C, g_free, "g_free");

      Families : aliased access font_family_array_bounded;
      Size : aliased Gint;
      Tmplt : Pango_Font_Family_Record;
   begin
      Internal (Self.Get_Object, Families'Address, Size'Access);

      declare
         Result : Pango_Font_Family_Array (1 .. Integer (Size));
      begin
         for R in 0 .. Integer (Size) - 1 loop
             Result (R + 1) := Pango_Font_Family
                (Get_User_Data (Families (R), Tmplt));
         end loop;
         g_free (Families);

         return Result;
      end;
       </body>
     </method>
   </package>

   <package id="PangoFontFamily">
     <extra>
       <with_spec pkg="Pango.Font_Face"/>

       <!--  Needed for PangoFontMap -->
       <type ctype="Pango_Font_Family_Array" ada="Pango_Font_Family_Array">
         type Pango_Font_Family_Array is array (Natural range &lt;&gt;) of Pango_Font_Family;
       </type>
     </extra>
     <method id="pango_font_family_get_face" bind="False"/><!-- more recent than 1.44 -->
     <method id="pango_font_family_list_faces" return="Pango_Font_Face_Array">
       <parameter name="faces" ada=""/>
       <parameter name="n_faces" ada=""/>
       <body>
      type font_face_array_bounded is array (Natural) of System.Address;

      procedure Internal
         (Self        : System.Address;
          Faces       : System.Address;
          Acc_N_Faces : access Gint);
      pragma Import (C, Internal, "pango_font_family_list_faces");

      procedure g_free (s : access font_face_array_bounded);
      pragma Import (C, g_free, "g_free");

      Faces : aliased access font_face_array_bounded;
      Size : aliased Gint;
      Tmplt : Pango_Font_Face_Record;
   begin
      Internal (Self.Get_Object, Faces'Address, Size'Access);

      declare
         Result : Pango_Font_Face_Array (1 .. Integer (Size));
      begin
         for R in 0 .. Integer (Size) - 1 loop
             Result (R + 1) := Pango_Font_Face
                (Get_User_Data (Faces (R), Tmplt));
         end loop;
         g_free (Faces);

         return Result;
      end;
       </body>
     </method>
   </package>

   <package id="PangoFontFace">
     <extra>
       <!--  Needed for PangoFontFamily -->
       <type ctype="Pango_Font_Face_Array" ada="Pango_Font_Face_Array">
         type Pango_Font_Face_Array is array (Natural range &lt;&gt;) of Pango_Font_Face;
       </type>
     </extra>
     <method id="pango_font_face_get_family" bind="False"/>  <!-- circular dependency -->
     <method id="pango_font_face_list_sizes" return="gint**">
       <parameter name="sizes" ada=""/>
       <parameter name="n_sizes" ada=""/>
       <body>
      type gint_array_bounded is array (Natural) of Gint;

      procedure Internal
         (Self        : System.Address;
          Sizes       : System.Address;
          Acc_N_Sizes : access Gint);
      pragma Import (C, Internal, "pango_font_face_list_sizes");

      procedure g_free (s : access gint_array_bounded);
      pragma Import (C, g_free, "g_free");

      Sizes : aliased access gint_array_bounded;
      Size : aliased Gint;
   begin
      Internal (Self.Get_Object, Sizes'Address, Size'Access);

      declare
         Result : Gint_Array (1 .. Integer (Size));
      begin
         for R in 0 .. Integer (Size) - 1 loop
             Result (R + 1) := Sizes (R);
         end loop;
         g_free (Sizes);

         return Result;
      end;
       </body>
     </method>
   </package>

   <package id="PangoLayout">
     <parameter name="self" ada="Layout"/>
     <enum ctype="PangoEllipsizeMode" prefix="PANGO_"/>
     <method id="pango_layout_xy_to_index" return_as_param="Exact">
       <parameter name="index" ada="Byte_Index" direction="out"/>
       <parameter name="trailing" direction="out"/>
     </method>

     <method id="pango_layout_get_direction" bind="False"/><!-- more recent than 1.44 -->

     <!-- Do not bind these, since they require a list of Pango_Layout_Line,
     which is incorrectly bound (error in From_Object) -->
     <method id="pango_layout_get_lines" return="PangoLayoutLineSList" bind="false"/>
     <method id="pango_layout_get_lines_readonly" bind="false"
             return="PangoLayoutLineSList"/>

     <method id="pango_layout_get_log_attrs" bind="false"/> <!--  what is a pango_log -->
     <method id="pango_layout_get_log_attrs_readonly" bind="false"/> <!--  what
     is a pango_log -->
     <method id="pango_layout_get_line_spacing" bind="False"/>
     <method id="pango_layout_set_line_spacing" bind="False"/>

     <method id="pango_layout_get_iter" classwide="true"/>

     <method id="pango_layout_set_attributes">
       <parameter name="attrs" direction="in" ctype="PangoAttrList"/>
     </method>

     <method id="pango_layout_set_text">
       <parameter name="length" default="-1" ada=""/>
     </method>
     <method id="pango_layout_set_markup">
       <parameter name="length" default="-1" ada=""/>
     </method>

     <extra>
       <with_spec pkg="Gtkada.Types" />
       <spec>
   function Get_Text (Layout : access Pango_Layout_Record)
      return Gtkada.Types.Chars_Ptr;
   --  Same a Get_Text, but return directly the C string, which is more
   --  efficient. The returned value should not be freed or modified.
       </spec>
       <body>
   function Get_Text (Layout : access Pango_Layout_Record)
      return Gtkada.Types.Chars_Ptr
   is
      function Internal (Layout : System.Address)
         return Gtkada.Types.Chars_Ptr;
      pragma Import (C, Internal, "pango_layout_get_text");
   begin
      return Internal (Get_Object (Layout));
   end Get_Text;
       </body>
     </extra>
   </package>

   <package id="PangoLayoutLine" into="PangoLayout">
     <record ctype="PangoLayoutLine" private="true"/>

     <method id="pango_layout_line_get_type" ada="Get_Type_Layout_Line" />

     <method id="pango_layout_line_get_extents" bind="false"/> <!--  forces bad pragma import on pango_layout_get_extents -->
     <method id="pango_layout_line_get_pixel_extents" bind="false"/>
     <method id="pango_layout_line_ref" bind="false"/> <!--  Not needed in Ada -->
     <method id="pango_layout_line_unref" bind="false"/> <!--  Not needed in Ada -->

     <!--  Do not bind these for now, there is an error in the generator that
     tries to use Get_Object on a PangoLayoutLine because it doesn't know
     private records are implemented as C_Proxy -->
     <method id="pango_layout_line_get_x_ranges" bind="false"/>
     <method id="pango_layout_line_index_to_x" bind="false"/>
     <method id="pango_layout_line_x_to_index" bind="false"/>
     <method id="pango_layout_line_get_height" bind="False"/>

   </package>

   <package id="PangoLayoutIter" into="PangoLayout">
     <method id="pango_layout_iter_get_type" ada="Get_Type_Layout_Iter" />

     <method id="pango_layout_iter_get_run" bind="false"/> <!--  what is a pango_run -->
     <method id="pango_layout_iter_get_run_readonly" bind="false"/> <!--  what is a pango_run -->
   </package>

   <package id="GtkPrintOperation">
     <enum ctype="GtkPrintStatus" prefix="GTK_PRINT_"/>
     <enum ctype="GtkPrintOperationResult" prefix="GTK_PRINT_OPERATION_"/>
     <enum ctype="GtkPrintOperationAction" prefix="GTK_PRINT_OPERATION_"/>
     <enum ctype="GtkPrintError" prefix="GTK_PRINT_"/>
   </package>

   <package id="GtkPrintOperationPreview">
     <parameter name="self" ada="Preview"/>
   </package>

   <package id="GtkAccelLabel">
     <parameter name="self" ada="Accel_Label"/>
   </package>

   <package id="GtkAccelMap">
     <method id="gtk_accel_map_load_scanner" bind="False"/> <!-- no binding for GScanner -->
     <method id="gtk_accel_map_add_entry">
       <parameter name="accel_key" ctype="GdkKeyType"/>
     </method>
     <method id="gtk_accel_map_change_entry">
       <parameter name="accel_key" ctype="GdkKeyType"/>
     </method>
     <method id="gtk_accel_map_lookup_entry" return_as_param="Found"/>
   </package>

   <package id="GtkActionGroup">
     <parameter name="self" ada="Action_Group"/>

     <list ada="Action_List" ctype="GtkAction"/>

     <method id="gtk_action_group_list_actions" return="GtkActionList"/>
     <method id="gtk_action_group_add_radio_actions" bind="False"/> <!-- see below -->
     <method id="gtk_action_group_add_radio_actions_full" bind="False"/> <!-- see below -->
     <method id="gtk_action_group_add_actions" bind="False"/> <!-- see below -->
     <method id="gtk_action_group_add_actions_full" bind="False"/> <!-- see below -->
     <method id="gtk_action_group_add_toggle_actions" bind="False"/> <!-- see below -->
     <method id="gtk_action_group_add_toggle_actions_full" bind="False"/> <!-- see below -->

     <extra>
       <with_spec pkg="Gtkada.Types" use="True" />
       <spec>
   type Action_Callback is access procedure
     (Action : System.Address; User_Data : System.Address);
   pragma Convention (C, Action_Callback);
   --  Profile of callbacks when an action is activated. You must convert
   --  Action to a Gtk_Action through:
   --      Act : constant Gtk_Action := Convert (Action);

   type Action_Entry is record
      Name         : Gtkada.Types.Chars_Ptr;
      Stock_Id     : Gtkada.Types.Chars_Ptr;
      Label        : Gtkada.Types.Chars_Ptr;
      Accelerator  : Gtkada.Types.Chars_Ptr;
      Tooltip      : Gtkada.Types.Chars_Ptr;
      Callback     : Action_Callback;
   end record;
   pragma Convention (C, Action_Entry);

   type Radio_Action_Entry is record
      Name         : Gtkada.Types.Chars_Ptr;
      Stock_Id     : Gtkada.Types.Chars_Ptr;
      Label        : Gtkada.Types.Chars_Ptr;
      Accelerator  : Gtkada.Types.Chars_Ptr;
      Tooltip      : Gtkada.Types.Chars_Ptr;
      Value        : Glib.Gint;
   end record;
   pragma Convention (C, Radio_Action_Entry);

   type Toggle_Action_Entry is record
      Name         : Gtkada.Types.Chars_Ptr;
      Stock_Id     : Gtkada.Types.Chars_Ptr;
      Label        : Gtkada.Types.Chars_Ptr;
      Accelerator  : Gtkada.Types.Chars_Ptr;
      Tooltip      : Gtkada.Types.Chars_Ptr;
      Callback     : Action_Callback;
      Is_Active    : Glib.Gboolean;
   end record;
   pragma Convention (C, Toggle_Action_Entry);
   --  An opaque structure describing an action entry

   type Action_Entry_Array is array (Natural range &lt;&gt;) of Action_Entry;
   type Radio_Action_Entry_Array
     is array (Natural range &lt;&gt;) of Radio_Action_Entry;
   type Toggle_Action_Entry_Array
     is array (Natural range &lt;&gt;) of Toggle_Action_Entry;

   type Radio_Action_Callback is access procedure
     (Group     : access Gtk.Action.Gtk_Action_Record'Class;
      Current   : access Gtk.Action.Gtk_Action_Record'Class;
      User_Data : System.Address);
   --   Called when an element of the Gtk_Radio_Action group is selected

   function Create
     (Name        : String;
      Label       : String := "";
      Stock_Id    : String := "";
      Accelerator : String := "";
      Tooltip     : String := "";
      Callback    : Action_Callback := null) return Action_Entry;
   --  Create a new Action_Entry. The returned value must be freed by the
   --  caller.

   function Create
     (Name        : String;
      Label       : String := "";
      Stock_Id    : String := "";
      Accelerator : String := "";
      Tooltip     : String := "";
      Callback    : Action_Callback := null;
      Is_Active   : Boolean := True) return Toggle_Action_Entry;
   --  Create a new Action_Entry. The returned value must be freed by the
   --  caller. Is_Active is the initial state of the button.

   function Create
     (Name        : String;
      Label       : String;
      Stock_Id    : String := "";
      Accelerator : String := "";
      Tooltip     : String := "";
      Value       : Glib.Gint) return Radio_Action_Entry;
   --  Create a new Radio_Action_Entry. Value is the value set on the radio
   --  action (see Gtk.Radio_Action.Get_Current_Value)

   procedure Free (Action  : in out Action_Entry);
   procedure Free (Actions : in out Action_Entry_Array);
   procedure Free (Action  : in out Radio_Action_Entry);
   procedure Free (Actions : in out Radio_Action_Entry_Array);
   procedure Free (Action  : in out Toggle_Action_Entry);
   procedure Free (Actions : in out Toggle_Action_Entry_Array);
   --  Free Action and Actions

   procedure Add_Actions
     (Action_Group : access Gtk_Action_Group_Record;
      Entries      : Action_Entry_Array;
      User_Data    : System.Address := System.Null_Address;
      Destroy      : Glib.G_Destroy_Notify_Address := null);
   --  This is a convenience function to create a number of actions and add
   --  them to the action group.
   --  Destroy is called when User_Data is no longer needed.
   --
   --  The "activate" signals of the actions are connected to the callbacks in
   --  Entries, and their accel paths are set to
   --  &lt;Actions&gt;/group-name/action-name.

   procedure Add_Radio_Actions
     (Action_Group : access Gtk_Action_Group_Record;
      Entries      : Radio_Action_Entry_Array;
      Value        : Glib.Gint;
      On_Change    : Radio_Action_Callback;
      User_Data    : System.Address := System.Null_Address;
      Destroy      : Glib.G_Destroy_Notify_Address := null);
   --  This is a convenience routine to create a group of radio actions and
   --  add them to the action group.
   --
   --  The "changed" signal of the first radio action is connected to the
   --  On_Change callback and the accel paths of the actions are set to
   --    &lt;Actions&gt;/group-name/action-name
   --
   --  Value is the value of the action to activate initially, or -1 if no
   --  action should be activated.
   --  Destroy is called when User_Data is no longer necessary.

   procedure Add_Toggle_Actions
     (Action_Group : access Gtk_Action_Group_Record;
      Entries      : Toggle_Action_Entry_Array;
      User_Data    : System.Address := System.Null_Address;
      Destroy      : Glib.G_Destroy_Notify_Address := null);
   --  This is a convenience function to create a number of toggle actions and
   --  add them to the action group.
   --  The "activate" signals of the actions are connected to the callbacks and
   --  their accel paths are set to &lt;Actions&gt;/group-name/action-name.
   --  Destroy is called when User_Data is no longer necessary.
       </spec>
       <with_body pkg="Ada.Unchecked_Deallocation" use="False" />
       <body>
   procedure Local_Radio_Action_Callback
     (Group, Current, User_Data : System.Address);
   pragma Convention (C, Local_Radio_Action_Callback);
   --  Local proxy for Radio_Action_Callback

   procedure Local_Radio_Action_Destroy
     (Data : in out System.Address);
   pragma Convention (C, Local_Radio_Action_Destroy);
   --  Local proxy for the Destroy notify for Radio_Action

   type Local_Radio_Action_User_Data is record
      Callback  : Radio_Action_Callback;
      User_Data : System.Address;
      Destroy   : G_Destroy_Notify_Address;
   end record;
   type Local_Radio_Action_User_Data_Access is
     access Local_Radio_Action_User_Data;

   function Convert is new Ada.Unchecked_Conversion
     (System.Address, Local_Radio_Action_User_Data_Access);
   function Convert is new Ada.Unchecked_Conversion
     (Local_Radio_Action_User_Data_Access, System.Address);
   procedure Unchecked_Free is new Ada.Unchecked_Deallocation
     (Local_Radio_Action_User_Data, Local_Radio_Action_User_Data_Access);

   procedure Local_Radio_Action_Callback
     (Group, Current, User_Data : System.Address)
   is
      Data : constant Local_Radio_Action_User_Data_Access :=
        Convert (User_Data);
      Stub : Gtk_Action_Record;
      G : constant Gtk_Action := Gtk_Action (Get_User_Data (Group, Stub));
      C : constant Gtk_Action := Gtk_Action (Get_User_Data (Current, Stub));
   begin
      Data.Callback (G, C, Data.User_Data);
   end Local_Radio_Action_Callback;

   procedure Local_Radio_Action_Destroy
     (Data : in out System.Address)
   is
      D : Local_Radio_Action_User_Data_Access := Convert (Data);
   begin
      D.Destroy (D.User_Data);
      Unchecked_Free (D);
   end Local_Radio_Action_Destroy;

   function Create
     (Name        : String;
      Label       : String := "";
      Stock_Id    : String := "";
      Accelerator : String := "";
      Tooltip     : String := "";
      Callback    : Action_Callback := null) return Action_Entry is
   begin
      return (Name        => String_Or_Null (Name),
              Label       => String_Or_Null (Label),
              Stock_Id    => String_Or_Null (Stock_Id),
              Accelerator => String_Or_Null (Accelerator),
              Tooltip     => String_Or_Null (Tooltip),
              Callback    => Callback);
   end Create;

   function Create
     (Name        : String;
      Label       : String := "";
      Stock_Id    : String := "";
      Accelerator : String := "";
      Tooltip     : String := "";
      Callback    : Action_Callback := null;
      Is_Active   : Boolean := True) return Toggle_Action_Entry is
   begin
      return (Name        => String_Or_Null (Name),
              Label       => String_Or_Null (Label),
              Stock_Id    => String_Or_Null (Stock_Id),
              Accelerator => String_Or_Null (Accelerator),
              Tooltip     => String_Or_Null (Tooltip),
              Callback    => Callback,
              Is_Active   => Boolean'Pos (Is_Active));
   end Create;

   function Create
     (Name        : String;
      Label       : String;
      Stock_Id    : String := "";
      Accelerator : String := "";
      Tooltip     : String := "";
      Value       : Glib.Gint) return Radio_Action_Entry is
   begin
      return (Name        => String_Or_Null (Name),
              Label       => String_Or_Null (Label),
              Stock_Id    => String_Or_Null (Stock_Id),
              Accelerator => String_Or_Null (Accelerator),
              Tooltip     => String_Or_Null (Tooltip),
              Value       => Value);
   end Create;

   procedure Free (Action  : in out Action_Entry) is
   begin
      g_free (Action.Name);
      g_free (Action.Label);
      g_free (Action.Stock_Id);
      g_free (Action.Accelerator);
      g_free (Action.Tooltip);
   end Free;

   procedure Free (Actions : in out Action_Entry_Array) is
   begin
      for A in Actions'Range loop
         Free (Actions (A));
      end loop;
   end Free;

   procedure Free (Action  : in out Radio_Action_Entry) is
   begin
      g_free (Action.Name);
      g_free (Action.Label);
      g_free (Action.Stock_Id);
      g_free (Action.Accelerator);
      g_free (Action.Tooltip);
   end Free;

   procedure Free (Actions : in out Radio_Action_Entry_Array) is
   begin
      for A in Actions'Range loop
         Free (Actions (A));
      end loop;
   end Free;

   procedure Free (Action  : in out Toggle_Action_Entry) is
   begin
      g_free (Action.Name);
      g_free (Action.Label);
      g_free (Action.Stock_Id);
      g_free (Action.Accelerator);
      g_free (Action.Tooltip);
   end Free;

   procedure Free (Actions : in out Toggle_Action_Entry_Array) is
   begin
      for A in Actions'Range loop
         Free (Actions (A));
      end loop;
   end Free;

   procedure Add_Actions
     (Action_Group : access Gtk_Action_Group_Record;
      Entries      : Action_Entry_Array;
      User_Data    : System.Address := System.Null_Address;
      Destroy      : Glib.G_Destroy_Notify_Address := null)
   is
      procedure Internal
        (Action_Group : System.Address;
         Entries      : System.Address;
         N_Entries    : Guint;
         User_Data    : System.Address;
         Destroy      : G_Destroy_Notify_Address);
      pragma Import (C, Internal, "gtk_action_group_add_actions_full");
   begin
      Internal (Get_Object (Action_Group),
                Entries (Entries'First)'Address,
                Entries'Length,
                User_Data, Destroy);
   end Add_Actions;

   procedure Add_Radio_Actions
     (Action_Group : access Gtk_Action_Group_Record;
      Entries      : Radio_Action_Entry_Array;
      Value        : Glib.Gint;
      On_Change    : Radio_Action_Callback;
      User_Data    : System.Address := System.Null_Address;
      Destroy      : Glib.G_Destroy_Notify_Address := null)
   is
      procedure Internal
        (Action_Group : System.Address;
         Entries      : System.Address;
         N_Entries    : Guint;
         Value        : Gint;
         On_Change    : System.Address;
         User_Data    : System.Address;
         Destroy      : System.Address);
      pragma Import (C, Internal, "gtk_action_group_add_radio_actions_full");
      Data : constant Local_Radio_Action_User_Data_Access :=
        new Local_Radio_Action_User_Data'
          (Callback  => On_Change,
           User_Data => User_Data,
           Destroy   => Destroy);
   begin
      Internal (Get_Object (Action_Group),
                Entries (Entries'First)'Address, Entries'Length,
                Value,
                Local_Radio_Action_Callback'Address,
                Convert (Data),
                Local_Radio_Action_Destroy'Address);
   end Add_Radio_Actions;

   procedure Add_Toggle_Actions
     (Action_Group : access Gtk_Action_Group_Record;
      Entries      : Toggle_Action_Entry_Array;
      User_Data    : System.Address := System.Null_Address;
      Destroy      : G_Destroy_Notify_Address := null)
   is
      procedure Internal
        (Action_Group : System.Address;
         Entries      : System.Address;
         N_Entries    : Guint;
         User_Data    : System.Address;
         Destroy      : G_Destroy_Notify_Address);
      pragma Import (C, Internal, "gtk_action_group_add_toggle_actions_full");
   begin
      Internal (Get_Object (Action_Group),
                Entries (Entries'First)'Address, Entries'Length, User_Data,
                Destroy);
   end Add_Toggle_Actions;
       </body>
     </extra>
   </package>

   <package id="GtkMessageDialog">
     <parameter name="self" ada="Dialog"/>
     <enum ctype="GtkMessageType" prefix="GTK_"/>
     <enum ctype="GtkButtonsType" prefix="GTK_"/>
     <method id="gtk_message_dialog_new">
       <parameter name="message_format" ada="message" default='""'/>
       <parameter name="varargs" ada="" ctype="gpointer" default="System.Null_Address"/>   <!--  remove varargs argument -->
     </method>
     <method id="gtk_message_dialog_new_with_markup">
       <parameter name="message_format" ada="message" default='""'/>
       <parameter name="varargs" ada="" ctype="gpointer" default="System.Null_Address"/>   <!--  remove varargs argument -->
     </method>
     <method id="gtk_message_dialog_format_secondary_markup">
       <parameter name="message_format" ada="message" default='""'/>
       <parameter name="varargs" ada="" ctype="gpointer" default="System.Null_Address"/>   <!--  remove varargs argument -->
     </method>
   </package>

   <package id="GtkPrintSettings">
     <method id="gtk_print_settings_set_page_ranges">
       <parameter name="page_ranges" type="Gtk_Page_Range_Array"/>
       <parameter name="num_ranges" ada="" default="-1" />
       <body>
      procedure Internal
        (Settings    : System.Address;
         Page_Ranges : System.Address;
         Num_Ranges  : Gint);
      pragma Import (C, Internal, "gtk_print_settings_set_page_ranges");
   begin
      Internal
        (Get_Object (Self),
         Page_Ranges (Page_Ranges'First)'Address,
         Page_Ranges'Length);
       </body>
     </method>
     <method id="gtk_print_settings_get_page_ranges" return="Gtk_Page_Range_Array">
       <parameter name="num_ranges" ada="" default="-1" />
       <body>
      type Internal_Page_Range_Array is
        array (Natural) of Gtk_Page_Range_Record;
      pragma Convention (C, Internal_Page_Range_Array);

      type Internal_Page_Range_Array_Access is
        access Internal_Page_Range_Array;
      pragma Convention (C, Internal_Page_Range_Array_Access);

      procedure Free (Item : in out Internal_Page_Range_Array_Access);
      pragma Import (C, Free, "g_free");

      function Internal
        (Settings   : System.Address;
         Num_Ranges : access Gint)
         return Internal_Page_Range_Array_Access;
      pragma Import (C, Internal, "gtk_print_settings_get_page_ranges");

      Len    : aliased Gint;
      Result : Internal_Page_Range_Array_Access;
   begin
      Result := Internal (Get_Object (Self), Len'Access);
      declare
         Ranges : constant Gtk_Page_Range_Array :=
           Gtk_Page_Range_Array (Result (0 .. Natural (Len)));
      begin
         Free (Result);
         return Ranges;
      end;
       </body>
     </method>
     <extra>
       <type ctype="GtkPageRange" ada="Gtk_Page_Range_Record">
   type Gtk_Page_Range_Record is record
      Range_Start : Gint;
      Range_End   : Gint;
   end record;
   pragma Convention (C, Gtk_Page_Range_Record);
   type Gtk_Page_Range_Array is array (Integer range &lt;&gt;) of Gtk_Page_Range_Record;
   pragma Convention (C, Gtk_Page_Range_Array);
   --  Page range specification(s).
       </type>
     </extra>
   </package>

   <package id="GtkBuilder">
     <parameter name="self" ada="Builder"/>
     <parameter name="error" direction="out" />
     <callback id="Gtk_Builder_Connect_Func">
        <parameter name="signal_name" ctype="SignalName"/>
     </callback>
     <method id="gtk_builder_add_from_string">
       <parameter name="length" default="-1" ada=""/>
     </method>
     <method id="gtk_builder_get_objects" return="ObjectSList" />
     <method id="gtk_builder_value_from_string" return_as_param="Success" />

     <method id="gtk_builder_set_application" bind="False"/> <!-- circular dep with GtkWidget -->
     <method id="gtk_builder_get_application" bind="False"/> <!-- circular dep with GtkWidget -->
     <method id="gtk_builder_extend_with_template" bind="False"/> <!-- circular dep with GtkWidget -->

     <method id="gtk_builder_add_callback_symbol" bind="False"/> <!-- error in generated binding -->
   </package>

   <package id="GtkUIManager">
     <enum ctype="GtkUIManagerItemType" prefix="GTK_UI_"
           ada="Manager_Item_Type"/>
     <method id="gtk_ui_manager_add_ui" ada="Add_UI">
       <parameter name="type" default="Manager_Auto"/>
       <parameter name="top" default="False"/>
     </method>
     <method id="gtk_ui_manager_remove_ui" ada="Remove_UI"/>
     <method id="gtk_ui_manager_add_ui_from_file" ada="Add_UI_From_File">
       <parameter name="error" direction="out"/>
     </method>
     <method id="gtk_ui_manager_add_ui_from_resource" ada="Add_UI_From_Resource">
       <parameter name="error" direction="out"/>
     </method>
     <method id="gtk_ui_manager_add_ui_from_string" ada="Add_UI_From_String">
       <parameter name="error" direction="out"/>
       <parameter name="length" ada="" default="-1"/>
     </method>
     <method id="gtk_ui_manager_get_action_groups" return="ObjectList"/>
     <method id="gtk_ui_manager_get_toplevels" return="WidgetSList"/>
   </package>

   <package id="GtkIconSet">
     <doc>
   An icon set represents a single icon in various sizes and widget states.
   It can provide a Gdk_Pixbuf for a given size and state on request, and
   automatically caches some of the rendered Gdk_Pixbuf objects.

   Normally you would use Gtk.Widget.Render_Icon instead of using icon sets
   directly. The one case where you'd use an icon set is to create
   application-specific icon sets to place in an icon factory.
     </doc>

     <extra>
       <spec>
   function Lookup_Icon_Set
      (Style    : access Gtk.Style_Context.Gtk_Style_Context_Record'Class;
       Stock_Id : String)
      return Gtk_Icon_Set;
   --  Retrieve an icon set by its name. The icon might exist in various sizes,
   --  that can be manipulated through the result set
       </spec>
       <body>
   function Lookup_Icon_Set
      (Style    : access Gtk.Style_Context.Gtk_Style_Context_Record'Class;
       Stock_Id : String)
      return Gtk_Icon_Set
   is
      function Internal
        (Style    : System.Address;
         Stock_Id : String)
         return System.Address;
      pragma Import (C, Internal, "gtk_style_context_lookup_icon_set");
   begin
      return From_Object (Internal (Get_Object (Style), Stock_Id &amp; ASCII.NUL));
   end Lookup_Icon_Set;
       </body>
     </extra>

     <method id="gtk_icon_set_get_sizes" return="Gint_Array">
       <parameter name="n_sizes" ada=""/>
       <parameter name="sizes" ada=""/>
       <body>
      type gint_array_bounded is array (Natural) of Gint;

      procedure Internal
         (Self        : System.Address;
          Sizes       : System.Address;
          Acc_N_Sizes : access Gint);
      pragma Import (C, Internal, "gtk_icon_set_get_sizes");

      procedure g_free (s : access gint_array_bounded);
      pragma Import (C, g_free, "g_free");

      Sizes : aliased access gint_array_bounded;
      Size : aliased Gint;
   begin
      Internal (Self.Get_Object, Sizes'Address, Size'Access);

      declare
         Result : Gint_Array (1 .. Integer (Size));
      begin
         for R in 0 .. Integer (Size) - 1 loop
             Result (R + 1) := Sizes (R);
         end loop;
         g_free (Sizes);

         return Result;
      end;
       </body>
     </method>
   </package>

   <package id="GtkIconSource">
     <doc>
An icon source contains a Gdk_Pixbuf (or image filename) that serves as
the base image for one or more of the icons in an icon set, along with a
specification for which icons in the icon set will be based on that
pixbuf or image file. An icon set contains a set of icons that represent
"the same" logical concept in different states, different global text
directions, and different sizes.

So for example a web browser's "Back to Previous Page" icon might point
in a different direction in Hebrew and in English; it might look
different when insensitive; and it might change size depending on
toolbar mode (small/large icons). So a single icon set would contain all
those variants of the icon. An icon set contains a list of icon sources
from which it can derive specific icon variants in the set.

In the simplest case, an icon set contains one source pixbuf from which
it derives all variants.

If you want to use a different base pixbuf for different icon variants,
you create multiple icon sources, mark which variants they'll be used to
create, and add them to the icon set with Add_Source (see below).

By default, the icon source has all parameters wildcarded. That is, the
icon source will be used as the base icon for any desired text
direction, widget state, or icon size.
     </doc>
   </package>

   <package id="GtkIconFactory">

     <function id="gtk_icon_size_lookup" return_as_param="Result" />
     <function id="gtk_icon_size_lookup_for_settings" return_as_param="Result" />
     <function id="gtk_icon_size_register" />
     <function id="gtk_icon_size_register_alias" />

     <extra>
       <with_spec pkg="Gtk.Style_Provider"/>
       <with_spec pkg="Gtk.Widget"/>
       <spec>
   function Get_Icon_Factory
      (Self : Gtk.Style_Provider.Gtk_Style_Provider;
       Path : Gtk.Widget.Gtk_Widget_Path)
       return Gtk_Icon_Factory;
   --  Returns the Gtk.Icon_Factory.Gtk_Icon_Factory defined to be in use for
   --  Path, or null if none is defined.
   --  Since: gtk+ 3.0
       </spec>
       <body>
   function Get_Icon_Factory
      (Self : Gtk_Style_Provider;
       Path : Gtk.Widget.Gtk_Widget_Path)
       return Gtk.Icon_Factory.Gtk_Icon_Factory
   is
      function Internal
         (Self : Gtk_Style_Provider;
          Path : Gtk.Widget.Gtk_Widget_Path) return System.Address;
      pragma Import (C, Internal, "gtk_style_provider_get_icon_factory");
      Stub_Gtk_Icon_Factory : Gtk.Icon_Factory.Gtk_Icon_Factory_Record;
   begin
      return Gtk.Icon_Factory.Gtk_Icon_Factory (Get_User_Data (Internal (Self, Path), Stub_Gtk_Icon_Factory));
   end Get_Icon_Factory;
       </body>
     </extra>
   </package>

   <package id="GtkIconTheme">
     <parameter name="self" ada="Icon_Theme" />
     <enum ctype="GtkIconLookupFlags" prefix="GTK_"/>
     <method id="gtk_icon_theme_lookup_by_gicon" classwide="true" />
     <method id="gtk_icon_theme_lookup_icon" classwide="true" />
     <method id="gtk_icon_theme_choose_icon" classwide="true" />
     <method id="gtk_icon_theme_set_search_path">
       <parameter name="n_elements" ada="" default="Path'Length"/>
     </method>
     <method id="gtk_icon_theme_get_search_path" return="GNAT.Strings.String_List">
       <parameter name="path" ada=""/>
       <parameter name="n_elements" ada=""/>
       <body>
      procedure Internal
        (Icon_Theme : System.Address;
         Path       : out chars_ptr_array_access;
         N_Elements : out Gint);
      pragma Import (C, Internal, "gtk_icon_theme_get_search_path");

      P : chars_ptr_array_access;
      N : Gint;
   begin
      Internal (Get_Object (Icon_Theme), P, N);
      declare
         Result : constant GNAT.Strings.String_List :=
           To_String_List (P.all, N);
      begin
         Free (P.all);
         return Result;
      end;
       </body>
     </method>
     <method id="gtk_icon_theme_get_icon_sizes">
       <body>
      use Gint_Arrays;
      function Internal
        (Icon_Theme : System.Address;
         Icon_Name  : String) return Unbounded_Array_Access;
      pragma Import (C, Internal, "gtk_icon_theme_get_icon_sizes");

      Res    : constant Unbounded_Array_Access := Internal
        (Get_Object (Icon_Theme), Icon_Name &amp; ASCII.NUL);
      Result : constant Gint_Array := To_Gint_Array_Zero_Terminated (Res);
   begin
      G_Free (Res);
      return Result;
       </body>
     </method>
     <method id="gtk_icon_theme_list_icons" return="StringList"/>
     <method id="gtk_icon_theme_list_contexts" return="StringList"/>
     <extra>
       <with_body pkg="Gtkada.Bindings"/>
     </extra>
   </package>

   <package id="GtkIconInfo" into="GtkIconTheme">
     <parameter name="self" ada="Icon_Info" />
     <method id="gtk_icon_info_get_type" ada="Icon_Info_Get_Type"/>
     <method id="gtk_icon_info_load_icon_async" bind="False"/> <!-- requires GAsync -->
     <method id="gtk_icon_info_load_symbolic_async" bind="False"/> <!-- requires GAsync -->
     <method id="gtk_icon_info_load_icon_finish" bind="False"/> <!-- requires GAsync -->
     <method id="gtk_icon_info_load_symbolic_finish" bind="False"/> <!-- requires GAsync -->
     <method id="gtk_icon_info_load_symbolic_for_context_async" bind="False"/> <!-- requires GAsync -->
     <method id="gtk_icon_info_load_symbolic_for_context_finish" bind="False"/> <!-- requires GAsync -->
     <method id="gtk_icon_info_get_embedded_rect" return_as_param="Has_Embedded_Rectangle"/>
     <method id="gtk_icon_info_get_attach_points" return="Gdk.Types.Gdk_Points_Array">
       <parameter name="n_points" ada=""/>
       <parameter name="points" ada=""/>
       <body>
      use Points_Arrays;
      function Internal
        (Icon_Info : System.Address;
         Result    : access Unbounded_Array_Access;
         N_Points  : access Gint) return Gboolean;
      pragma Import (C, Internal, "gtk_icon_info_get_attach_points");

      R : aliased Unbounded_Array_Access;
      N : aliased Gint;
   begin
      if Internal (Icon_Info.Get_Object, R'Unchecked_Access,
                   N'Unchecked_Access) = 0
      then
         R := null;
      end if;

      declare
         Result : constant Gdk_Points_Array := To_Array (R, Integer (N));
      begin
         G_Free (R);
         return Result;
      end;
       </body>
     </method>
     <extra>
       <with_body pkg="Gtkada.C"/>
       <body>
   package Points_Arrays is new Gtkada.C.Unbounded_Arrays
     (Gdk.Types.Gdk_Point, (0, 0), Positive, Gdk.Types.Gdk_Points_Array);
       </body>
     </extra>
   </package>

   <package id="GtkSettings">
     <method id="gtk_settings_install_property_parser" bind="False"/> <!-- not needed in Ada -->
     <method id="gtk_settings_set_property_value" bind="False"/> <!-- see below -->
     <extra>
       <spec>
   procedure Set_Property_Value
     (Settings : not null access Gtk_Settings_Record;
      Name     : String;
      Value    : GValue;
      Origin   : String);

   function Get_Settings
     (Widget   : not null access Gtk_Widget_Record'Class)
     return Gtk_Settings;
   --  Get the settings object holding the settings used for this widget.
   --
   --  Note that this function can only be called when the widget is
   --  attached to a toplevel, since the settings object is specific to a
   --  particular Gdk.Screen.Gdk_Screen.
       </spec>
       <body>
   function Get_Settings
     (Widget   : not null access Gtk_Widget_Record'Class)
     return Gtk_Settings
   is
      function Internal (W : System.Address) return System.Address;
      pragma Import (C, Internal, "gtk_widget_get_settings");
      Stub : Gtk_Settings_Record;
   begin
      return Gtk_Settings (Get_User_Data (Internal (Get_Object (Widget)), Stub));
   end Get_Settings;

   procedure Set_Property_Value
     (Settings : not null access Gtk_Settings_Record;
      Name     : String;
      Value    : GValue;
      Origin   : String)
   is
      type Property_Value is record
         Origin : Gtkada.Types.Chars_Ptr;
         Value  : GValue;
      end record;
      pragma Convention (C, Property_Value);

      procedure Internal
        (Settings : System.Address;
         Name     : String;
         Svalue   : System.Address);
      pragma Import (C, Internal, "gtk_settings_set_property_value");

      Val : aliased Property_Value :=
        (Origin => New_String (Origin),
         Value  => Value);
   begin
      Internal (Get_Object (Settings), Name &amp; ASCII.NUL, Val'Address);
      g_free (Val.Origin);
   end Set_Property_Value;
       </body>
     </extra>
   </package>

   <package id="GtkBorder" into="GtkStyle">
     <record ctype="GtkBorder"/>
     <method id="gtk_border_copy" bind="False" />  <!-- not needed in Ada -->
     <method id="gtk_border_free" bind="False" />  <!-- not needed in Ada -->
     <method id="gtk_border_get_type" ada="Border_Get_Type"/>
   </package>

   <package id="GtkStockItem" ada="Gtk.Stock">
     <record ctype="GtkStockItem" private="True"/>
     <constant prefix_regexp="GTK_STOCK_.*" prefix="GTK_"/>
     <function id="gtk_stock_add" ada="Add">
       <parameter name="items" type="Gtk_Stock_Item_Array"/>
       <parameter name="n_items" ada="" default="Items'Length"/>
     </function>
     <function id="gtk_stock_add_static" ada="Add_Static">
       <parameter name="items" type="Gtk_Stock_Item_Array"/>
       <parameter name="n_items" ada="" default="Items'Length"/>
     </function>
     <function id="gtk_stock_lookup" ada="Lookup" return_as_param="Success"/>
     <method id="gtk_stock_item_free" bind="False" /> <!-- see below -->
     <extra>
       <type ada="Gtk_Stock_Item_Array" ctype="GtkStockItemArray">
   type Gtk_Stock_Item_Array is array (Natural range &lt;&gt;) of Gtk_Stock_Item;
       </type>
       <spec>
   procedure Gtk_New
     (Item               : out Gtk_Stock_Item;
      Stock_Id           : String;
      Label              : UTF8_String;
      Modifier           : Gdk.Types.Gdk_Modifier_Type;
      Keyval             : Gdk.Types.Gdk_Key_Type;
      Translation_Domain : String);
   --  Create a new stock item.

   procedure Free (Item : in out Gtk_Stock_Item);
   --  Free memory allocated in Item.

   procedure Add (Item : Gtk_Stock_Item);
   --  Register Item.
   --  If an item already exists with the same stock ID as one of the items,
   --  the old item gets replaced. The stock item is copied, so GtkAda does
   --  not hold any pointer into item and item can be freed. Use
   --  Add_Static if item is persistent and GtkAda need not copy the array.
       </spec>
       <body>
   procedure Gtk_New
     (Item               : out Gtk_Stock_Item;
      Stock_Id           : String;
      Label              : UTF8_String;
      Modifier           : Gdk.Types.Gdk_Modifier_Type;
      Keyval             : Gdk.Types.Gdk_Key_Type;
      Translation_Domain : String) is
   begin
      Item.Stock_Id           := Gtkada.Types.New_String (Stock_Id);
      Item.Label              := Gtkada.Types.New_String (Label);
      Item.Modifier           := Modifier;
      Item.Keyval             := Guint (Keyval);
      Item.Translation_Domain := Gtkada.Types.New_String (Translation_Domain);
   end Gtk_New;

   procedure Free (Item : in out Gtk_Stock_Item) is
   begin
      Gtkada.Types.g_free (Item.Stock_Id);
      Gtkada.Types.g_free (Item.Label);
      Gtkada.Types.g_free (Item.Translation_Domain);
   end Free;

   ---------
   -- Add --
   ---------

   procedure Add (Item : Gtk_Stock_Item) is
      procedure Internal (Item : Gtk_Stock_Item; N_Items : Guint := 1);
      pragma Import (C, Internal, "gtk_stock_add");

   begin
      Internal (Item);
   end Add;
       </body>
     </extra>
   </package>

   <package id="GtkTextIter">
     <parameter name="self" ada="Iter"/>
     <record ctype="GtkTextIter" private="True"/>
     <enum ctype="GtkTextSearchFlags" prefix="GTK_TEXT_SEARCH_"/>

     <method id="gtk_text_iter_get_buffer" bind="False"/> <!-- circular dependency -->
     <method id="gtk_text_iter_get_child_anchor" bind="False"/> <!-- circular dependency -->
     <method id="gtk_text_iter_copy" bind="False"/> <!-- manual binding below -->
     <method id="gtk_text_iter_get_marks" return="ObjectSList" />
     <method id="gtk_text_iter_get_tags" return="TextTagList" />
     <method id="gtk_text_iter_get_toggled_tags" return="TextTagList" />

     <method id="gtk_text_iter_forward_char" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_chars" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_char" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_chars" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_word_end" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_word_ends" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_visible_word_end" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_visible_word_ends" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_word_start" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_word_starts" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_visible_word_start" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_visible_word_starts" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_sentence_end" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_sentence_ends" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_sentence_start" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_sentence_starts" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>

     <method id="gtk_text_iter_set_offset">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_set_line">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_set_line_offset">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_set_line_index">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_set_visible_line_offset">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_set_visible_line_index">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>

     <method id="gtk_text_iter_forward_line" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_lines" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_visible_line" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_visible_lines" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_to_line_end" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>

     <method id="gtk_text_iter_backward_line" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_lines" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_visible_line" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_visible_lines" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>

     <method id="gtk_text_iter_forward_to_end">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>

     <method id="gtk_text_iter_forward_to_tag_toggle" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
       <parameter name="tag" default="null"/>
     </method>
     <method id="gtk_text_iter_backward_to_tag_toggle" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
       <parameter name="tag" default="null"/>
     </method>

     <method id="gtk_text_iter_forward_cursor_position" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_cursor_positions" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_cursor_position" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_cursor_positions" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_visible_cursor_position" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_visible_cursor_positions" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_visible_cursor_position" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_visible_cursor_positions" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>

     <method id="gtk_text_iter_forward_search" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
       <parameter name="limit" default="Null_Text_Iter"/>
     </method>
     <method id="gtk_text_iter_backward_search" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
       <parameter name="limit" default="Null_Text_Iter"/>
     </method>
     <method id="gtk_text_iter_forward_find_char" return_as_param="Result"
             bind="false"> <!--  Need func with callback and return_as_param -->
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_find_char" return_as_param="Result"
             bind="false"> <!--  Need func with callback and return_as_param -->
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <extra>
        <with_spec pkg="Glib.Values"/>
        <with_spec pkg="Gtkada.Types"/>
        <with_body pkg="Ada.Unchecked_Conversion" use="False"/>
        <with_body pkg="System.Address_To_Access_Conversions" use="False"/>
        <type>
   Null_Text_Iter : constant Gtk_Text_Iter;
        </type>
        <spec private="True">
   Null_Text_Iter : constant Gtk_Text_Iter :=
     (System.Null_Address, System.Null_Address, 0, 0, 0, 0, 0, 0,
      System.Null_Address, System.Null_Address, 0, 0, 0,
      System.Null_Address);
        </spec>
        <spec>
   procedure Copy (Source : Gtk_Text_Iter; Dest : out Gtk_Text_Iter);
   pragma Inline (Copy);
   --  Create a copy of Source.

   function Get_Char (Iter : Gtk_Text_Iter) return Character;
   --  Return the character immediately following Iter. If Iter is at the
   --  end of the buffer, then return ASCII.NUL.
   --  Note that this function assumes that the text is encoded in ASCII
   --  format. If this is not the case, use the Get_Char function that
   --  returns a Gunichar instead.

   function Iter_Or_Null (Iter : System.Address) return System.Address;
   --  Internal function for GtkAda

   -------------------------------
   -- Converting to/from GValue --
   -------------------------------

   procedure Set_Text_Iter
     (Val  : in out Glib.Values.GValue;
      Iter : Gtk_Text_Iter);
   pragma Import (C, Set_Text_Iter, "g_value_set_pointer");
   --  Set the value of the given GValue to Iter.
   --  Note that Iter is stored by reference, which means no copy of Iter
   --  is made. Iter should remain allocated as long as Val is being used.

   procedure Get_Text_Iter
     (Val  : Glib.Values.GValue;
      Iter : out Gtk_Text_Iter);
   --  Extract the iterator from the given GValue.
   --  Note that the iterator returned is a copy of the iterator referenced
   --  by the give GValue. Modifying the iterator returned does not modify
   --  the iterator referenced by the GValue.

   function Get_Slice
     (Start   : Gtk_Text_Iter;
      The_End : Gtk_Text_Iter) return Gtkada.Types.Chars_Ptr;
   --  Same as Get_Slice above, but returns the raw C string.
   --  The caller is responsible for freeing the string returned,
   --  using Gtkada.Types.g_free.

        </spec>
        <body>

   type Gtk_Text_Iter_Access is access Gtk_Text_Iter;
   function Convert is new Ada.Unchecked_Conversion
     (System.Address, Gtk_Text_Iter_Access);
   use type System.Address;

   ------------------
   -- Iter_Or_Null --
   ------------------

   function Iter_Or_Null (Iter : System.Address) return System.Address is
   begin
      if Convert (Iter).all = Null_Text_Iter then--  null iter
         return System.Null_Address;
      else
         return Iter;
      end if;
   end Iter_Or_Null;

   ----------
   -- Copy --
   ----------

   procedure Copy (Source : Gtk_Text_Iter; Dest : out Gtk_Text_Iter) is
   begin
      Dest := Source;
   end Copy;

   --------------
   -- Get_Char --
   --------------

   function Get_Char (Iter : Gtk_Text_Iter) return Character is
      Result         : constant Gunichar := Get_Char (Iter);
      Eight_LSB_Mask : constant := 2#1111_1111#;

   begin
      --  This function relies on the Get_Char function provided by gtk+,
      --  which returns a gunichar value. Only the 8 least significant bits
      --  are then kept to deduce the associated character.

      return Character'Val (Result and Eight_LSB_Mask);
   end Get_Char;

   -------------------
   -- Get_Text_Iter --
   -------------------

   package Iter_Access_Address_Conversions is
     new System.Address_To_Access_Conversions (Gtk_Text_Iter);

   procedure Get_Text_Iter
     (Val  : Glib.Values.GValue;
      Iter : out Gtk_Text_Iter) is
   begin
      Copy
        (Source => Iter_Access_Address_Conversions.To_Pointer
                     (Glib.Values.Get_Address (Val)).all,
         Dest   => Iter);
   end Get_Text_Iter;

   ---------------
   -- Get_Slice --
   ---------------

   function Get_Slice
     (Start   : Gtk_Text_Iter;
      The_End : Gtk_Text_Iter) return Gtkada.Types.Chars_Ptr
   is
      function Internal
        (Start   : Gtk_Text_Iter;
         The_End : Gtk_Text_Iter) return Gtkada.Types.Chars_Ptr;
      pragma Import (C, Internal, "gtk_text_iter_get_slice");

   begin
      return Internal (Start, The_End);
   end Get_Slice;
        </body>
     </extra>
   </package>

   <package id="GIcon" ada="Glib.G_Icon">
     <virtual-method id='*' bind='False'/>
     <method id="g_icon_hash">
       <parameter name="icon" type="G_Icon"/>
     </method>
   </package>

   <package id="GtkToolPalette">
     <enum ctype="GtkDestDefaults"/>
     <enum ctype="GtkToolPaletteDragTargets"/>
     <method id="gtk_tool_palette_get_hadjustment" bind="False"/> <!-- obsolete, use interface-->
     <method id="gtk_tool_palette_get_vadjustment" bind="False"/> <!-- obsolete, use interface-->
   </package>

   <package id="PangoFont">
     <parameter name="self" ada="Font" />

     <method id="pango_font_get_type" ada="Font_Get_Type"/>
     <method id="pango_font_find_shaper" bind="False"/> <!--  internal implementation of gtk -->
     <method id="pango_font_describe" classwide="True"/>
     <method id="pango_font_describe_with_absolute_size" classwide="True"/>
     <method id="pango_font_descriptions_free" bind="False"/> <!-- in Ada, need iteration -->
     <method id="pango_font_get_coverage" bind="False"/> <!-- circular dependency -->
     <method id="pango_font_get_font_map" bind="False"/> <!-- circular dependency -->
     <method id="pango_font_get_face" bind="False"/> <!-- circular dependency -->
     <method id="pango_font_get_features" bind="False"/> <!-- Harfbuzz required -->
     <method id="pango_font_get_hb_font" bind="False"/> <!-- Harfbuzz required -->
     <method id="pango_font_get_metrics">
       <parameter name="language" default="Pango.Language.Null_Pango_Language"/>
     </method>
   </package>

   <package id="PangoMatrix">
     <record ctype="PangoMatrix"/>
     <method id="pango_matrix_rotate">
       <parameter name="self" direction="inout"/>
     </method>
     <method id="pango_matrix_scale">
       <parameter name="self" direction="inout"/>
     </method>
     <method id="pango_matrix_translate">
       <parameter name="self" direction="inout"/>
     </method>
   </package>

   <package id="PangoCoverage">
     <method id="pango_coverage_from_bytes" bind="False"/>  <!-- not used for Ada -->
     <method id="pango_coverage_to_bytes" bind="False"/>  <!-- not used for Ada -->
   </package>

   <package id="PangoTabArray" ada="Pango.Tabs">
     <enum ctype="PangoTabAlign"/>
     <method id="pango_tab_array_get_tabs" bind="False"/> <!-- Require manual binding -->
   </package>

   <package id="PangoAttribute" ada="Pango.Attributes">
     <slist ada="Pango_Attribute_SList" ctype="PangoAttribute"/>
     <method id="pango_attribute_init" bind="False"/> <!--  low-level -->
     <method id="pango_attribute_get_type" ada="Get_Type_Attribute"/>

     <function id="pango_attr_underline_new"/>
     <function id="pango_attr_background_new"/>
     <function id="pango_attr_foreground_new"/>
     <function id="pango_attr_family_new"/>
     <function id="pango_attr_strikethrough_new"/>
     <function id="pango_attr_variant_new"/>
     <function id="pango_attr_weight_new"/>
     <function id="pango_attr_stretch_new"/>
     <function id="pango_attr_scale_new"/>
     <function id="pango_attr_rise_new"/>
     <function id="pango_attr_gravity_new"/>
   </package>

   <package id="PangoAttrList" into="PangoAttribute">
     <method id="pango_attr_list_get_iterator" bind="False"/>  <!-- Not needed ? -->
     <method id="pango_attr_list_get_type" ada="Get_Type_Attr_List"/>
     <method id="pango_attr_list_get_attributes" bind="False"/>
     <method id="pango_attr_list_equal" bind="False"/><!-- more recent than 1.44 -->
   </package>

   <package id="PangoContext">
     <method id="pango_context_get_font_map" bind="False" /> <!-- circular dep -->
     <method id="pango_context_set_font_map" bind="False" /> <!-- circular dep -->
     <extra>
       <with_spec pkg="Pango.Font_Family"/>
     </extra>
     <method id="pango_context_list_families" return="Pango_Font_Family_Array">
       <parameter name="families" ada=""/>
       <parameter name="n_families" ada=""/>
       <body>
      type font_family_array_bounded is array (Natural) of System.Address;

      procedure Internal
         (Self     : System.Address;
          Families : System.Address;
          Size     : access Gint);
      pragma Import (C, Internal, "pango_context_list_families");

      procedure g_free (s : access font_family_array_bounded);
      pragma Import (C, g_free, "g_free");

      Families : aliased access font_family_array_bounded;
      Size : aliased Gint;
      Tmplt : Pango_Font_Family_Record;
   begin
      Internal (Get_Object (Self), Families'Address, Size'Access);

      declare
         Result : Pango_Font_Family_Array (1 .. Integer (Size));
      begin
         for R in 0 .. Integer (Size) - 1 loop
             Result (R + 1) := Pango_Font_Family
                (Get_User_Data (Families (R), Tmplt));
         end loop;
         g_free (Families);

         return Result;
      end;
       </body>
     </method>
   </package>

   <package id="PangoFontDescription" into="PangoFont">
     <method id="pango_font_description_free" bind="False" /> <!--  manual binding below -->
     <extra>
       <with_spec pkg="Glib.Generic_Properties"/>
       <spec>
   function To_Font_Description
     (Family_Name : String := "";
      Style       : Pango.Enums.Style := Pango.Enums.Pango_Style_Normal;
      Variant     : Pango.Enums.Variant := Pango.Enums.Pango_Variant_Normal;
      Weight      : Pango.Enums.Weight := Pango.Enums.Pango_Weight_Normal;
      Stretch     : Pango.Enums.Stretch := Pango.Enums.Pango_Stretch_Normal;
      Size        : Gint := 0) return Pango_Font_Description;
   --  Create a new font decription from the given parameters.

   function Get_Style_As_String
     (Self : Pango_Font_Description) return String;
   -- Return the font's style as a string (e.g: 'Oblique').

   function Get_Weight_As_String
     (Self : Pango_Font_Description) return String;
   -- Return the font's style as a string (e.g: 'Oblique').

   function To_Address
     (F : Pango_Font_Description; Add : System.Address) return System.Address;
   package Desc_Properties is new Generic_Internal_Boxed_Property
     (Pango_Font_Description, Get_Type, To_Address);
   type Property_Font_Description is new Desc_Properties.Property;

   procedure Free (Desc : in out Pango_Font_Description);
   --  Deallocate the given font description.
       </spec>
       <body>
   subtype String7 is String (1 .. 7);
   Style_Map : constant array (Enums.Style) of String7 :=
     (Enums.Pango_Style_Normal  =&gt; "       ",
      Enums.Pango_Style_Oblique =&gt; "Oblique",
      Enums.Pango_Style_Italic  =&gt; "Italic ");

   subtype String10 is String (1 .. 10);
   Variant_Map : constant array (Enums.Variant) of String10 :=
     (Enums.Pango_Variant_Normal     =&gt; "          ",
      Enums.Pango_Variant_Small_Caps =&gt; "Small-Caps");

   subtype String15 is String (1 .. 15);
   Stretch_Map : constant array (Enums.Stretch) of String15 :=
     (Enums.Pango_Stretch_Ultra_Condensed =&gt; "Ultra-Condensed",
      Enums.Pango_Stretch_Extra_Condensed =&gt; "Extra-Condensed",
      Enums.Pango_Stretch_Condensed       =&gt; "Condensed      ",
      Enums.Pango_Stretch_Semi_Condensed  =&gt; "Semi-Condensed ",
      Enums.Pango_Stretch_Normal          =&gt; "               ",
      Enums.Pango_Stretch_Semi_Expanded   =&gt; "Semi-Expanded  ",
      Enums.Pango_Stretch_Expanded        =&gt; "Expanded       ",
      Enums.Pango_Stretch_Extra_Expanded  =&gt; "Extra-Expanded ",
      Enums.Pango_Stretch_Ultra_Expanded  =&gt; "Ultra-Expanded ");

   --  Some of the values are not directly supported by pango.
   --  ??? See fonts.c in pango

   Weight_Map : constant array (Enums.Weight) of String10 :=
     (Enums.Pango_Weight_Ultralight  =&gt; "Light     ",
      Enums.Pango_Weight_Thin        =&gt; "Thin      ",
      Enums.Pango_Weight_Light       =&gt; "Light     ",
      Enums.Pango_Weight_Normal      =&gt; "          ",
      Enums.Pango_Weight_Book        =&gt; "Book      ",
      Enums.Pango_Weight_Medium      =&gt; "Medium    ",
      Enums.Pango_Weight_Semibold    =&gt; "Semi-Bold ",
      Enums.Pango_Weight_Bold        =&gt; "Bold      ",
      Enums.Pango_Weight_Semilight   =&gt; "Semi-Light",
      Enums.Pango_Weight_Ultrabold   =&gt; "Bold      ",
      Enums.Pango_Weight_Ultraheavy  =&gt; "Ultraheavy",
      Enums.Pango_Weight_Heavy       =&gt; "Heavy     ");

   function To_Font_Description
     (Family_Name : String := "";
      Style       : Enums.Style := Enums.Pango_Style_Normal;
      Variant     : Enums.Variant := Enums.Pango_Variant_Normal;
      Weight      : Enums.Weight := Enums.Pango_Weight_Normal;
      Stretch     : Enums.Stretch := Enums.Pango_Stretch_Normal;
      Size        : Gint := 0) return Pango_Font_Description
   is
   begin
      return From_String (Family_Name &amp; " " &amp;
                     Style_Map (Style) &amp; " " &amp;
                     Variant_Map (Variant) &amp;
                     Weight_Map (Weight) &amp; " " &amp;
                     Stretch_Map (Stretch) &amp; Gint'Image (Size));
   end To_Font_Description;

   function Get_Style_As_String
      (Self : Pango_Font_Description) return String
   is
      Style : constant Pango.Enums.Style := Get_Style (Self);
   begin
      if Style = Pango.Enums.Pango_Style_Normal then
         return "Normal";
      else
         return Style_Map (Style);
      end if;
   end Get_Style_As_String;

   function Get_Weight_As_String
      (Self : Pango_Font_Description) return String
   is
      Weight : constant Pango.Enums.Weight := Get_Weight (Self);
   begin
      if Weight = Pango.Enums.Pango_Weight_Normal then
         return "Normal";
      else
         return Weight_Map (Weight);
      end if;
   end Get_Weight_As_String;

   function To_Address
      (F : Pango_Font_Description; Add : System.Address)
      return System.Address
   is
      pragma Unreferenced (Add);
   begin
      return F.all'Address;
   end To_Address;

   ----------
   -- Free --
   ----------

   procedure Free (Desc : in out Pango_Font_Description) is
      procedure Internal (Desc : Pango_Font_Description);
      pragma Import (C, Internal, "pango_font_description_free");

   begin
      Internal (Desc);
      Desc := null;
   end Free;
       </body>
     </extra>
   </package>

   <package id="GtkCellView">
     <parameter name="self" ada="Cell_View"/>
   </package>

   <package id="GtkTreeView">
     <parameter name="self" ada="Tree_View"/>
     <enum ctype="GtkTreeViewDropPosition" />
     <method id="gtk_tree_view_get_columns" return="GtkTreeViewColumnList"/>

     <method id="gtk_tree_view_new_with_model" ada="Gtk_New" />
     <method id="gtk_tree_view_insert_column">
       <parameter name="position" default="-1"/>
     </method>
     <method id="gtk_tree_view_get_path_at_pos" return_as_param="Row_Found"/>
     <method id="gtk_tree_view_get_visible_range" return_as_param="Success"/>
     <method id="gtk_tree_view_get_tooltip_context" return_as_param="Success"/>
     <method id="gtk_tree_view_set_expander_column">
        <parameter name="column" allow-none="1"/>
     </method>

     <method id="gtk_tree_view_get_hadjustment" bind="False" /> <!-- from scrollable -->
     <method id="gtk_tree_view_get_vadjustment" bind="False" /> <!-- from scrollable -->
     <method id="gtk_tree_view_set_hadjustment" bind="False" /> <!-- from scrollable -->
     <method id="gtk_tree_view_set_vadjustment" bind="False" /> <!-- from scrollable -->

     <method id="gtk_tree_view_enable_model_drag_source">
       <parameter name="targets" ctype="Gtk.Target_List.Target_Entry_Array"/>
       <parameter name="n_targets" ada="" default="Targets'Length" />
     </method>
     <method id="gtk_tree_view_enable_model_drag_dest">
       <parameter name="targets" ctype="Gtk.Target_List.Target_Entry_Array"/>
       <parameter name="n_targets" ada="" default="Targets'Length" />
     </method>

     <extra>
       <spec>
   procedure Gtk_New
      (Tree_View : out Gtk_Tree_View;
       Model     : access Gtk.Tree_Model.Gtk_Root_Tree_Model_Record'Class);
   --  A convenience function so that one can directly pass a model, without
   --  converting to a Gtk_Tree_Model via the "+" operator.
       </spec>
       <body>
   procedure Gtk_New
      (Tree_View : out Gtk_Tree_View;
       Model     : access Gtk.Tree_Model.Gtk_Root_Tree_Model_Record'Class)
   is
   begin
      Gtk_New (Tree_View, To_Interface (Model));
   end Gtk_New;
       </body>
     </extra>
   </package>

   <package id="GtkTreeViewColumn">
     <parameter name="self" ada="Tree_Column"/>
     <enum ctype="GtkTreeViewColumnSizing"/>
     <list ctype="GtkTreeViewColumn" ada="Column_List" />
     <method id="gtk_tree_view_column_cell_get_position" return_as_param="Success"/>

     <method id="gtk_tree_view_column_add_attribute" bind="False" /> <!-- overridden -->
     <method id="gtk_tree_view_column_clear" bind="False" /> <!-- from cell_layout -->
     <method id="gtk_tree_view_column_clear_attributes" bind="False" /> <!-- from cell_layout -->
     <method id="gtk_tree_view_column_pack_start" bind="False" /> <!-- from cell_layout -->
     <method id="gtk_tree_view_column_pack_end" bind="False" /> <!-- from cell_layout -->
     <method id="gtk_tree_view_column_set_cell_data_func" bind="False" /> <!-- from cell_layout -->
   </package>

   <package id="GtkTreeSortable">
     <parameter name="self" ada="Sortable"/>
     <method id="gtk_tree_sortable_get_sort_column_id" return="void"/>
     <extra>
       <spec>
   Default_Sort_Column_Id  : constant Gint := -1;
   Unsorted_Sort_Column_Id : constant Gint := -2;
   --  Two special values for the sort column
       </spec>
     </extra>
   </package>

   <package id="GtkTreeDragSource">
     <function id="gtk_tree_set_row_drag_data" ada="Set_Row_Drag_Data"/>
     <function id="gtk_tree_get_row_drag_data" ada="Get_Row_Drag_Data" return_as_param="Success"/>
   </package>

   <package id="GtkTreeModel">
     <parameter name="self" ada="Tree_Model"/>
     <enum ctype="GtkTreeModelFlags" ada="Tree_Model_Flags" />
     <method id="gtk_tree_model_get" bind="False"/> <!-- varargs -->
     <method id="gtk_tree_model_get_valist" bind="False"/> <!-- varargs -->
     <method id="gtk_tree_model_get_iter" return="Gtk_Tree_Iter">
       <parameter name="iter" ada=""/>
       <body>
      function Internal
        (Tree_Model : Gtk_Tree_Model;
         Iter : System.Address; Path : System.Address) return Gint;
      pragma Import (C, Internal, "gtk_tree_model_get_iter");
      Iter : aliased Gtk_Tree_Iter;
   begin
      if Internal (+Tree_Model, Iter'Address, Get_Object (Path)) /= 0 then
         return Iter;
      else
         return Null_Iter;
      end if;
       </body>
     </method>
     <method id="gtk_tree_model_get_iter_from_string" return="Gtk_Tree_Iter">
       <parameter name="iter" ada=""/>
       <body>
      function Internal
        (Tree_Model : Gtk_Tree_Model;
         Iter : System.Address; Str : String) return Gint;
      pragma Import (C, Internal, "gtk_tree_model_get_iter_from_string");
      Iter : aliased Gtk_Tree_Iter;
   begin
      if Internal
        (+Tree_Model, Iter'Address, Path_String &amp; ASCII.NUL) /= 0
      then
         return Iter;
      else
         return Null_Iter;
      end if;
       </body>
     </method>
     <method id="gtk_tree_model_get_iter_first" return="Gtk_Tree_Iter">
       <parameter name="iter" ada=""/>
       <body>
      function Internal
         (Tree_Model : Gtk_Tree_Model; Iter : System.Address) return Gint;
      pragma Import (C, Internal, "gtk_tree_model_get_iter_first");
      Iter : aliased Gtk_Tree_Iter;
   begin
      if Internal (+Tree_Model, Iter'Address) /= 0 then
         return Iter;
      else
         return Null_Iter;
      end if;
       </body>
     </method>
     <method id="gtk_tree_model_iter_next" ada="Next" return="void">
       <parameter name="iter" direction="inout"/>
       <body>
      function Internal
         (Tree_Model : Gtk_Tree_Model; Iter : System.Address) return Gint;
      pragma Import (C, Internal, "gtk_tree_model_iter_next");
      Local_Iter : aliased Gtk_Tree_Iter := Iter;
   begin
      if Internal (+Tree_Model, Local_Iter'Address) = 0 then
         Iter := Null_Iter;
      else
         Iter := Local_Iter;
      end if;
       </body>
     </method>
     <method id="gtk_tree_model_iter_previous" ada="Previous" return="void">
       <parameter name="iter" direction="inout"/>
       <body>
      function Internal
         (Tree_Model : Gtk_Tree_Model; Iter : System.Address) return Gint;
      pragma Import (C, Internal, "gtk_tree_model_iter_previous");
      Local_Iter : aliased Gtk_Tree_Iter := Iter;
   begin
      if Internal (+Tree_Model, Local_Iter'Address) = 0 then
         Iter := Null_Iter;
      else
         Iter := Local_Iter;
      end if;
       </body>
     </method>
     <method id="gtk_tree_model_iter_children" ada="Children" return="Gtk_Tree_Iter">
       <parameter name="iter" ada=""/>
       <body>
      function Internal
        (Tree_Model : Gtk_Tree_Model;
         Iter       : System.Address;
         Parent     : System.Address) return Gint;
      pragma Import (C, Internal, "gtk_tree_model_iter_children");
      It : aliased Gtk_Tree_Iter;
   begin
      if Internal (+Tree_Model, It'Address, Iter_Or_Null (Parent'Address)) /= 0 then
         return It;
      else
         return Null_Iter;
      end if;
       </body>
     </method>
     <method id="gtk_tree_model_iter_has_child" ada="Has_Child"/>
     <method id="gtk_tree_model_iter_n_children" ada="N_Children">
       <parameter name="iter" default="Gtk.Tree_Model.Null_Iter"/>
       <body>
      function Internal
          (Tree_Model : Gtk_Tree_Model; Iter : System.Address) return Gint;
      pragma Import (C, Internal, "gtk_tree_model_iter_n_children");
   begin
      return Internal (+Tree_Model, Iter_Or_Null (Iter'Address));
       </body>
     </method>
     <method id="gtk_tree_model_iter_nth_child" ada="Nth_Child" return="Gtk_Tree_Iter">
       <parameter name="iter" ada=""/>
       <body>
      function Internal
        (Tree_Model : Gtk_Tree_Model;
         Iter, Parent : System.Address; N : Gint) return Gint;
      pragma Import (C, Internal, "gtk_tree_model_iter_nth_child");
      Iter : aliased Gtk_Tree_Iter;
   begin
      if Internal (+Tree_Model, Iter'Address, Iter_Or_Null (Parent'Address), N) /= 0 then
         return Iter;
      else
         return Null_Iter;
      end if;
       </body>
     </method>
     <method id="gtk_tree_model_iter_parent" ada="Parent" return="Gtk_Tree_Iter">
       <parameter name="iter" ada=""/>
       <body>
      function Internal
        (Tree_Model : Gtk_Tree_Model;
         Iter       : System.Address;
         Child      : Gtk_Tree_Iter) return Gint;
      pragma Import (C, Internal, "gtk_tree_model_iter_parent");
      Iter : aliased Gtk_Tree_Iter;
   begin
      if Internal (+Tree_Model, Iter'Address, Child) /= 0 then
         return Iter;
      else
         return Null_Iter;
      end if;
       </body>
     </method>
     <method id="gtk_tree_model_rows_reordered">
       <parameter name="new_order" type="Gint_Array"/>
     </method>
     <extra>
       <spec>
   type Gtk_Root_Tree_Model_Record is new Glib.Object.GObject_Record
      with null record;
   type Gtk_Root_Tree_Model is
      access all Gtk_Root_Tree_Model_Record'Class;
   --  A common base type for all objects that implement GtkTreeModel. This
   --  is used to conveniently provide a number of primitive operations.

   function Get_Int
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Gint;
   function Get_Ulong
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Gulong;
   function Get_Boolean
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Boolean;
   function Get_Object
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Glib.Object.GObject;
   function Get_C_Proxy
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Glib.C_Proxy;
   function Get_String
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return UTF8_String;
   function Get_Address
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return System.Address;
   --  Get the value of one cell of the model

   function Get_Int
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Gint;
   function Get_Ulong
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Gulong;
   function Get_Boolean
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Boolean;
   function Get_Object
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Glib.Object.GObject;
   function Get_C_Proxy
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Glib.C_Proxy;
   function Get_String
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return UTF8_String;
   function Get_Address
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return System.Address;

   package Implements_Gtk_Tree_Model is new Glib.Types.Implements
     (Gtk_Tree_Model, Gtk_Root_Tree_Model_Record, Gtk_Root_Tree_Model);
   function To_Interface
     (Widget : access Gtk_Root_Tree_Model_Record'Class)
     return Gtk_Tree_Model renames Implements_Gtk_Tree_Model.To_Interface;
   function "-"
     (Interf : Gtk_Tree_Model) return Gtk_Root_Tree_Model
     renames Implements_Gtk_Tree_Model.To_Object;
   --  Convert from the gtk+ interface to an actual object. The return type
   --  depends on the exact model, and will likely be an instance of
   --  Gtk_Tree_Store'Class or Gtk_List_Store'Class depending on how you
   --  created it.
       </spec>
       <body>
   function Get_Int
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Gint is
   begin
     return Get_Int (To_Interface (Tree_Model), Iter, Column);
   end Get_Int;

   function Get_Int
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Gint
   is
      procedure Internal
        (Tree_Model : Gtk_Tree_Model;
         Iter       : Gtk_Tree_Iter;
         Column     : Gint;
         Value      : out Gint);
      pragma Import (C, Internal, "ada_gtk_tree_model_get");
      A : Gint;
   begin
      if Iter = Null_Iter then
         raise Program_Error with "Get_Int with null_iter";
      end if;
      Internal (Tree_Model, Iter, Column, A);
      return A;
   end Get_Int;

   function Get_Ulong
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Gulong is
   begin
     return Get_Ulong (To_Interface (Tree_Model), Iter, Column);
   end Get_Ulong;

   function Get_Ulong
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Gulong
   is
      procedure Internal
        (Tree_Model : Gtk_Tree_Model;
         Iter       : Gtk_Tree_Iter;
         Column     : Gint;
         Value      : out Gulong);
      pragma Import (C, Internal, "ada_gtk_tree_model_get");
      A : Gulong;
   begin
      if Iter = Null_Iter then
         raise Program_Error with "Get_Ulong with null_iter";
      end if;
      Internal (Tree_Model, Iter, Column, A);
      return A;
   end Get_Ulong;

   function Get_Boolean
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Boolean is
   begin
      return Get_Boolean (To_Interface (Tree_Model), Iter, Column);
   end Get_Boolean;

   function Get_Boolean
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Boolean is
   begin
      return Get_Int (Tree_Model, Iter, Column) /= 0;
   end Get_Boolean;

   function Get_Object
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Glib.Object.GObject
   is
   begin
      return Get_Object (To_Interface (Tree_Model), Iter, Column);
   end Get_Object;

   function Get_Object
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Glib.Object.GObject
   is
      Stub : Glib.Object.GObject_Record;
   begin
      return Get_User_Data
         (Get_Address (Tree_Model, Iter, Column), Stub);
   end Get_Object;

   function Get_C_Proxy
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Glib.C_Proxy is
   begin
      return Get_C_Proxy (To_Interface (Tree_Model), Iter, Column);
   end Get_C_Proxy;

   function Get_C_Proxy
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Glib.C_Proxy
   is
      procedure Internal
        (Tree_Model : Gtk_Tree_Model;
         Iter       : Gtk_Tree_Iter;
         Column     : Gint;
         Value      : out Glib.C_Proxy);
      pragma Import (C, Internal, "ada_gtk_tree_model_get");
      A : Glib.C_Proxy;
   begin
      if Iter = Null_Iter then
         raise Program_Error with "Get_C_Proxy with null_iter";
      end if;
      Internal (Tree_Model, Iter, Column, A);
      return A;
   end Get_C_Proxy;

   function Get_String
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return UTF8_String
   is
   begin
      return Get_String (To_Interface (Tree_Model), Iter, Column);
   end Get_String;

   function Get_String
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return UTF8_String
   is
      procedure Internal
        (Tree_Model : Gtk_Tree_Model;
         Iter       : Gtk_Tree_Iter;
         Column     : Gint;
         Value      : out Gtkada.Types.Chars_Ptr);
      pragma Import (C, Internal, "ada_gtk_tree_model_get");
      A : Gtkada.Types.Chars_Ptr;
   begin
      if Iter = Null_Iter then
         raise Program_Error with "Get_String with null_iter";
      end if;
      Internal (Tree_Model, Iter, Column, A);
      if A = Gtkada.Types.Null_Ptr then
         return "";
      else
         declare
            S : constant String := Gtkada.Types.Value (A);

            procedure C_Free (S : Gtkada.Types.Chars_Ptr);
            pragma Import (C, C_Free, "free");

         begin
            --  Since A was allocated by gtk+ via malloc(), and not via
            --  System.Memory, we should not be using Gtkada.Types.g_free
            --  which goes through System.Memory. So we call free() directly
            --  instead.
            C_Free (A);
            return S;
         end;
      end if;
   end Get_String;

   function Get_Address
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return System.Address
   is
   begin
      return Get_Address (To_Interface (Tree_Model), Iter, Column);
   end Get_Address;

   function Get_Address
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return System.Address
   is
      procedure Internal
        (Tree_Model : Gtk_Tree_Model;
         Iter       : Gtk_Tree_Iter;
         Column     : Gint;
         Value      : out System.Address);
      pragma Import (C, Internal, "ada_gtk_tree_model_get");
      A : System.Address;
   begin
      if Iter = Null_Iter then
         raise Program_Error with "Get_Address with null_iter";
      end if;
      Internal (Tree_Model, Iter, Column, A);
      return A;
   end Get_Address;
       </body>
     </extra>
   </package>

   <package id="GtkTreeIter" into="GtkTreeModel">
     <record ctype="GtkTreeIter" private="True"/>
     <method id="gtk_tree_iter_get_type" ada="Iter_Get_Type" />
     <method id="gtk_tree_iter_copy" ada="Iter_Copy" />
     <extra>
       <type>
   Null_Iter : constant Gtk_Tree_Iter;
       </type>
       <spec>
   function "=" (Left : Gtk_Tree_Iter; Right : Gtk_Tree_Iter) return Boolean;

   procedure Set_Tree_Iter
     (Val  : in out Glib.Values.GValue;
      Iter : Gtk_Tree_Iter);
   pragma Import (C, Set_Tree_Iter, "g_value_set_pointer");
   --  Set the value of the given GValue to Iter.
   --  Note that Iter is stored by reference, which means no copy of Iter
   --  is made. Iter should remain allocated as long as Val is being used.

   procedure Get_Tree_Iter
     (Val  : Glib.Values.GValue;
      Iter : out Gtk_Tree_Iter);
   --  Extract the iterator from the given GValue.
   --  Note that the iterator returned is a copy of the iterator referenced
   --  by the give GValue. Modifying the iterator returned does not modify
   --  the iterator referenced by the GValue.

   function Get_Tree_Iter (Val : Glib.Values.GValue) return Gtk_Tree_Iter;
   --  Extract the iterator from the given GValue.

   function To_Address (Iter : Gtk_Tree_Iter) return System.Address;
   pragma Convention (C, To_Address);
   --  Return address of the specified iterator.
   --  Note: To_Address needs a pass-by-reference semantic to work properly
   --  On some ABIs (e.g. IA64), Gtk_Tree_Iter is passed by copy, since it's
   --  a "small enough" record.

   function Iter_Or_Null (Iter : System.Address) return System.Address;
   --  Internal function for GtkAda
       </spec>
       <spec private="True">
   Null_Iter : constant Gtk_Tree_Iter :=
     (0, System.Null_Address, System.Null_Address, System.Null_Address);
       </spec>
       <body>
   function "=" (Left : Gtk_Tree_Iter; Right : Gtk_Tree_Iter) return Boolean is
      use type System.Address;
   begin
      if Left.Stamp = Right.Stamp then
         if Left.Stamp = 0 then
            --  Stamp = 0 means the iterator is null iterator, we need not to
            --  compare other fields in this case.
            return True;
         else
            return Left.User_Data = Right.User_Data
                     and then Left.User_Data2 = Right.User_Data2
                     and then Left.User_Data3 = Right.User_Data3;
         end if;
      else
         return False;
      end if;
   end "=";

   type Gtk_Tree_Iter_Access is access Gtk_Tree_Iter;
   function Convert is new Ada.Unchecked_Conversion
      (System.Address, Gtk_Tree_Iter_Access);
   use type System.Address;

   function Iter_Or_Null (Iter : System.Address) return System.Address is
   begin
      if Convert (Iter).Stamp = 0 then   --  null iter
         return System.Null_Address;
      else
         return Iter;
      end if;
   end Iter_Or_Null;

   procedure Get_Tree_Iter
     (Val  : Glib.Values.GValue;
      Iter : out Gtk_Tree_Iter) is
   begin
      Iter := Convert (Glib.Values.Get_Address (Val)).all;
   end Get_Tree_Iter;

   function Get_Tree_Iter (Val : Glib.Values.GValue) return Gtk_Tree_Iter is
      Result : Gtk_Tree_Iter;
   begin
      Get_Tree_Iter (Val, Result);
      return Result;
   end Get_Tree_Iter;

   function To_Address (Iter : Gtk_Tree_Iter) return System.Address is
   begin
      return Iter'Address;
   end To_Address;
       </body>
     </extra>
   </package>

   <package id="GtkTreeRowReference">
     <parameter name="self" ada="Reference"/>
   </package>

   <package id="GtkTreePath" into="GtkTreeModel">
     <parameter name="self" ada="Path" />
     <list ctype="GtkTreePath" ada="Gtk_Tree_Path_List" section="Lists"/>
     <method id="gtk_tree_path_new_from_string" ada="Gtk_New">
       <parameter name="self" ada="Self" />
     </method>
     <method id="gtk_tree_path_get_type" ada="Path_Get_Type" />
     <method id="gtk_tree_path_free" ada="Path_Free" />
     <method id="gtk_tree_path_get_indices_with_depth" bind="False"/> <!-- duplicates Get_Indices, in Ada -->
     <method id="gtk_tree_path_get_indices" return="Glib.Gint_Array">
       <body>
      Depth : constant Integer := Integer (Get_Depth (Path));

      subtype Result_Array is Gint_Array (0 .. Depth - 1);
      type Result_Array_Access is access all Result_Array;
      pragma Convention (C, Result_Array_Access);

      function Internal (Path : System.Address) return Result_Array_Access;
      pragma Import (C, Internal, "gtk_tree_path_get_indices");

      --  Do not free the result of gtk_tree_path_get_indices since this is
      --  not a copy, but the currently used data.
      Result : constant Result_Array_Access := Internal (Get_Object (Path));

   begin
      if Result = null then
         return (0 .. -1 => 0);
      else
         return Result.all;
      end if;
       </body>
     </method>
     <extra>
       <spec>
   function Get_Tree_Path (Val : Glib.Values.GValue) return Gtk_Tree_Path;
   --  Extract the path from the given GValue.

       </spec>
       <with_body pkg="Glib.Values"/>
       <body>
   function Get_Tree_Path (Val : Glib.Values.GValue) return Gtk_Tree_Path is
   begin
      return From_Object (Glib.Values.Get_Address (Val));
   end Get_Tree_Path;
       </body>
     </extra>
   </package>

   <package id="GtkTreeModelSort" parent="Gtk.Tree_Model.Gtk_Root_Tree_Model">
     <method id="gtk_tree_model_sort_new_with_model" ada="Gtk_New_With_Model"/>
   </package>

   <package id="GtkTreeModelFilter" parent="Gtk.Tree_Model.Gtk_Root_Tree_Model">
     <method id="gtk_tree_model_filter_new" ada="Gtk_New">
       <parameter name="root" default="Null_Gtk_Tree_Path" />
     </method>
     <method id="gtk_tree_model_filter_convert_child_iter_to_iter" return="void" />
     <method id="gtk_tree_model_filter_set_modify_func"> <!-- function with callback and custom parameter -->
       <parameter name="types" type="Glib.GType_Array"/>
       <parameter name="n_columns" ada="" default="Types'Length" />
     </method>
   </package>

   <package id="GtkTreeSelection">
     <parameter name="self" ada="Selection" />
     <method id="gtk_tree_selection_get_selected" return="void">
        <body>
      function Internal
        (Selection : System.Address;
         Model     : access Gtk_Tree_Model;
         Iter      : access Gtk_Tree_Iter) return Gboolean;
      pragma Import (C, Internal, "gtk_tree_selection_get_selected");
      M  : aliased Gtk_Tree_Model := Null_Gtk_Tree_Model;
      It : aliased Gtk_Tree_Iter;
   begin
      if Internal (Get_Object (Selection), M'Access, It'Access) = 0 then
         Iter  := Null_Iter;
      else
         Iter  := It;
      end if;
      Model := M;
        </body>
     </method>
     <method id="gtk_tree_selection_get_selected_rows" bind="False"/><!-- see below -->
     <method id="gtk_tree_selection_get_tree_view" return="Gtk_Widget"/> <!-- avoid circular dep -->
     <extra>
       <spec>
   procedure Get_Selected_Rows
     (Selection : access Gtk_Tree_Selection_Record;
      Model     : out Gtk.Tree_Model.Gtk_Tree_Model;
      Path_List : out Gtk.Tree_Model.Gtk_Tree_Path_List.Glist);
   --  Creates a list of path of all selected rows. Additionally, if you are
   --  planning on modifying the model after calling this function, you may
   --  want to convert the returned list into a list of Gtk_Tree_Row_Reference.
   --
   --  You must free the resulting list by calling Path_Free on each item, and
   --  then freeing the list itself.
       </spec>
       <body>
   procedure Get_Selected_Rows
     (Selection : access Gtk_Tree_Selection_Record;
      Model     : out Gtk_Tree_Model;
      Path_List : out Gtk_Tree_Path_List.Glist)
   is
      use type System.Address;
      function Internal
        (Selection : System.Address;
         Model     : access Gtk_Tree_Model) return System.Address;
      pragma Import (C, Internal, "gtk_tree_selection_get_selected_rows");
      M        : aliased Gtk_Tree_Model;
      Selected : System.Address;  --  list of paths
   begin
      Selected := Internal (Get_Object (Selection), M'Access);
      Model := M;
      if Selected = System.Null_Address then
         Path_List := Gtk_Tree_Path_List.Null_List;
      else
         Gtk_Tree_Path_List.Set_Object (Path_List, Selected);
      end if;
   end Get_Selected_Rows;
       </body>
     </extra>
   </package>

   <package id="GtkListStore" parent="Gtk.Tree_Model.Gtk_Root_Tree_Model">
     <parameter name="self" ada="List_Store" />
     <method id="gtk_list_store_newv" ada="Gtk_New">
       <parameter name="types" type="GType_Array"/>
       <parameter name="n_columns" ada="" default="Types'Length"/>
     </method>
     <method id="gtk_list_store_set_column_types">
       <parameter name="types" type="GType_Array"/>
       <parameter name="n_columns" ada="" default="Types'Length"/>
     </method>
     <method id="gtk_list_store_insert_with_valuesv" bind="False"/> <!-- valist -->
     <method id="gtk_list_store_set_value">
       <parameter name="value" ctype="GValue" />
     </method>
     <method id="gtk_list_store_set_valist" bind="False"/> <!-- valist -->
     <method id="gtk_list_store_set_valuesv" bind="False"/> <!-- manually -->
     <method id="gtk_list_store_remove" return="void">
       <parameter name="iter" direction="inout"/>
       <body>%(auto)s
Iter := Gtk.Tree_Model.Null_Iter;
       </body>
     </method>
     <extra>
       <with_spec pkg="Gdk.Pixbuf" />
       <spec>
   procedure Set
     (Tree_Store : access Gtk_List_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : UTF8_String);
   procedure Set
     (Tree_Store : access Gtk_List_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Boolean);
   procedure Set
     (Tree_Store : access Gtk_List_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Gint);
   procedure Set
     (Tree_Store : access Gtk_List_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Gdk.Pixbuf.Gdk_Pixbuf);

   procedure Set
     (Self       : not null access Gtk_List_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Columns    : Glib.Gint_Array;
      Values     : Glib.Values.GValue_Array);
   pragma Precondition (Columns'Length = Values'Length);
   --  A variant of Set which takes the columns and valus as two arrays.
   --  This is more efficient when changing multiple values than calling
   --  one of the Set procedures above multiple times.

   procedure Set
     (Self       : not null access Gtk_List_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Values     : Glib.Values.GValue_Array);
   --  A variant of the above that is used to set all the columns.

       </spec>
       <body>
   procedure Set
     (Tree_Store : access Gtk_List_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : UTF8_String)
   is
      procedure Internal
        (Tree_Store : System.Address;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint;
         Value      : UTF8_String);
      pragma Import (C, Internal, "ada_gtk_list_store_set_ptr");
   begin
      Internal (Get_Object (Tree_Store), Iter, Column, Value &amp; ASCII.NUL);
   end Set;

   procedure Set
     (Tree_Store : access Gtk_List_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Gint)
   is
      procedure Internal
        (Tree_Store : System.Address;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint;
         Value      : Gint);
      pragma Import (C, Internal, "ada_gtk_list_store_set_int");
   begin
      Internal (Get_Object (Tree_Store), Iter, Column, Value);
   end Set;

   procedure Set
     (Tree_Store : access Gtk_List_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Boolean)
   is
      procedure Internal
        (Tree_Store : System.Address;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint;
         Value      : Gboolean);
      pragma Import (C, Internal, "ada_gtk_list_store_set_int");
   begin
      Internal (Get_Object (Tree_Store), Iter, Column, Boolean'Pos (Value));
   end Set;

   procedure Set
     (Tree_Store : access Gtk_List_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Gdk.Pixbuf.Gdk_Pixbuf)
   is
      procedure Internal
        (Tree_Store : System.Address;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint;
         Value      : System.Address);
      pragma Import (C, Internal, "ada_gtk_list_store_set_ptr");
   begin
      Internal (Get_Object (Tree_Store), Iter, Column, Get_Object (Value));
   end Set;

   procedure Set
     (Self       : not null access Gtk_List_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Columns    : Glib.Gint_Array;
      Values     : Glib.Values.GValue_Array)
   is
      procedure Internal
         (Self       : System.Address;
          Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
          Columns    : System.Address;
          Values     : System.Address;
          N_Values   : Gint);
      pragma Import (C, Internal, "gtk_list_store_set_valuesv");
   begin
      if Columns'Length = Values'Length then
         Internal (Get_Object (Self), Iter,
                   Columns (Columns'First)'Address,
                   Values (Values'First)'Address, Values'Length);
      end if;
   end Set;

   procedure Set
     (Self       : not null access Gtk_List_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Values     : Glib.Values.GValue_Array)
   is
      Columns : Gint_Array (Integer (Values'First) .. Integer (Values'Last));
   begin
      for C in Columns'Range loop
         Columns (C) := Gint (C);
      end loop;
      Set (Self, Iter, Columns, Values);
   end Set;
       </body>
     </extra>
   </package>

   <package id="GtkTreeStore" parent="Gtk.Tree_Model.Gtk_Root_Tree_Model">
     <parameter name="self" ada="Tree_Store" />
     <method id="gtk_tree_store_newv" ada="Gtk_New">
       <parameter name="types" type="GType_Array"/>
       <parameter name="n_columns" ada="" default="Types'Length"/>
     </method>
     <method id="gtk_tree_store_set_column_types">
       <parameter name="types" type="GType_Array"/>
       <parameter name="n_columns" ada="" default="Types'Length"/>
     </method>
     <method id="gtk_tree_store_remove" return="void">
       <parameter name="iter" direction="inout"/>
     </method>
     <method id="gtk_tree_store_reorder">
       <parameter name="new_order" type="Gint_Array"/>
     </method>
     <method id="gtk_tree_store_set_value">
       <parameter name="value" ctype="GValue" />
     </method>
     <method id="gtk_tree_store_insert_with_valuesv" bind="False"/> <!-- valist -->
     <method id="gtk_tree_store_set_valist" bind="False"/> <!-- valist -->
     <method id="gtk_tree_store_set_valuesv" bind="False"/> <!-- manually -->
     <extra>
       <spec>
   generic
      type Data_Type is private;
   package Generic_Set is
      type Data_Type_Access is access all Data_Type;

      procedure Set
        (Tree_Store : access Gtk_Tree_Store_Record'Class;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint;
         Value      : Data_Type_Access);
      --  Generic procedure used to store access objects in the model.
      --  For GObject and all of its descendents (including all widgets),
      --  you should use the Set procedure below that takes a GObject as
      --  parameter.
      --
      --  Please see the example at the end for more information on how to
      --  create your own Set procedures adapted to your model. Also consider
      --  using Set_Value for complex cases

      function Get
        (Tree_Store : access Gtk_Tree_Store_Record'Class;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint) return Data_Type_Access;
      --  Generic procedure used to get access objects back from the model.
      --  For GObject and all of its descendents (including all widgets),
      --  you should use the Get_Object function defined in Gtk-Tree_Model
      --  that returns a GObject.

   end Generic_Set;

   procedure Set
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : UTF8_String);
   procedure Set
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Boolean);
   procedure Set_Ulong
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Gulong);
   procedure Set
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Gint);
   procedure Set
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Glib.C_Proxy);
   procedure Set
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Address    : System.Address);
   procedure Set
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Glib.Object.GObject);

   procedure Set
     (Self       : not null access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Columns    : Glib.Gint_Array;
      Values     : Glib.Values.GValue_Array);
   pragma Precondition (Columns'Length = Values'Length);
   --  A variant of Set which takes the columns and valus as two arrays.
   --  This is more efficient when changing multiple values than calling
   --  one of the Set procedures above multiple times.

   procedure Set
     (Self       : not null access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Values     : Glib.Values.GValue_Array);
   --  A variant of the above that is used to set all the columns.

   function Freeze_Sort
     (Tree : access Gtk.Tree_Store.Gtk_Tree_Store_Record'Class)
      return Gint;
   --  Freeze the sorting in the tree view, and returns the current
   --  sort_column_id, which should be used when thawing. (See Thaw_Sort)

   procedure Thaw_Sort
     (Tree      : access Gtk.Tree_Store.Gtk_Tree_Store_Record'Class;
      Column_Id : Gint);
   --  Thaw a frozen tree_view. Column_Id should be the value returned by
   --  the corresponding call to Freeze_Sort.
       </spec>
       <body>
   function Freeze_Sort
     (Tree : access Gtk.Tree_Store.Gtk_Tree_Store_Record'Class)
      return Gint
   is
      function Internal (Tree : System.Address) return Gint;
      pragma Import (C, Internal, "ada_gtk_tree_view_freeze_sort");
   begin
      return Internal (Get_Object (Tree));
   end Freeze_Sort;

   procedure Thaw_Sort
     (Tree : access Gtk.Tree_Store.Gtk_Tree_Store_Record'Class;
      Column_Id : Gint)
   is
      procedure Internal (Tree : System.Address; Id : Gint);
      pragma Import (C, Internal, "ada_gtk_tree_view_thaw_sort");
   begin
      Internal (Get_Object (Tree), Column_Id);
   end Thaw_Sort;

package body Generic_Set is

      pragma Warnings (Off);
      --  Disable warnings on strict aliasing, since there's no aliasing
      --  issue here.

      function To_Address is new
        Ada.Unchecked_Conversion (Data_Type_Access, System.Address);

      function To_Access is new
        Ada.Unchecked_Conversion (System.Address, Data_Type_Access);

      pragma Warnings (On);

      procedure Set
        (Tree_Store : access Gtk_Tree_Store_Record'Class;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint;
         Value      : Data_Type_Access) is
      begin
         Set (Tree_Store, Iter, Column, To_Address (Value));
      end Set;

      function Get
        (Tree_Store : access Gtk_Tree_Store_Record'Class;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint) return Data_Type_Access is
      begin
         return To_Access (Get_Address (+Tree_Store, Iter, Column));
      end Get;
   end Generic_Set;

   procedure Set
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Address    : System.Address)
   is
      procedure Internal
        (Tree_Store : System.Address;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint;
         Value      : System.Address);
      pragma Import (C, Internal, "ada_gtk_tree_store_set_ptr");
   begin
      Internal (Get_Object (Tree_Store), Iter, Column, Address);
   end Set;

   procedure Set
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : UTF8_String)
   is
      procedure Internal
        (Tree_Store : System.Address;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint;
         Value      : UTF8_String);
      pragma Import (C, Internal, "ada_gtk_tree_store_set_ptr");
   begin
      Internal (Get_Object (Tree_Store), Iter, Column, Value &amp; ASCII.NUL);
   end Set;

   procedure Set
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Gint)
   is
      procedure Internal
        (Tree_Store : System.Address;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint;
         Value      : Gint);
      pragma Import (C, Internal, "ada_gtk_tree_store_set_int");
   begin
      Internal (Get_Object (Tree_Store), Iter, Column, Value);
   end Set;

   procedure Set_Ulong
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Gulong)
   is
      procedure Internal
        (Tree_Store : System.Address;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint;
         Value      : Gulong);
      pragma Import (C, Internal, "ada_gtk_tree_store_set_ulong");
   begin
      Internal (Get_Object (Tree_Store), Iter, Column, Value);
   end Set_Ulong;

   procedure Set
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Boolean)
   is
      procedure Internal
        (Tree_Store : System.Address;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint;
         Value      : Gboolean);
      pragma Import (C, Internal, "ada_gtk_tree_store_set_int");
   begin
      Internal (Get_Object (Tree_Store), Iter, Column, Boolean'Pos (Value));
   end Set;

   procedure Set
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Glib.C_Proxy)
   is
      procedure Internal
        (Tree_Store : System.Address;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint;
         Value      : Glib.C_Proxy);
      pragma Import (C, Internal, "ada_gtk_tree_store_set_ptr");
   begin
      Internal (Get_Object (Tree_Store), Iter, Column, Value);
   end Set;

   procedure Set
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Glib.Object.GObject)
   is
      procedure Internal
        (Tree_Store : System.Address;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint;
         Value      : System.Address);
      pragma Import (C, Internal, "ada_gtk_tree_store_set_ptr");
   begin
      if Value = null then
         Internal (Get_Object (Tree_Store), Iter, Column, System.Null_Address);
      else
         Internal (Get_Object (Tree_Store), Iter, Column, Get_Object (Value));
      end if;
   end Set;

   procedure Set
     (Self       : not null access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Columns    : Glib.Gint_Array;
      Values     : Glib.Values.GValue_Array)
   is
      procedure Internal
         (Self       : System.Address;
          Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
          Columns    : System.Address;
          Values     : System.Address;
          N_Values   : Gint);
      pragma Import (C, Internal, "gtk_tree_store_set_valuesv");
   begin
      if Columns'Length = Values'Length then
         Internal (Get_Object (Self), Iter,
                   Columns (Columns'First)'Address,
                   Values (Values'First)'Address, Values'Length);
      end if;
   end Set;

   procedure Set
     (Self       : not null access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Values     : Glib.Values.GValue_Array)
   is
      Columns : Gint_Array (Integer (Values'First) .. Integer (Values'Last));
   begin
      for C in Columns'Range loop
         Columns (C) := Gint (C);
      end loop;
      Set (Self, Iter, Columns, Values);
   end Set;

       </body>
     </extra>
   </package>

   <package id="GtkGrid">
     <method id="gtk_grid_attach">
       <parameter name="width" default='1'/>
       <parameter name="height" default='1'/>
     </method>
     <method id="gtk_grid_attach_next_to">
       <parameter name="width" default='1'/>
       <parameter name="height" default='1'/>
     </method>
   </package>

   <package id="GtkCssSection">
     <enum ctype="GtkCssSectionType"/>

     <method id="gtk_css_section_get_file" bind="False"/>  <!--  needs GFile -->
   </package>

   <package id="GdkFrameClock">
     <enum ctype="GdkFrameClockPhase"/>
   </package>

   <package id="GtkMenuButton">
   </package>

   <package id="GtkActionable">
   </package>

   <package id="GtkThemingEngine">
     <method id="gtk_theming_engine_get_style_valist" bind="False"/> <!-- valist -->
     <method id="gtk_theming_engine_get_valist" bind="False"/> <!-- valist -->

     <method id="gtk_theming_engine_register_property" bind="False"/> <!-- obsolete and requires GtkStylePropertyParser -->
   </package>

   <package id="GtkBindingSet">
     <method id="gtk_binding_set_new" ada="Gtk_New"/>
     <record ctype="GtkBindingSet">
       <field name="widget_path_pspecs" ctype="gpointer"/>  <!-- unused in C -->
       <field name="widget_class_pspecs" ctype="gpointer"/>  <!-- unused in C -->
       <field name="class_branch_pspecs" ctype="gpointer"/>  <!-- unused in C -->
       <field name="current" ctype="gpointer"/>  <!-- implementation detail in C -->
     </record>
   </package>

   <package id="GtkBindingEntry" into="GtkBindingSet">
   </package>

   <package id="GIO" ada="Glib.IO"/>

   <package id="GVariant" ada="Glib.Variant">
     <enum ctype="GVariantClass" prefix="G_VARIANT_"/>
     <method id="g_variant_new_from_bytes" bind="False"/>  <!--  requires GByte -->
     <method id="g_variant_get_data_as_bytes" bind="False"/>  <!--  requires GByte -->
     <method id="g_variant_new_parsed_va" bind="False" /> <!-- va_list -->
     <method id="g_variant_new_va" bind="False" /> <!-- va_list -->
     <method id="g_variant_get_va" bind="False" /> <!-- va_list -->
     <method id="g_variant_new_array" bind="False"/> <!-- c arrays -->
     <method id="g_variant_new_fixed_array" bind="False"/> <!-- c arrays -->
     <method id="g_variant_new_from_data" bind="False"/> <!-- c arrays -->
     <method id="g_variant_new_maybe" bind="False"/> <!-- c arrays -->
     <method id="g_variant_new_tuple" bind="False"/> <!-- c arrays -->
     <method id="g_variant_get_fixed_array" bind="False"/> <!-- c arrays -->
     <method id="g_variant_compare" bind="False"/> <!-- c arrays -->
     <method id="g_variant_equal" bind="False"/> <!-- c arrays -->
     <method id="g_variant_get_data" bind="False"/> <!-- c arrays -->
     <method id="g_variant_dup_bytestring" bind="False"/> <!-- c arrays -->
     <method id="g_variant_get_bytestring" bind="False"/> <!-- c arrays -->
   </package>

   <package id="GVariantIter" into="GVariant" ada="Glib.Variant">
     <method id="g_variant_iter_copy" bind="False"/> <!-- results in duplicate import -->
     <method id="g_variant_iter_free" bind="False"/> <!-- results in duplicate import -->
     <method id="g_variant_iter_n_children" bind="False"/> <!-- duplicate import -->
   </package>

   <package id="GVariantType" into="GVariant" ada="Glib.Variant">
     <method id="g_variant_type_checked_" bind="False"/> <!--  implementation detail -->
     <method id="g_variant_type_new_from_bytes" bind="False"/>  <!--  requires GByte -->
     <method id="g_variant_type_new_tuple" bind="False"/> <!-- c arrays -->
     <method id="g_variant_type_new_maybe" bind="False"/> <!-- c arrays -->
     <method id="g_variant_type_new_array" bind="False"/> <!-- c arrays -->
     <method id="g_variant_type_equal" bind="False"/> <!-- c arrays -->
     <method id="g_variant_type_hash" bind="False"/> <!-- duplicate import -->
     <method id="g_variant_type_string_scan" bind="False"/> <!-- c arrays -->
     <extra>
        <spec>
      Gvariant_Type_Boolean : constant Gvariant_Type; --  value is 0 or 1
      Gvariant_Type_Byte    : constant Gvariant_Type; --  from 0 to 255
      Gvariant_Type_Int16   : constant Gvariant_Type; --  from -32768..32767
      Gvariant_Type_Uint16  : constant Gvariant_Type; --  from 0 to 65535
      Gvariant_Type_Int32   : constant Gvariant_Type;
      Gvariant_Type_Uint32  : constant Gvariant_Type;
      Gvariant_Type_Int64   : constant Gvariant_Type;
      Gvariant_Type_Uint64  : constant Gvariant_Type;
      Gvariant_Type_Double  : constant Gvariant_Type;
      Gvariant_Type_String  : constant Gvariant_Type;

      pragma Import (C, Gvariant_Type_Boolean, "ada_gvariant_type_boolean");
      pragma Import (C, Gvariant_Type_Byte,    "ada_gvariant_type_byte");
      pragma Import (C, Gvariant_Type_Int16,   "ada_gvariant_type_int16");
      pragma Import (C, Gvariant_Type_Uint16,  "ada_gvariant_type_uint16");
      pragma Import (C, Gvariant_Type_Int32,   "ada_gvariant_type_int32");
      pragma Import (C, Gvariant_Type_Uint32,  "ada_gvariant_type_uint32");
      pragma Import (C, Gvariant_Type_Int64,   "ada_gvariant_type_int64");
      pragma Import (C, Gvariant_Type_Uint64,  "ada_gvariant_type_uint64");
      pragma Import (C, Gvariant_Type_Double,  "ada_gvariant_type_double");
      pragma Import (C, Gvariant_Type_String,  "ada_gvariant_type_string");
        </spec>
     </extra>
   </package>

   <package id="GBytes" ada="Glib.Bytes" />

   <package id="GString" ada="Glib.String">
     <record ctype="GString"/>
     <method id="g_string_append_vprintf" bind="False"/> <!-- valist -->
     <method id="g_string_vprintf" bind="False"/> <!-- valist -->
     <method id="g_string_free_to_bytes" bind="False"/> <!-- requires GByte -->
   </package>

   <package id="GListModel" ada="Glib.List_Model"/>

   <package id="GMenu" ada="Glib.Menu">
      <method id="g_menu_get_type" ada="Get_Type_Menu" />
   </package>

   <package id="GMenuItem" into="GMenu" ada="Glib.Menu">
      <method id="g_menu_item_get_type" ada="Get_Type_Menu_Item" />
   </package>

   <package id="GMenuModel" ada="Glib.Menu_Model">
      <method id="g_menu_model_get_type" ada="Get_Type_Menu_Model" />
   </package>

   <package id="GMenuAttributeIter" into="GMenuModel" ada="Glib.Menu_Model">
      <method id="g_menu_attribute_iter_get_type" ada="Get_Type_Menu_Attribute_Iter" />
      <method id="g_menu_attribute_iter_get_next" bind="False"/> <!-- parameter out String -->
   </package>

   <package id="GMenuLinkIter" into="GMenuModel" ada="Glib.Menu_Model">
      <method id="g_menu_link_iter_get_type" ada="Get_Type_Menu_Link_Iter" />
      <method id="g_menu_link_iter_get_next" bind="False"/> <!-- parameter out String -->
   </package>

   <package id="GApplication" ada="Glib.Application">
     <virtual-method id='command_line' bind='True'/>
     <virtual-method id='local_command_line' bind='True'>
        <parameter name='arguments' type='Gtkada.Bindings.chars_ptr_array_access' direction='access'/>
     </virtual-method>
     <enum ctype="GApplicationFlags"/>
     <method id="g_application_get_dbus_connection" bind="False"/> <!-- requires DBus -->
     <method id="g_application_open" bind="False" /> <!-- requires GFile -->
     <method id="::open" bind="False"/>  <!--  requires GFile -->
     <method id="g_application_add_main_option_entries" bind="False"/>  <!--  requires GOptionEntry -->
     <method id="g_application_add_main_option" bind="False" /> <!--  circular dependency -->
     <method id="g_application_add_option_group" bind="False"/> <!--  circular dependency -->
     <method id="g_application_register" bind="False"/> <!--  bound manually -->
     <method id="::handle-local-options" bind="False"/>  <!--  require GVariant -->
     <!-- bound manually below -->
      <extra>
        <with_spec pkg="Glib.Cancellable"/>
        <spec>
   function Register
      (Self        : not null access Gapplication_Record;
       Cancellable : access Glib.Cancellable.Gcancellable_Record'Class)
       return Boolean;
   --  Attempts registration of the application.
   --  This is the point at which the application discovers if it is the
   --  primary instance or merely acting as a remote for an already-existing
   --  primary instance. This is implemented by attempting to acquire the
   --  application identifier as a unique bus name on the session bus using
   --  GDBus.
   --  If there is no application ID or if
   --  Glib.Application.G_Application_Non_Unique was given, then this process
   --  will always become the primary instance.
   --  Due to the internal architecture of GDBus, method calls can be
   --  dispatched at any time (even if a main loop is not running). For this
   --  reason, you must ensure that any object paths that you wish to register
   --  are registered before calling this function.
   --  If the application has already been registered then True is returned
   --  with no work performed.
   --  The Glib.Application.Gapplication::startup signal is emitted if
   --  registration succeeds and Application is the primary instance (including
   --  the non-unique case).
   --  In the event of an error (such as Cancellable being cancelled, or a
   --  failure to connect to the session bus), False is returned and Error is
   --  set appropriately.
   --  Note: the return value of this function is not an indicator that this
   --  instance is or is not the primary instance of the application. See
   --  Glib.Application.Get_Is_Remote for that.
   --  Since: gtk+ 2.28
   --  "cancellable": a Glib.Cancellable.Gcancellable, or null
        </spec>
        <body>
   --------------
   -- Register --
   --------------

   function Register
      (Self        : not null access Gapplication_Record;
       Cancellable : access Glib.Cancellable.Gcancellable_Record'Class)
       return Boolean
   is
      function Internal
         (Self        : System.Address;
          Cancellable : System.Address;
          Error       : System.Address) return Glib.Gboolean;
      pragma Import (C, Internal, "g_application_register");
   begin
      return Internal (Get_Object (Self), Get_Object_Or_Null (GObject (Cancellable)), System.Null_Address) /= 0;
   end Register;
        </body>
      </extra>
   </package>
   <package id="GNotification" ada="Glib.Notification">
      <method id="g_notification_set_body">
         <parameter name="body" ada="the_body"/>
      </method>
      <enum ctype='GNotificationPriority'/>
   </package>

   <package id="GApplicationCommandLine" into="GApplication" ada="Glib.Application">
     <method id="g_application_command_line_create_file_for_arg" bind="False" /> <!-- requires GFile -->
     <method id="g_application_command_line_get_stdin" bind="False" /> <!-- requires GInputStream -->
     <method id="g_application_command_line_get_type" ada="Get_Type_Command_Line" />
     <method id="g_application_command_line_get_options_dict" bind="False"/> <!-- requires GVariant -->
     <method id="g_application_command_line_get_arguments">
       <parameter name="argc" ada="" default="null"/>
       <return-value transfer-ownership="full"/>
     </method>
     <extra>
       <spec>
   function Run
      (Self : not null access Gapplication_Record) return Gint;
   --  Same as above, but automatically sets argc argv from actual values.
       </spec>
       <body>
   gnat_argc : Interfaces.C.int;
   pragma Import (C, gnat_argc);

   gnat_argv : System.Address;
   pragma Import (C, gnat_argv);

   function Run
      (Self : not null access Gapplication_Record) return Gint
   is
      function Internal
         (Self : System.Address;
          Argc : Gint;
          Argv : System.Address) return Gint;
      pragma Import (C, Internal, "g_application_run");
   begin
      return Internal (Self.Get_Object, Gint (gnat_argc), gnat_argv);
   end Run;
       </body>
     </extra>
   </package>

   <package id="GOptionContext" ada="Glib.Option">
     <record ctype="GOptionGroup"/>
     <record ctype="GOptionEntry">
       <field name="flags" ctype="GOptionFlags"/>
     </record>
     <enum ctype="GOptionError"/>
     <enum ctype="GOptionArg"/>
     <enum ctype="GOptionFlags"/>
     <method id="g_option_context_new" ada="G_New"/>
     <method id="g_option_group_new" ada="G_New"/>
     <method id="g_option_context_parse" bind="False"/> <!-- Invalid binding generated -->
     <method id="g_option_context_parse_strv" bind="False"/> <!-- low-level -->
     <method id="g_option_context_add_main_entries">
       <parameter name="entries" type="GOption_Entry_Array"/>
     </method>
     <extra>
       <type ctype="array_of_GOptionEntry" ada="GOption_Entry_Array">
         type GOption_Entry_Array is array (Natural range &lt;&gt;) of GOption_Entry;
       </type>
       <with_spec pkg="Glib.Application"/>
       <with_spec pkg="Glib.Error"/>
       <with_spec pkg="Gtkada.Bindings"/>
       <with_body pkg="Ada.Unchecked_Conversion" use='false'/>
       <spec>
   Null_GOption_Entry : constant GOption_Entry;

   type Parse_Filter is access function (Param : String) return Boolean;
   --  Returns True if the parameter is to be passed from Command_Line to
   --  Goption_Context

   procedure Parse
     (Self         : Goption_Context;
      Command_Line : not null access Glib.Application.Gapplication_Command_Line_Record'Class;
      Filter       : Parse_Filter := null;
      Success      : out Boolean;
      Error        : out Glib.Error.GError);
   --  Parses the arguments given via Command_Line, removing from the arguments
   --  list all parsed switches.

   procedure Parse
     (Self         : Goption_Context;
      Argv         : access chars_ptr_array_access;  --  Null-terminated
      Success      : out Boolean;
      Error        : out Glib.Error.GError);
   --  This version is suitable for use from Glib.Application.Local_Command_Line
       </spec>
       <spec private="True">
   Null_GOption_Entry : constant GOption_Entry :=
                          (Gtkada.Types.Null_Ptr, Gchar(ASCII.NUL),
                           0, G_Option_Arg_None, System.Null_Address,
                           Gtkada.Types.Null_Ptr, Gtkada.Types.Null_Ptr);
       </spec>
       <body>
   -----------
   -- Parse --
   -----------

   procedure Parse
     (Self         : Goption_Context;
      Command_Line : not null access Glib.Application.Gapplication_Command_Line_Record'Class;
      Filter       : Parse_Filter := null;
      Success      : out Boolean;
      Error        : out Glib.Error.GError)
   is
      function Get_Args
         (Self : System.Address;
          Argc : access Glib.Gint) return chars_ptr_array_access;
      pragma Import (C, Get_Args, "g_application_command_line_get_arguments");

      function Internal
         (Self  : System.Address;
          Argc  : access Glib.Gint;
          Argv  : System.Address;
          Error : System.Address) return Glib.Gboolean;
      pragma Import (C, Internal, "g_option_context_parse");

      pragma Warnings (Off, "possible aliasing problem for*");
      function Convert is new Ada.Unchecked_Conversion
         (System.Address, chars_ptr_array_access);
      pragma Warnings (On, "possible aliasing problem for*");

      Argc : aliased Glib.Gint;
      Argv : chars_ptr_array_access;
      Err  : Glib.Error.GError;
      Ret  : Glib.Gboolean;
   begin
      Argv := Get_Args (Command_Line.Get_Object, Argc'Access);

      if Filter = null then
         Ret := Internal (Get_Object (Self), Argc'Access, Argv'Address, Err'Address);
      else
         declare
            Args : aliased Gtkada.Types.Chars_Ptr_Array := To_Chars_Ptr (Argv);
            Idx  : aliased Glib.Gint := 1;
         begin
            --  Copy command name argument
            Args (0) := Argv (0);
            Idx := 1;

            for J in 1 .. Argc - 1 loop
               if Filter
                  (Gtkada.Types.Value (Argv (Interfaces.C.size_t (J))))
               then
                  Args (Interfaces.C.size_t (Idx)) :=
                    Argv (Interfaces.C.size_t (J));
                  Idx := Idx + 1;
               end if;
            end loop;

            Argv := Convert (Args'Address);
            Ret := Internal
               (Get_Object (Self), Idx'Access, Argv'Address, Err'Address);
         end;
      end if;

      Error := Err;
      Success := Ret /= 0;
   end Parse;

   -----------
   -- Parse --
   -----------

   procedure Parse
     (Self         : Goption_Context;
      Argv         : access chars_ptr_array_access;  --  Null-terminated
      Success      : out Boolean;
      Error        : out Glib.Error.GError)
   is
      use Interfaces.C;
      function Internal
         (Self  : System.Address;
          Argc  : access Glib.Gint;
          Argv  : access chars_ptr_array_access;
          Error : System.Address) return Glib.Gboolean;
      pragma Import (C, Internal, "g_option_context_parse");

      Err  : Glib.Error.GError;
      Ret  : Glib.Gboolean;
      Argc : aliased Glib.Gint := 0;

   begin
      while Argv.all (size_t (Argc)) /= Gtkada.Types.Null_Ptr loop
         Argc := Argc + 1;
      end loop;

      Ret := Internal (Get_Object (Self), Argc'Access, Argv, Err'Address);
      Argv.all (size_t (Argc)) := Gtkada.Types.Null_Ptr;
      Error := Err;
      Success := Ret /= 0;
   end Parse;
       </body>
     </extra>
   </package>

   <package id="GAction" ada="Glib.Action">
      <method id="g_action_parse_detailed_name" bind="False"/>  <!-- incorrect generated binding -->
   </package>

   <package id="GSimpleAction" ada="Glib.Simple_Action">
   </package>

   <package id="GActionGroup" ada="Glib.Action_Group">
   </package>

   <package id="GSimpleActionGroup" ada="Glib.Simple_Action_Group">
     <method id="g_simple_action_group_add_entries">
       <parameter name="entries" type="Glib.Action_Map.GAction_Entry_Array"/>
       <parameter name="n_entries" ada="" default="Entries'Length"/>
       <parameter name="user_data" default="System.Null_Address"/>
     </method>
   </package>

   <package id="GActionMap" ada="Glib.Action_Map">
     <record ctype="GActionEntry" private="true" />
     <method id="g_action_map_add_action_entries">
       <parameter name="n_entries" ada="" default="Entries'Length"/>
       <parameter name="user_data" default="System.Null_Address"/>
     </method>
     <extra>
       <type ctype="array_of_ActionEntry" ada="GAction_Entry_Array">
         type GAction_Entry_Array is array (Natural range &lt;&gt;) of GAction_Entry;
       </type>
       <with_spec pkg="Glib.Variant"/>
       <with_spec pkg="Glib.Simple_Action"/>
       <spec>
         type Activate_Callback is access procedure
            (Action    : access Glib.Simple_Action.Gsimple_Action;
             Parameter : Glib.Variant.Gvariant;
             Data      : System.Address);
         pragma Convention (C, Activate_Callback);

         type Change_State_Callback is access procedure
            (Action    : access Glib.Simple_Action.Gsimple_Action;
             Parameter : Glib.Variant.Gvariant;
             Data      : System.Address);
         pragma Convention (C, Change_State_Callback);

         function Build
            (Name           : String;
             Activate       : Activate_Callback := null;
             Parameter_Type : String := "";
             State          : String := "";
             Change_State   : Change_State_Callback := null)
            return GAction_Entry;
         --  Return a newly allocation action entry.
         --  This will be freed by the the action_map when needed.
         --
         --  Name is the name of the action.
         --  Activate is the callback to connect to the "activate" signal of
         --  the action.
         --  Parameter_Type is the type of the parameter that must be passed
         --  to the activate function for this action, given as a single
         --  Gvariant (or the empty string for no parameter).
         --  State is the initial state of this action, given in Gvariant
         --  text format. The state is parsed with no extra type information
         --  so type tags must be added to the string if they are necessary.
         --  Change_State is the callback for the "change-state" signal.
       </spec>
       <with_body pkg="Ada.Unchecked_Conversion" use="false" />
       <body>
         function Convert is new Ada.Unchecked_Conversion
            (Activate_Callback, System.Address);
         function Convert is new Ada.Unchecked_Conversion
            (Change_State_Callback, System.Address);

         function Build
            (Name           : String;
             Activate       : Activate_Callback := null;
             Parameter_Type : String := "";
             State          : String := "";
             Change_State   : Change_State_Callback := null)
            return GAction_Entry
         is
            P, S : chars_ptr := null_ptr;
         begin
            if Parameter_Type /= "" then
               P := New_String (Parameter_Type);
            end if;
            if State /= "" then
               S := New_String (State);
            end if;
            return GAction_Entry'
               (Name           => New_String (Name),
                Activate       => Convert (Activate),
                Parameter_Type => P,
                State          => S,
                Change_State   => Convert (Change_State),
                Padding        => &lt;&gt;);
         end Build;
       </body>
     </extra>
   </package>

   <package id="GIOChannel" ada="Glib.IOChannel">
     <enum ctype="GIOCondition"/>
     <enum ctype="GIOFlags"/>
     <enum ctype="GIOStatus"/>
     <enum ctype="GIOError"/>
     <enum ctype="GIOChannelError"/>
     <enum ctype="GSeekType"/>

     <record ctype="GIOFuncs"/>
     <record ctype="GIOChannel" ada="GIO_Channel_Record" />

     <method id="g_io_channel_new_file" bind="False" />
     <method id="g_io_channel_read_line" bind="False" /> <!-- too complicated for generator -->
     <method id="g_io_channel_read_to_end" bind="False" /> <!-- too complicated for generator -->
     <method id="g_io_channel_get_type" bind="False" /> <!-- exists only in gir file -->

     <method id="g_io_channel_shutdown" bind="False" /><!-- gir file should be updated -->
     <method id="g_io_channel_flush" bind="False" /><!-- gir file should be updated -->
     <method id="g_io_channel_set_encoding" bind="False" /><!-- gir file should be updated -->
     <method id="g_io_channel_set_flags" bind="False" /><!-- gir file should be updated -->
     <method id="g_io_channel_read_chars" bind="False" /><!-- gir file should be updated -->
     <method id="g_io_channel_read_line_string" bind="False" /><!-- gir file should be updated -->
     <method id="g_io_channel_read_unichar" bind="False" /><!-- gir file should be updated -->
     <method id="g_io_channel_write_unichar" bind="False" /><!-- gir file should be updated -->
     <method id="g_io_channel_write_chars" bind="False" /><!-- gir file should be updated -->

     <!-- deprecated methods -->
     <method id="g_io_channel_close" bind="False" />
     <method id="g_io_channel_read" bind="False" />
     <method id="g_io_channel_seek" bind="False" />
     <method id="g_io_channel_write" bind="False" />

     <function id="g_io_create_watch"/>

     <extra>
         <with_spec pkg="Glib.Error" />
         <with_spec pkg="Ada.Streams" />
         <type ctype="GIOChannel*" ada="Giochannel">
           type Giochannel is access all GIO_Channel_Record;
           pragma No_Strict_Aliasing (Giochannel);
         </type>

       <spec>
   function Shutdown
     (Self     : Giochannel;
      Flush    : Glib.Gboolean;
      Error    : access Glib.Error.GError) return GIOStatus;
   pragma Import (C, Shutdown, "g_io_channel_shutdown");
   --  Close an IO channel. Any pending data to be written will be flushed if
   --  Flush is True. The channel will not be freed until the last reference is
   --  dropped using Glib.IOChannel.Unref.
   --  "flush": if True, flush pending

   function Flush
     (Self  : Giochannel;
      Error : access Glib.Error.GError) return GIOStatus;
   pragma Import (C, Flush, "g_io_channel_flush");
   --  Flushes the write buffer for the GIOChannel.

   function Set_Encoding
      (Self     : Giochannel;
       Encoding : UTF8_String := "";
       Error    : access Glib.Error.GError) return GIOStatus;
   --  Sets the encoding for the input/output of the channel. The internal
   --  encoding is always UTF-8. The default encoding for the external file is
   --  UTF-8.
   --  The encoding null is safe to use with binary data.
   --  The encoding can only be set if one of the following conditions is
   --  true:
   --  - The channel was just created, and has not been written to or read
   --  from yet.
   --  - The channel is write-only.
   --  - The channel is a file, and the file pointer was just repositioned by
   --  a call to Glib.IOChannel.Seek_Position. (This flushes all the internal
   --  buffers.)
   --  - The current encoding is null or UTF-8.
   --  - One of the (new API) read functions has just returned
   --  Glib.IOChannel.G_Io_Status_Eof (or, in the case of
   --  g_io_channel_read_to_end, Glib.IOChannel.G_Io_Status_Normal).
   --  - One of the functions Glib.IOChannel.Read_Chars or
   --  Glib.IOChannel.Read_Unichar has returned
   --  Glib.IOChannel.G_Io_Status_Again or Glib.IOChannel.G_Io_Status_Error.
   --  This may be useful in the case of G_CONVERT_ERROR_ILLEGAL_SEQUENCE.
   --  Returning one of these statuses from g_io_channel_read_line,
   --  Glib.IOChannel.Read_Line_String, or g_io_channel_read_to_end does not
   --  guarantee that the encoding can be changed.
   --  Channels which do not meet one of the above conditions cannot call
   --  Glib.IOChannel.Seek_Position with an offset of
   --  Glib.IOChannel.G_Seek_Cur, and, if they are "seekable", cannot call
   --  Glib.IOChannel.Write_Chars after calling one of the API "read"
   --  functions.
   --  "encoding": the encoding type

   function Set_Flags
     (Self : Giochannel;
     Flags : GIOFlags;
     Error : access Glib.Error.GError) return GIOStatus;
   pragma Import (C, Set_Flags, "g_io_channel_set_flags");
   --  Sets the (writeable) flags in Channel to (Flags and
   --  Glib.IOChannel.G_Io_Flag_Set_Mask).
   --  "flags": the flags to set on the IO channel

   function Read_Chars
      (Self       : Giochannel;
       Buf        : out Ada.Streams.Stream_Element_Array;
       Bytes_Read : access Gsize;
       Error      : access Glib.Error.GError) return GIOStatus;
   --  Replacement for g_io_channel_read with the new API.
   --  "buf": a buffer to read data into
   --  "count": is sent as Buf'Length.
   --  "bytes_read": The number of bytes read. This may be zero even on
   --  success if count less than 6 and the channel's encoding is non-null.
   --  This indicates that the next UTF-8 character is too wide for
   --  the buffer.

   function Write_Chars
      (Self          : Giochannel;
       Buf           : Ada.Streams.Stream_Element_Array;
       Bytes_Written : access Gsize;
       Error         : access Glib.Error.GError) return GIOStatus;
   --  Replacement for g_io_channel_write with the new API.
   --  On seekable channels with encodings other than null or UTF-8, generic
   --  mixing of reading and writing is not allowed. A call to
   --  g_io_channel_write_chars () may only be made on a channel from which
   --  data has been read in the cases described in the documentation for
   --  g_io_channel_set_encoding ().
   --  "buf": a buffer to write data from
   --  "count": is sent as Buf'Length.
   --  "bytes_written": The number of bytes written. This can be nonzero even
   --  if the return value is not Glib.IOChannel.G_Io_Status_Normal. If the
   --  return value is Glib.IOChannel.G_Io_Status_Normal and the channel is
   --  blocking, this will always be equal to Count if Count >= 0.

   function Read_Line_String
      (Self           : Giochannel;
       Buffer         : Glib.String.Gstring;
       Terminator_Pos : in out Gsize;
       Error          : access Glib.Error.GError) return GIOStatus;
   pragma Import (C, Read_Line_String, "g_io_channel_read_line_string");
   --  Reads a line from a Glib.IOChannel.Giochannel, using a
   --  Glib.String.Gstring as a buffer.
   --  "buffer": a Glib.String.Gstring into which the line will be written. If
   --  Buffer already contains data, the old data will be overwritten.
   --  "terminator_pos": location to store position of line terminator, or
   --  null

   function Read_Unichar
      (Self    : Giochannel;
       Thechar : access Gunichar;
       Error   : access Glib.Error.GError) return GIOStatus;
   pragma Import (C, Read_Unichar, "g_io_channel_read_unichar");
   --  Reads a Unicode character from Channel. This function cannot be called
   --  on a channel with null encoding.
   --  "thechar": a location to return a character

   function Write_Unichar
      (Self    : Giochannel;
       Thechar : Gunichar;
       Error   : access Glib.Error.GError) return GIOStatus;
   pragma Import (C, Write_Unichar, "g_io_channel_write_unichar");
   --  Writes a Unicode character to Channel. This function cannot be called
   --  on a channel with null encoding.
   --  "thechar": a character

   generic
      type User_Data is limited private;
   function Generic_Add_Watch
     (Channel    : Giochannel;
      Condition  : GIOCondition;
      Callback   : access function
         (Source    : Giochannel;
          Condition : GIOCondition;
          Data      : access User_Data) return Glib.Gboolean;
      Data       : access User_Data) return Glib.Main.G_Source_Id;
   pragma Import (C, Generic_Add_Watch, "g_io_add_watch");
   --  Adds the Glib.IOChannel.Giochannel into the default main loop context
   --  with the default priority.
   --  "channel": a Glib.IOChannel.Giochannel
   --  "condition": the condition to watch for
   --  "callback": the function to call when the condition is satisfied
       </spec>
       <body>
   ------------------
   -- Set_Encoding --
   ------------------

   function Set_Encoding
      (Self     : Giochannel;
       Encoding : UTF8_String := "";
       Error    : access Glib.Error.GError) return GIOStatus
   is
      function Internal
         (Self     : Giochannel;
          Encoding : Gtkada.Types.Chars_Ptr;
          Error    : access Glib.Error.GError) return GIOStatus;
      pragma Import (C, Internal, "g_io_channel_set_encoding");
      Tmp_Encoding : Gtkada.Types.Chars_Ptr;
      Tmp_Return   : GIOStatus;
   begin
      if Encoding = "" then
         Tmp_Encoding := Gtkada.Types.Null_Ptr;
      else
         Tmp_Encoding := New_String (Encoding);
      end if;
      Tmp_Return := Internal (Self, Tmp_Encoding, Error);
      Free (Tmp_Encoding);
      return Tmp_Return;
   end Set_Encoding;

   ----------------
   -- Read_Chars --
   ----------------

   function Read_Chars
      (Self       : Giochannel;
       Buf        : out Ada.Streams.Stream_Element_Array;
       Bytes_Read : access Gsize;
       Error    : access Glib.Error.GError) return GIOStatus
   is
      function Internal
         (Self           : Giochannel;
          Buf            : System.Address;
          Count          : Gsize;
          Acc_Bytes_Read : access Gsize;
          Error          : access Glib.Error.GError) return GIOStatus;
      pragma Import (C, Internal, "g_io_channel_read_chars");
      Acc_Bytes_Read : aliased Gsize;
      Tmp_Return     : GIOStatus;
   begin
      Tmp_Return := Internal (Self, Buf'Address, Buf'Length, Acc_Bytes_Read'Access, Error);
      if Bytes_Read /= null then
         Bytes_Read.all := Acc_Bytes_Read;
      end if;
      return Tmp_Return;
   end Read_Chars;

   -----------------
   -- Write_Chars --
   -----------------

   function Write_Chars
      (Self          : Giochannel;
       Buf           : Ada.Streams.Stream_Element_Array;
       Bytes_Written : access Gsize;
       Error         : access Glib.Error.GError) return GIOStatus
   is
      function Internal
         (Self              : Giochannel;
          Buf               : System.Address;
          Count             : Gssize;
          Acc_Bytes_Written : access Gsize;
          Error             : access Glib.Error.GError) return GIOStatus;
      pragma Import (C, Internal, "g_io_channel_write_chars");
      Acc_Bytes_Written : aliased Gsize;
      Tmp_Return        : GIOStatus;
   begin
      Tmp_Return := Internal (Self, Buf'Address, Buf'Length, Acc_Bytes_Written'Access, Error);
      Bytes_Written.all := Acc_Bytes_Written;
      return Tmp_Return;
   end Write_Chars;

       </body>
     </extra>
   </package>

   <package id="Spawn" ada="Glib.Spawn">
     <enum ctype="GSpawnFlags"/>
     <enum ctype="GSpawnError" ignore="G_SPAWN_ERROR_2BIG"/>

     <extra>
       <with_spec pkg="Glib.Error"/>
       <with_spec pkg="Gtkada.Types" />
       <type ctype="GPid" ada="GPid">
         type GPid is new Interfaces.C.ptrdiff_t;
       </type>
       <spec>
   generic
      type User_Data is limited private;
   function Generic_Spawn_Async
      (Working_Directory : Gtkada.Types.Chars_Ptr := Gtkada.Types.Null_Ptr;
       Argv              : access Gtkada.Types.Chars_Ptr_Array;
       Envp              : access Gtkada.Types.Chars_Ptr_Array;
       Flags             : GSpawn_Flags;
       Child_Setup       : access procedure
         (Data : access User_Data);
       Data              : access User_Data;
       Child_Pid         : access GPid;
       Error             : access Glib.Error.GError)
       return Glib.Gboolean;
   pragma Import (C, Generic_Spawn_Async, "gnat_spawn_async");
   --  See Glib.Spawn.Spawn_Async_With_Pipes for a full description; this
   --  function simply calls the Glib.Spawn.Spawn_Async_With_Pipes without any
   --  pipes.
   --  You should call Glib.Spawn.Spawn_Close_Pid on the returned child
   --  process reference when you don't need it any more.
   --  If you are writing a GTK+ application, and the program you are spawning
   --  is a graphical application, too, then you may want to use
   --  gdk_spawn_on_screen instead to ensure that the spawned program opens its
   --  windows on the right screen.
   --  Note that the returned Child_Pid on Windows is a handle to the child
   --  process and not its identifier. Process handles and process identifiers
   --  are different concepts on Windows.
   --  "working_directory": child's current working directory, or null to
   --  inherit parent's
   --  "argv": child's argument vector
   --  "envp": child's environment, or null to inherit parent's
   --  "flags": flags from Glib.Spawn.GSpawn_Flags
   --  "child_setup": function to run in the child just before exec
   --  "child_pid": return location for child process reference, or null

   generic
      type User_Data is limited private;
   function Generic_Spawn_Async_With_Pipes
      (Working_Directory : Gtkada.Types.Chars_Ptr := Gtkada.Types.Null_Ptr;
       Argv              : access Gtkada.Types.Chars_Ptr_Array;
       Envp              : access Gtkada.Types.Chars_Ptr_Array;
       Flags             : GSpawn_Flags;
       Child_Setup       : access procedure
         (Data : access User_Data);
       Data              : access User_Data;
       Child_Pid         : access GPid;
       Standard_Input    : access Glib.Gint;
       Standard_Output   : access Glib.Gint;
       Standard_Error    : access Glib.Gint;
       Error             : access Glib.Error.GError)
       return Glib.Gboolean;
   pragma Import
     (C, Generic_Spawn_Async_With_Pipes, "gnat_spawn_async_with_pipes");
   --  Executes a child program asynchronously (your program will not block
   --  waiting for the child to exit). The child program is specified by the
   --  only argument that must be provided, Argv. Argv should be a
   --  null-terminated array of strings, to be passed as the argument vector
   --  for the child. The first string in Argv is of course the name of the
   --  program to execute. By default, the name of the program must be a full
   --  path. If Flags contains the Glib.Spawn.G_Spawn_Search_Path flag, the
   --  `PATH` environment variable is used to search for the executable. If
   --  Flags contains the Glib.Spawn.G_Spawn_Search_Path_From_Envp flag, the
   --  `PATH` variable from Envp is used to search for the executable. If both
   --  the Glib.Spawn.G_Spawn_Search_Path and
   --  Glib.Spawn.G_Spawn_Search_Path_From_Envp flags are set, the `PATH`
   --  variable from Envp takes precedence over the environment variable.
   --  If the program name is not a full path and
   --  Glib.Spawn.G_Spawn_Search_Path flag is not used, then the program will
   --  be run from the current directory (or Working_Directory, if specified);
   --  this might be unexpected or even dangerous in some cases when the
   --  current directory is world-writable.
   --  On Windows, note that all the string or string vector arguments to this
   --  function and the other g_spawn* functions are in UTF-8, the GLib file
   --  name encoding. Unicode characters that are not part of the system
   --  codepage passed in these arguments will be correctly available in the
   --  spawned program only if it uses wide character API to retrieve its
   --  command line. For C programs built with Microsoft's tools it is enough
   --  to make the program have a wmain instead of main. wmain has a wide
   --  character argument vector as parameter.
   --  At least currently, mingw doesn't support wmain, so if you use mingw to
   --  develop the spawned program, it will have to call the undocumented
   --  function __wgetmainargs to get the wide character argument vector and
   --  environment. See gspawn-win32-helper.c in the GLib sources or init.c in
   --  the mingw runtime sources for a prototype for that function.
   --  Alternatively, you can retrieve the Win32 system level wide character
   --  command line passed to the spawned program using the GetCommandLineW
   --  function.
   --  On Windows the low-level child process creation API CreateProcess
   --  doesn't use argument vectors, but a command line. The C runtime
   --  library's spawn* family of functions (which
   --  Glib.Spawn.Spawn_Async_With_Pipes eventually calls) paste the argument
   --  vector elements together into a command line, and the C runtime startup
   --  code does a corresponding reconstruction of an argument vector from the
   --  command line, to be passed to main. Complications arise when you have
   --  argument vector elements that contain spaces of double quotes. The
   --  spawn* functions don't do any quoting or escaping, but on the other hand
   --  the startup code does do unquoting and unescaping in order to enable
   --  receiving arguments with embedded spaces or double quotes. To work
   --  around this asymmetry, Glib.Spawn.Spawn_Async_With_Pipes will do quoting
   --  and escaping on argument vector elements that need it before calling the
   --  C runtime spawn function.
   --  The returned Child_Pid on Windows is a handle to the child process, not
   --  its identifier. Process handles and process identifiers are different
   --  concepts on Windows.
   --  Envp is a null-terminated array of strings, where each string has the
   --  form `KEY=VALUE`. This will become the child's environment. If Envp is
   --  null, the child inherits its parent's environment.
   --  Flags should be the bitwise OR of any flags you want to affect the
   --  function's behaviour. The Glib.Spawn.G_Spawn_Do_Not_Reap_Child means
   --  that the child will not automatically be reaped; you must use a child
   --  watch to be notified about the death of the child process. Eventually
   --  you must call Glib.Spawn.Spawn_Close_Pid on the Child_Pid, in order to
   --  free resources which may be associated with the child process. (On Unix,
   --  using a child watch is equivalent to calling waitpid or handling the
   --  SIGCHLD signal manually. On Windows, calling Glib.Spawn.Spawn_Close_Pid
   --  is equivalent to calling CloseHandle on the process handle returned in
   --  Child_Pid). See g_child_watch_add.
   --  Glib.Spawn.G_Spawn_Leave_Descriptors_Open means that the parent's open
   --  file descriptors will be inherited by the child; otherwise all
   --  descriptors except stdin/stdout/stderr will be closed before calling
   --  exec in the child. Glib.Spawn.G_Spawn_Search_Path means that Argv[0]
   --  need not be an absolute path, it will be looked for in the `PATH`
   --  environment variable. Glib.Spawn.G_Spawn_Search_Path_From_Envp means
   --  need not be an absolute path, it will be looked for in the `PATH`
   --  variable from Envp. If both Glib.Spawn.G_Spawn_Search_Path and
   --  Glib.Spawn.G_Spawn_Search_Path_From_Envp are used, the value from Envp
   --  takes precedence over the environment.
   --  Glib.Spawn.G_Spawn_Stdout_To_Dev_Null means that the child's standard
   --  output will be discarded, instead of going to the same location as the
   --  parent's standard output. If you use this flag, Standard_Output must be
   --  null. Glib.Spawn.G_Spawn_Stderr_To_Dev_Null means that the child's
   --  standard error will be discarded, instead of going to the same location
   --  as the parent's standard error. If you use this flag, Standard_Error
   --  must be null. Glib.Spawn.G_Spawn_Child_Inherits_Stdin means that the
   --  child will inherit the parent's standard input (by default, the child's
   --  standard input is attached to /dev/null). If you use this flag,
   --  Standard_Input must be null. Glib.Spawn.G_Spawn_File_And_Argv_Zero means
   --  that the first element of Argv is the file to execute, while the
   --  remaining elements are the actual argument vector to pass to the file.
   --  Normally Glib.Spawn.Spawn_Async_With_Pipes uses Argv[0] as the file to
   --  execute, and passes all of Argv to the child.
   --  Child_Setup and User_Data are a function and user data. On POSIX
   --  platforms, the function is called in the child after GLib has performed
   --  all the setup it plans to perform (including creating pipes, closing
   --  file descriptors, etc.) but before calling exec. That is, Child_Setup is
   --  called just before calling exec in the child. Obviously actions taken in
   --  this function will only affect the child, not the parent.
   --  On Windows, there is no separate fork and exec functionality. Child
   --  processes are created and run with a single API call, CreateProcess.
   --  There is no sensible thing Child_Setup could be used for on Windows so
   --  it is ignored and not called.
   --  If non-null, Child_Pid will on Unix be filled with the child's process
   --  ID. You can use the process ID to send signals to the child, or to use
   --  g_child_watch_add (or waitpid) if you specified the
   --  Glib.Spawn.G_Spawn_Do_Not_Reap_Child flag. On Windows, Child_Pid will be
   --  filled with a handle to the child process only if you specified the
   --  Glib.Spawn.G_Spawn_Do_Not_Reap_Child flag. You can then access the child
   --  process using the Win32 API, for example wait for its termination with
   --  the WaitFor* functions, or examine its exit code with
   --  GetExitCodeProcess. You should close the handle with CloseHandle or
   --  Glib.Spawn.Spawn_Close_Pid when you no longer need it.
   --  If non-null, the Standard_Input, Standard_Output, Standard_Error
   --  locations will be filled with file descriptors for writing to the
   --  child's standard input or reading from its standard output or standard
   --  error. The caller of Glib.Spawn.Spawn_Async_With_Pipes must close these
   --  file descriptors when they are no longer in use. If these parameters are
   --  null, the corresponding pipe won't be created.
   --  If Standard_Input is NULL, the child's standard input is attached to
   --  /dev/null unless Glib.Spawn.G_Spawn_Child_Inherits_Stdin is set.
   --  If Standard_Error is NULL, the child's standard error goes to the same
   --  location as the parent's standard error unless
   --  Glib.Spawn.G_Spawn_Stderr_To_Dev_Null is set.
   --  If Standard_Output is NULL, the child's standard output goes to the
   --  same location as the parent's standard output unless
   --  Glib.Spawn.G_Spawn_Stdout_To_Dev_Null is set.
   --  Error can be null to ignore errors, or non-null to report errors. If an
   --  error is set, the function returns False. Errors are reported even if
   --  they occur in the child (for example if the executable in Argv[0] is not
   --  found). Typically the `message` field of returned errors should be
   --  displayed to users. Possible errors are those from the G_SPAWN_ERROR
   --  domain.
   --  If an error occurs, Child_Pid, Standard_Input, Standard_Output, and
   --  Standard_Error will not be filled with valid values.
   --  If Child_Pid is not null and an error does not occur then the returned
   --  process reference must be closed using Glib.Spawn.Spawn_Close_Pid.
   --  If you are writing a GTK+ application, and the program you are spawning
   --  is a graphical application, too, then you may want to use
   --  gdk_spawn_on_screen_with_pipes instead to ensure that the spawned
   --  program opens its windows on the right screen.
   --  "working_directory": child's current working directory, or null to
   --  inherit parent's, in the GLib file name encoding
   --  "argv": child's argument vector, in the GLib file name encoding
   --  "envp": child's environment, or null to inherit parent's, in the GLib
   --  file name encoding
   --  "flags": flags from Glib.Spawn.GSpawn_Flags
   --  "child_setup": function to run in the child just before exec
   --  "child_pid": return location for child process ID, or null
   --  "standard_input": return location for file descriptor to write to
   --  child's stdin, or null
   --  "standard_output": return location for file descriptor to read child's
   --  stdout, or null
   --  "standard_error": return location for file descriptor to read child's
   --  stderr, or null

   generic
      type User_Data is limited private;
   function Generic_Spawn_Async_With_Fds
      (Working_Directory : Gtkada.Types.Chars_Ptr := Gtkada.Types.Null_Ptr;
       Argv              : access Gtkada.Types.Chars_Ptr_Array;
       Envp              : access Gtkada.Types.Chars_Ptr_Array;
       Flags             : GSpawn_Flags;
       Child_Setup       : access procedure
         (Data : access User_Data);
       Data              : access User_Data;
       Child_Pid         : access GPid;
       Stdin_Fd          : Glib.Gint;
       Stdout_Fd         : Glib.Gint;
       Stderr_Fd         : Glib.Gint;
       Error             : access Glib.Error.GError)
       return Glib.Gboolean;
   pragma Import
     (C, Generic_Spawn_Async_With_Fds, "gnat_spawn_async_with_fds");
   --  Identical to g_spawn_async_with_pipes() but instead of creating pipes
   --  for the stdin/stdout/stderr, you can pass existing file descriptors
   --  into this function through the stdin_fd , stdout_fd and
   --  stderr_fd parameters. The following flags also have their behaviour
   --  slightly tweaked as a result: G_SPAWN_STDOUT_TO_DEV_NULL means that
   --  the child's standard output will be discarded, instead of going to the
   --  same location as the parent's standard output. If you use this flag,
   --  standard_output must be -1. G_SPAWN_STDERR_TO_DEV_NULL means that the
   --  child's standard error will be discarded, instead of going to the same
   --  location as the parent's standard error. If you use this flag,
   --  standard_error must be -1. G_SPAWN_CHILD_INHERITS_STDIN means that the
   --  child will inherit the parent's standard input (by default, the child's
   --  standard input is attached to /dev/null). If you use this flag,
   --  standard_input must be -1.
   --  It is valid to pass the same fd in multiple parameters (e.g. you can
   --  pass a single fd for both stdout and stderr).
   --  Parameters
   --  "working_directory" child's current working directory, or NULL to
   --  inherit parent's, in the GLib file name encoding.
   --  "argv" child's argument vector, in the GLib file name encoding.
   --  "envp"  child's environment, or NULL to inherit parent's, in the GLib
   --  file name encoding.
   --  "flags" flags from GSpawnFlags
   --  "child_setup" function to run in the child just before exec().
   --  "user_data" user data for child_setup
   --  "child_pid" return location for child process ID, or NULL.
   --  "stdin_fd" file descriptor to use for child's stdin, or -1
   --  "stdout_fd" file descriptor to use for child's stdout, or -1
   --  "stderr_fd" file descriptor to use for child's stderr, or -1
   --  "error" return location for error
   --  Returns
   --  TRUE on success, FALSE if an error was set
   --  Since: 2.58

   generic
      type User_Data is limited private;
   function Generic_Spawn_Sync
      (Working_Directory : Gtkada.Types.Chars_Ptr := Gtkada.Types.Null_Ptr;
       Argv              : access Gtkada.Types.Chars_Ptr_Array;
       Envp              : access Gtkada.Types.Chars_Ptr_Array;
       Flags             : GSpawn_Flags;
       Child_Setup       : access procedure
         (Data : access User_Data);
       Data              : access User_Data;
       Child_Pid         : access GPid;
       Standard_Output   : access Gtkada.Types.Chars_Ptr_Array;
       Standard_Error    : access Gtkada.Types.Chars_Ptr_Array;
       Exit_Status       : access Glib.Gint;
       Error             : access Glib.Error.GError)
       return Glib.Gboolean;
   pragma Import (C, Generic_Spawn_Sync, "gnat_spawn_sync");
   --  Executes a child synchronously (waits for the child to exit before
   --  returning). All output from the child is stored in Standard_Output and
   --  Standard_Error, if those parameters are non-null. Note that you must set
   --  the Glib.Spawn.G_Spawn_Stdout_To_Dev_Null and
   --  Glib.Spawn.G_Spawn_Stderr_To_Dev_Null flags when passing null for
   --  Standard_Output and Standard_Error.
   --  If Exit_Status is non-null, the platform-specific exit status of the
   --  child is stored there; see the documentation of
   --  Glib.Spawn.Spawn_Check_Exit_Status for how to use and interpret this.
   --  Note that it is invalid to pass Glib.Spawn.G_Spawn_Do_Not_Reap_Child in
   --  Flags.
   --  If an error occurs, no data is returned in Standard_Output,
   --  Standard_Error, or Exit_Status.
   --  This function calls Glib.Spawn.Spawn_Async_With_Pipes internally; see
   --  that function for full details on the other parameters and details on
   --  how these functions work on Windows.
   --  "working_directory": child's current working directory, or null to
   --  inherit parent's
   --  "argv": child's argument vector
   --  "envp": child's environment, or null to inherit parent's
   --  "flags": flags from Glib.Spawn.GSpawn_Flags
   --  "child_setup": function to run in the child just before exec
   --  "standard_output": return location for child output, or null
   --  "standard_error": return location for child error messages, or null
   --  "exit_status": return location for child exit status, as returned by
   --  waitpid, or null

   generic
      type User_Data is limited private;
   function Generic_Spawn_Command_Line_Sync
      (Command_Line      : Gtkada.Types.Chars_Ptr;
       Standard_Output   : access Gtkada.Types.Chars_Ptr_Array;
       Standard_Error    : access Gtkada.Types.Chars_Ptr_Array;
       Exit_Status       : access Glib.Gint;
       Error             : access Glib.Error.GError)
       return Glib.Gboolean;
   pragma Import
     (C, Generic_Spawn_Command_Line_Sync, "gnat_spawn_command_line_sync");
   --  A simple version of g_spawn_sync() with little-used parameters removed,
   --  taking a command line instead of an argument vector. See g_spawn_sync()
   --  for full details. command_line will be parsed by g_shell_parse_argv().
   --  Unlike g_spawn_sync(), the G_SPAWN_SEARCH_PATH flag is enabled.
   --  Note that G_SPAWN_SEARCH_PATH can have security implications, so
   --  consider using g_spawn_sync() directly if appropriate. Possible errors
   --  are those from g_spawn_sync() and those from g_shell_parse_argv().
   --  If exit_status is non-NULL, the platform-specific exit status of the
   --  child is stored there; see the documentation of
   --  g_spawn_check_exit_status() for how to use and interpret this.
   --  On Windows, please note the implications of g_shell_parse_argv()
   --  parsing command_line . Parsing is done according to Unix shell rules,
   --  not Windows command interpreter rules. Space is a separator,
   --  and backslashes are special. Thus you cannot simply pass a
   --  command_line containing canonical Windows paths, like
   --  "c:\program files\app\app.exe", as the backslashes will be eaten,
   --  and the space will act as a separator. You need to enclose such paths
   --  with single quotes, like "'c:\program files\app\app.exe'
   --  'e:\folder\argument.txt'".
   --  Parameters
   --  "command_line" a command line.
   --  "standard_output" return location for child output.
   --  "standard_error" return location for child errors.
   --  "exit_status" return location for child exit status, as returned
   --  by waitpid().
   --  "error" return location for errors
   --  Returns
   --  TRUE on success, FALSE if an error was set

   function Spawn_Command_Line_Async
      (Command_Line : Gtkada.Types.Chars_Ptr;
       Error        : access Glib.Error.GError)
       return Boolean;
   --  A simple version of Glib.Spawn.Spawn_Async that parses a command line
   --  with g_shell_parse_argv and passes it to Glib.Spawn.Spawn_Async. Runs a
   --  command line in the background. Unlike Glib.Spawn.Spawn_Async, the
   --  Glib.Spawn.G_Spawn_Search_Path flag is enabled, other flags are not.
   --  Note that Glib.Spawn.G_Spawn_Search_Path can have security implications,
   --  so consider using Glib.Spawn.Spawn_Async directly if appropriate.
   --  Possible errors are those from g_shell_parse_argv and
   --  Glib.Spawn.Spawn_Async.
   --  The same concerns on Windows apply as for g_spawn_command_line_sync.
   --  "command_line": a command line

   function Spawn_Check_Exit_Status
     (Exit_Status : Glib.Gint;
      Error       : access Glib.Error.GError)
      return Boolean;
   --  Set Error if Exit_Status indicates the child exited abnormally (e.g.
   --  with a nonzero exit code, or via a fatal signal).
   --  The Glib.Spawn.Spawn_Sync and g_child_watch_add family of APIs return
   --  an exit status for subprocesses encoded in a platform-specific way. On
   --  Unix, this is guaranteed to be in the same format waitpid returns, and
   --  on Windows it is guaranteed to be the result of GetExitCodeProcess.
   --  Prior to the introduction of this function in GLib 2.34, interpreting
   --  Exit_Status required use of platform-specific APIs, which is problematic
   --  for software using GLib as a cross-platform layer.
   --  Additionally, many programs simply want to determine whether or not the
   --  child exited successfully, and either propagate a Gerror.Gerror or print
   --  a message to standard error. In that common case, this function can be
   --  used. Note that the error message in Error will contain human-readable
   --  information about the exit status.
   --  The Domain and Code of Error have special semantics in the case where
   --  the process has an "exit code", as opposed to being killed by a signal.
   --  On Unix, this happens if WIFEXITED would be true of Exit_Status. On
   --  Windows, it is always the case.
   --  The special semantics are that the actual exit code will be the code
   --  set in Error, and the domain will be G_SPAWN_EXIT_ERROR. This allows you
   --  to differentiate between different exit codes.
   --  If the process was terminated by some means other than an exit status,
   --  the domain will be G_SPAWN_ERROR, and the code will be
   --  Glib.Spawn.G_Spawn_Error_Failed.
   --  This function just offers convenience; you can of course also check the
   --  available platform via a macro such as G_OS_UNIX, and use WIFEXITED and
   --  WEXITSTATUS on Exit_Status directly. Do not attempt to scan or parse the
   --  error message string; it may be translated and/or change in future
   --  versions of GLib.
   --  Since: gtk+ 2.34
   --  "exit_status": An exit code as returned from Glib.Spawn.Spawn_Sync
       </spec>
       <body>
   ------------------------------
   -- Spawn_Command_Line_Async --
   ------------------------------

   function Spawn_Command_Line_Async
      (Command_Line : Gtkada.Types.Chars_Ptr;
       Error        : access Glib.Error.GError)
       return Boolean
   is
      function Internal
         (Command_Line : Gtkada.Types.Chars_Ptr;
          Error        : access Glib.Error.GError)
          return Glib.Gboolean;
      pragma Import (C, Internal, "gnat_spawn_command_line_async");
   begin
      return Internal (Command_Line, Error) /= 0;
   end Spawn_Command_Line_Async;

   -----------------------------
   -- Spawn_Check_Exit_Status --
   -----------------------------

   function Spawn_Check_Exit_Status
     (Exit_Status : Glib.Gint;
      Error       : access Glib.Error.GError)
      return Boolean
   is
      function Internal
         (Exit_Status : Glib.Gint;
          Error       : access Glib.Error.GError)
          return Glib.Gboolean;
      pragma Import (C, Internal, "g_spawn_check_exit_status");
   begin
      return Internal (Exit_Status, Error) /= 0;
   end Spawn_Check_Exit_Status;
       </body>
     </extra>

     <function id="g_get_environ"/>
     <function id="g_spawn_close_pid"/>
   </package>

   <package id="GPoll" ada="Glib.Poll">
     <record ctype="GPollFD"/>
   </package>

   <package id="Utils" ada="Glib.Utils">
     <extra>
       <spec>
   function Get_Home_Dir return UTF8_String;
   --  Gets the current user's home directory. As with most UNIX tools, this
   --  function will return the value of the HOME environment variable if it
   --  is set to an existing absolute path name, falling back to the passwd
   --  file in the case that it is unset. If the path given in HOME is
   --  non-absolute, does not exist, or is not a directory, the result is
   --  undefined. Before version 2.36 this function would ignore the HOME
   --  environment variable, taking the value from the passwd database
   --  instead. This was changed to increase the compatibility of GLib with
   --  other programs (and the XDG basedir specification) and to increase
   --  testability of programs based on GLib (by making it easier to run them
   --  from test frameworks). If your program has a strong requirement for
   --  either the new or the old behaviour (and if you don't wish to increase
   --  your GLib dependency to ensure that the new behaviour is in effect)
   --  then you should either directly check the HOME environment variable
   --  yourself or unset it before calling any functions in GLib.
   --
   --  Returns:
   --    the current user's home directory.
       </spec>

       <with_body pkg="Gtkada.Types"/>
       <body>
   ------------------
   -- Get_Home_Dir --
   ------------------

   function Get_Home_Dir return UTF8_String
   is
      function Internal return Gtkada.Types.Chars_Ptr;
      pragma Import (C, Internal, "glib_get_home_dir");

      Tmp    : constant Gtkada.Types.Chars_Ptr := Internal;
      Result : constant String := Gtkada.Types.Value (Tmp);
   begin
      Gtkada.Types.g_free (Tmp);
      return Result;
   end Get_Home_Dir;
       </body>
     </extra>
   </package>

   <package id="GtkApplication">
     <enum ctype="GtkApplicationInhibitFlags"/>
     <method id="gtk_application_get_windows" return="WidgetList"/>
   </package>

   <package id="GCancellable" ada="Glib.Cancellable">
     <method id="g_cancellable_make_pollfd" bind="False"/> <!-- requires GPoll_FD -->
   </package>

   <package id="GdkDeviceManager">
      <method id="gdk_device_manager_list_devices" return="DeviceList"/>
      <method id="::device-added" bind="False"/>
      <method id="::device-changed" bind="False"/>
      <method id="::device-removed" bind="False"/>
      <extra>
         <spec>
   function Get_Device_Manager
      (Self : not null access Gdk.Display.Gdk_Display_Record'Class)
      return Gdk.Device_Manager.Gdk_Device_Manager;
   --  Returns the Gdk.Device_Manager.Gdk_Device_Manager associated to
   --  Display.
   --  Since: gtk+ 3.0
         </spec>
         <body>
   function Get_Device_Manager
      (Self : not null access Gdk.Display.Gdk_Display_Record'Class)
       return Gdk.Device_Manager.Gdk_Device_Manager
   is
      function Internal (Self : System.Address) return System.Address;
      pragma Import (C, Internal, "gdk_display_get_device_manager");
      Stub_Gdk_Device_Manager : Gdk.Device_Manager.Gdk_Device_Manager_Record;
   begin
      return Gdk.Device_Manager.Gdk_Device_Manager (Get_User_Data (Internal (Get_Object (Self)), Stub_Gdk_Device_Manager));
   end Get_Device_Manager;
         </body>
      </extra>
   </package>

   <package id="GdkDisplay">
      <method id="gdk_display_get_app_launch_context" bind="False"/> <!-- requires GdkAppLaunchContext -->
      <method id="gdk_display_list_devices" bind="False"/> <!-- deprecated -->
      <method id="gdk_display_get_default_screen" bind="False"/> <!-- in gdk-screen.ads -->
      <method id="gdk_display_get_screen" bind="False"/> <!-- in gdk-screen.ads -->
      <method id="gdk_display_get_pointer" bind="False"/> <!-- deprecated by Gdk.Device.Get_Position -->
      <method id="gdk_display_warp_pointer" bind="False"/> <!-- deprecated, Gdk.Device.Warp -->
      <method id="gdk_display_get_device_manager" bind="False"/> <!-- in gdk-device_manager.ads -->
      <method id="gdk_display_device_is_grabbed" bind="False"/> <!-- circular dependency -->
      <method id="gdk_display_store_clipboard" bind="False"/> <!-- see below -->
      <method id="gdk_display_get_window_at_pointer" bind="False"/> <!-- see below -->

      <method id="gdk_display_get_default_seat" return="GObject*"/>
      <method id="gdk_display_list_seats" return="ObjectList"/>

      <method id="::monitor-added">
        <parameter name="monitor" ctype="GObject*"/>
      </method>
      <method id="::monitor-removed">
        <parameter name="monitor" ctype="GObject*"/>
      </method>
      <method id="::seat-added">
        <parameter name="seat" ctype="GObject*"/>
      </method>
      <method id="::seat-removed">
        <parameter name="seat" ctype="GObject*"/>
      </method>

      <extra>
         <spec>
   procedure Store_Clipboard
      (Display          : not null access Gdk_Display_Record;
       Clipboard_Window : Gdk.Gdk_Window;
       Time             : Guint32;
       Targets          : Gdk.Types.Gdk_Atom_Array);
   --  Issues a request to the clipboard manager to store the clipboard data.
   --  On X11, this is a special program that works according to the
   --  freedesktop clipboard specification, available at &lt;ulink
   --  url="http://www.freedesktop.org/Standards/clipboard-manager-spec">
   --  http://www.freedesktop.org/Standards/clipboard-manager-spec&lt;/ulink&gt;>.
   --  Since: gtk+ 2.6
   --  "clipboard_window": a Gdk.Gdk_Window belonging to the clipboard owner
   --  "time_": a timestamp
   --  "targets": an array of targets that should be saved, or null if all
   --  available targets should be saved.
   --  "n_targets": length of the Targets array

   procedure Get_Window_At_Pointer
     (Display : access Gdk_Display_Record;
      Win_X   : out Glib.Gint;
      Win_Y   : out Glib.Gint;
      Win     : out Gdk.Gdk_Window);
   --  Obtains the window underneath the mouse pointer, returning the location
   --  of that window in Win_X, Win_Y. Returns nullif the window
   --  under the mouse pointer is not known to GDK (for example, belongs to
   --  another application).
   --  (Win_X, Win_Y) are relative to the origin of the window under the
   --  pointer.
   --
   --  Obsolescent: use Gdk.Device.Get_Window_At_Position instead.
         </spec>
         <body>
   procedure Store_Clipboard
     (Display          : not null access Gdk_Display_Record;
      Clipboard_Window : Gdk_Window;
      Time             : Guint32;
      Targets          : Gdk.Types.Gdk_Atom_Array)
   is
      procedure Internal
        (Display          : System.Address;
         Clipboard_Window : Gdk_Window;
         Time             : Guint32;
         Targets          : System.Address;
         N_Targets        : Gint);
      pragma Import (C, Internal, "gdk_display_store_clipboard");
   begin
      Internal (Get_Object (Display), Clipboard_Window, Time,
                Targets (Targets'First)'Address, Targets'Length);
   end Store_Clipboard;

   procedure Get_Window_At_Pointer
     (Display : access Gdk_Display_Record;
      Win_X   : out Gint;
      Win_Y   : out Gint;
      Win     : out Gdk_Window)
   is
      function Internal
        (Display : System.Address;
         Win_X   : access Gint;
         Win_Y   : access Gint) return Gdk_Window;
      pragma Import (C, Internal, "gdk_display_get_window_at_pointer");
      X, Y : aliased Gint;
   begin
      Win   := Internal (Get_Object (Display), X'Access, Y'Access);
      Win_X := X;
      Win_Y := Y;
   end Get_Window_At_Pointer;
         </body>
      </extra>
   </package>

   <package id='GtkActivatable'>
      <virtual-method id='*' bind='False'/>
   </package>

   <package id='GtkListBoxRow'>
     <list ctype="GtkListBoxRow" ada="List_Box_Row_List" />
   </package>
   <package id='GtkListBox'>
      <method id='gtk_list_box_get_selected_rows' return='ListBoxRowList'>
      </method>
   </package>

   <package id='GtkGesture'>
      <list ctype='GtkGesture' ada='Gesture_List'/>
      <list ctype='GdkEventSequence' ada='Gdk_Event_Sequence_List'/>
      <method id='gtk_gesture_get_group' return='GestureList'/>
      <method id='gtk_gesture_get_sequences' return='GdkEventSequenceList'/>
      <doc>
GtkAda

Gesture events are meant to replace low-level handling in most cases. For
instance, you should move away from direct use of "button_press" event, and
instead use a Gtk.Gesture.Multi_Press gesture. They give you more control (on
the area for which a double click is valid for instance), work with touchpad in
addition to mouse events, and you can have multiple gestures associated with
the same widget, and that won't compete with each other.

For instance, having drag-and-drop on a widget which also manipulates low-level
"button_press" events is hard to get rid, since the latter callback will often
consume the events needed by gtk+ to detect that a drag operation is about to
take place.

Gestures are objects in their full rights, and therefore needs to be Unref-ed
to free memory. GtkAda provides a convenient function for this, so that the
typical workflow is:

   Gesture : Gtk_Gesture_Multi_Press;

   Gtk_New (Gesture, Widget);
   Gesture.Watch (Widget);   --  Destroy Gesture when Widget is destroyed
   Gesture.On_Pressed (On_Pressed'Access, Slot => Widget);

Without the call to Watch, Gesture would be kept in memory for ever, ready
to be attached to some other widget.
      </doc>
      <extra>
         <spec>
   procedure Set_State
     (Self : not null access Gtk_Gesture_Record'Class;
      State : Gtk.Enums.Gtk_Event_Sequence_State := Event_Sequence_Denied);
   pragma Inline (Set_State);
   --  Same as the function Set_State, but ignore the return value.
   --  This is in general call in a gesture callback to stop monitoring the
   --  current sequence of events. For instance, when you have a multipress
   --  gesture, you could call Set_State when the number of clicks is greater
   --  than 2 and you will never be interested in triple clicks or more.

   procedure Watch
     (Self   : not null access Gtk_Gesture_Record'Class;
      Object : not null access GObject_Record'Class);
   --  Automatically unref Self when Widget is destroyed.
   --  This is a convenience function, since attaching a gesture to a widget
   --  does not automatically free the gesture when the widget is destroyed
   --  (presumably so that you can reuse the gesture and its settings for
   --  another widget).
         </spec>
         <body>
   procedure Set_State
     (Self : not null access Gtk_Gesture_Record'Class;
      State : Gtk.Enums.Gtk_Event_Sequence_State := Event_Sequence_Denied)
   is
      Dummy : Boolean;
   begin
      Dummy := Set_State (Self, State);
   end Set_State;

   procedure On_Widget_Destroyed (Gesture, Object : System.Address);
   pragma Convention (C, On_Widget_Destroyed);
   procedure On_Widget_Destroyed (Gesture, Object : System.Address) is
       pragma Unreferenced (Object);
       procedure Internal (Object : System.Address);
       pragma Import (C, Internal, "g_object_unref");
   begin
       Internal (Gesture);
   end On_Widget_Destroyed;

   procedure Watch
     (Self   : not null access Gtk_Gesture_Record'Class;
      Object : not null access GObject_Record'Class)
   is
   begin
      Weak_Ref (Object, Notify => On_Widget_Destroyed'Access,
                Data => Get_Object (Self));
   end Watch;
         </body>
      </extra>
   </package>


   <!-- Below were added just for the sake of parsing the files to get information
        on their symbols, and properly substitute them in the docs.
        No file is generated from them.
   -->

   <package id="GtkNumerableIcon">
     <method id="gtk_numerable_icon_new" ada="Gtk_New"/>
     <method id="gtk_numerable_icon_new_with_style_context" ada="Gtk_New_With_Style_Context"/>
   </package>

  <package id="GtkIMContext">
    <!-- There are issues with binding string parameters for the following
         two methods: -->
    <method id="gtk_im_context_get_preedit_string" bind="False" />
    <method id="gtk_im_context_get_surrounding" bind="False" />
  </package>

  <package id="GtkRevealer">
     <enum ctype="GtkRevealerTransitionType"/>
  </package>

  <package id="GtkStack">
     <enum ctype="GtkStackTransitionType"/>
  </package>

  <package id="GtkFlowBox">
     <method id="gtk_flow_box_get_selected_children" return="WidgetList" />
  </package>

  <package id="GtkGLArea" ada="Gtk.GLArea">
  </package>
</GIR>
