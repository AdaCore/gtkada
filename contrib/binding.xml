<?xml version="1.0"?>

<!--  This file overrides parts of the .gir files. -->

<GIR xmlns:gir="http://www.gtk.org/introspection/core/1.0"
     xmlns:c="http://www.gtk.org/introspection/c/1.0">

   <!-- ###################################################
        Gtk.Button
        ###################################################-->
   <package id="Gtk.Button">
      <doc screenshot="gtk-button"
           group="Buttons and Toggles"
           testgtk="create_buttons.adb">
This package implements a general button widget. This button can
be clicked on by the user to start any action.
This button does not have multiple states, it can just be temporarily
pressed while the mouse is on it, but does not keep its pressed state.

The gtk+ sources provide the following drawing that explains the role of
the various spacings that can be set for a button:
      </doc>

      <method id="gtk_button_new" binding="false"/>

      <method id="gtk_button_new_with_label" ada="Gtk_New">
         <parameter name="label" default='""'/>
      </method>

   </package>

   <!-- ###################################################
        Gtk.Frame
        ###################################################-->
   <package id="Gtk.Frame">
      <doc screenshot="gtk-frame" testgtk="create_frame.adb"
           group="Ornaments">
A Gtk_Frame is a simple border than can be added to any widget or
group of widget to enhance its visual aspect.
Optionally, a frame can have a title.

This is a very convenient widget to visually group related widgets (like
groups of buttons for instance), possibly with a title to explain the
purpose of this group.

A Gtk_Frame has only one child, so you have to put a container like for
instance a Gtk_Box inside if you want the frame to surround multiple
widgets.
      </doc>

      <method id="gtk_frame_new">
         <parameter name="label" default='""'/>
      </method>
   </package>

   <!-- ################################################
        Gtk.Label
        ################################################-->

   <package id="Gtk.Label">
      <doc screenshot="gtk-label" testgtk="create_label.adb"
           group="Display widgets">
A Gtk_Label is a light widget associated with some text you want
to display on the screen. You can change the text dynamically if
needed.

The text can be on multiple lines if you separate each line with
the ASCII.LF character. However, this is not the recommended way
to display long texts (see the Gtk_Text widget instead).

== Mnemonics ==

Labels may contain mnemonics. Mnemonics are underlined characters in the
label, used for keyboard navigation. Mnemonics are created by providing
string with an underscore before the mnemonic character, such as "_File",
to the functions gtk_new_with_mnemonic or set_text_with_mnemonic().

Mnemonics automatically activate any activatable widget the label is
inside, such as a Gtk_Button; if the label is not inside the mnemonic's
target widget, you have to tell the label about the target using
set_mnemonic_widget(). For instance:
    declare
       Button : Gtk_Button;
       Label  : Gtk_Label;
    begin
       Gtk_New (Button);
       Gtk_New_With_Mnemonic (Label, "_File");
       Add (Button, Label);
    end;
However, there exists a convenience function in Gtk.Button to create such
a button already.

== Markup ==

To make it easy to format text in a label (changing colors, fonts, etc.),
label text can be provided in a simple markup format. Here's how to create
a label with a small font:
     Gtk_New (Label, "&lt;small&gt;hello&lt;/small&gt;");

The markup must be valid, and &lt;&gt;&amp; characters must be escaped with
&amp;lt; &amp;gt; and &amp;amp;

Markup strings are just a convenient way to set the Pango_Attr_List on
label; Set_Attributes() may be a simpler way to set attributes in some
cases. Be careful though; Pango_Attr_List tends to cause
internationalization problems, unless you're applying attributes to the
entire string (i.e. unless you set the range of each attribute to [0,
G_MAXINT)). The reason is that specifying the start_index and end_index for
a Pango_Attribute requires knowledge of the exact string being displayed,
so translations will cause problems.

== Selectable labels ==

Labels can be made selectable with Set_Selectable. Selectable
labels allow the user to copy the label contents to the clipboard. Only
should be made selectable.
      </doc>

      <method id="gtk_label_new">
         <parameter name="str" default='""'/>
      </method>
      <method id="gtk_label_get" binding="false"/>
      <method id="gtk_label_select_region">
         <parameter name="start_offset" default="-1"/>
         <parameter name="end_offset" default="-1"/>
      </method>
      <method id="gtk_label_get_selection_bounds"
         return_as_param="Has_Selection"/>
      <method id="gtk_label_set_pattern">
         <doc>
Change the underlines pattern.

Pattern is a simple string made of underscore and space characters,
matching the ones in the string. GtkAda will underline every letter
that matches an underscore.

An empty string disables the underlines.

example: If the text is FooBarBaz and the Pattern is "___   ___"
then both "Foo" and "Baz" will be underlined, but not "Bar".
         </doc>
      </method>
   </package>

   <!-- ################################################
        Gtk.Paned
        ################################################-->

   <package id="Gtk.Paned">
      <doc screenshot="gtk-paned" testgtk="create_paned.adb"
           group="Layout container">
A Gtk_Paned is a container that organizes its two children either
horizontally or vertically.
The initial size allocated to the children depends on the size
they request. However, the user has the possibility to interactively
move a separation bar between the two to enlarge one of the children,
while at the same time shrinking the second one.
The bar can be moved by clicking with the mouse on a small cursor
displayed in the bar, and then dragging the mouse.

No additional decoration is provided around the children.

Each child has two parameters, Resize and Shrink.

If Shrink is True, then the widget can be made smaller than its
requisition size by the user. Set this to False if you want to
set a minimum size.

if Resize is True, this means that the child accepts to be resized, and
will not require any size. Thus, the size allocated to it will be
the total size allocated to the container minus the size requested by
the other child.
If Resize is False, the child should ask for a specific size, which it
will get. The other child will be resized accordingly.
If both Child have the same value for Resize (either True or False), then
the size allocated to each is a ratio between the size requested by both.

When you use Set_Position with a parameter other than -1, or the user
moves the handle to resize the widgets, the behavior of Resize is
canceled.
      </doc>
      <method id="gtk_paned_pack1">
         <parameter name="resize" default="False" />
         <parameter name="shrink" default="True" />
         <doc>
Add a child to the top or left pane.
You can not change dynamically the attributes Resize and Shrink.
Instead, you have to remove the child from the container, and put it
back with the new value of the attributes. You should also first
call Gtk.Object.Ref on the child so as to be sure it is not destroyed
when you remove it, and Gtk.Object.Unref it at the end. See the
example in testgtk/ in the GtkAda distribution.
         </doc>
      </method>
      <method id="gtk_paned_pack2">
         <parameter name="resize" default="False" />
         <parameter name="shrink" default="False" />
      </method>
      <method id="gtk_paned_add1">
         <doc>
Add the first child of the container.
The child will be displayed either in the top or in the left pane,
depending on the orientation of the container.
This is equivalent to using the Pack1 procedure with its default parameters.
         </doc>
      </method>
      <method id="gtk_paned_add2">
         <doc>
Add the second child of the container.
It will be displayed in the bottom or right pane, depending on the
container's orientation.
This is equivalent to using Pack2 with its default parameters.
         </doc>
      </method>
   </package>

   <package id="Gtk.Vpaned" into="Paned">
      <type name="Gtk_Vpaned" subtype="true"/>
      <method id="gtk_vpaned_new" ada="Gtk_New_Vpaned">
         <doc>The children will be displayed one on top of the other</doc>
      </method>
      <method id="gtk_vpaned_get_type" ada="Get_Type_Vpaned" />
   </package>

   <package id="Gtk.Hpaned" into="Paned">
      <type name="Gtk_Hpaned" subtype="true"/>
      <method id="gtk_hpaned_new" ada="Gtk_New_Hpaned">
         <doc>The children will be displayed next to each other</doc>
      </method>
      <method id="gtk_hpaned_get_type" ada="Get_Type_Hpaned" />
   </package>


   <!-- ################################################
        Gtk.Box, Gtk.Vbox, Gtk.Hbox
        ################################################-->
   <package id="Gtk.Box">
      <doc screenshot="gtk-box" testgtk="create_box.adb"
           group="Layout containers">
A box is a container that can have multiple children, organized either
horizontally or vertically. Two subtypes are provided, Gtk_Hbox and
Gtk_Vbox, to conform to the C API. In Ada, you do not need to
distinguish between the two, but note that the Gtk_Box type is conceptually
an abstract type: there is no way to create a "Gtk_Box", only ways to
create either an horizontal box, or a vertical box.

Children can be added to one of two positions in the box, either at the
beginning (ie left or top) or at the end (ie right or bottom). Each of
these positions can contain multiple widgets.

Every time a child is added to the start, it is placed to the right
(resp. the bottom) of the previous widget added to the start.

Every time a child is added to the end, it is placed to the left (resp.
the top) of the previous widget added to the end.

There are a number of parameters to specify the behavior of the box when
it is resized, and how the children should be reorganized and/or resized.

See the testgtk example in the GtkAda distribution to see concrete examples
on how all the parameters for the boxes work.
      </doc>
      <method id="gtk_box_pack_start">
         <parameter name="self" ada="In_Box"/>
         <parameter name="expand" default="True"/>
         <parameter name="fill" default="True"/>
         <parameter name="padding" default="0"/>
      </method>
      <method id="gtk_box_pack_end">
         <parameter name="self" ada="In_Box"/>
         <parameter name="expand" default="True"/>
         <parameter name="fill" default="True"/>
         <parameter name="padding" default="0"/>
      </method>

      <extra>
         <gir:method c:identifier="ada_box_get_child" name="Get_Child"
                     version="GtkAda 1.0">
            <gir:doc>Return the Num-th child of the box, or null if there is no such child</gir:doc>
            <gir:return-value>
               <gir:type name="GtkWidget" c:type="GtkWidget*"/>
            </gir:return-value>
            <gir:parameters>
               <gir:parameter name="num">
                  <gir:type name="Gint" c:type="gint"/>
               </gir:parameter>
            </gir:parameters>
         </gir:method>
      </extra>
   </package>

   <package id="Gtk.Vbox" into="Box">
      <type name="Gtk_Vbox" subtype="true"/>
      <method id="gtk_vbox_new" ada="Gtk_New_Vbox">
         <parameter name="homogeneous" default="False"/>
         <parameter name="spacing" default="0"/>
      </method>
      <method id="gtk_vbox_get_type" ada="Get_Vbox_Type" />
   </package>

   <package id="Gtk.Hbox" into="Box">
      <type name="Gtk_Hbox" subtype="true"/>
      <method id="gtk_hbox_new" ada="Gtk_New_Hbox" >
         <parameter name="homogeneous" default="False"/>
         <parameter name="spacing" default="0"/>
      </method>
      <method id="gtk_hbox_get_type" ada="Get_Hbox_Type" />
   </package>

   <!-- ########################################################
        ## Gtk.Arrow
        ########################################################-->

   <package id="Gtk.Arrow">
      <doc screenshot="gtk-arrow" testgtk="create_arrow.adb">
Gtk_Arrow should be used to draw simple arrows that need to point in one
of the four cardinal directions (up, down, left, or right). The style of
the arrow can be one of shadow in, shadow out, etched in, or etched out.
Note that these directions and style types may be ammended in versions of
Gtk to come.

Gtk_Arrow will fill any space alloted to it, but since it is inherited from
Gtk_Misc, it can be padded and/or aligned, to fill exactly the space you
desire.

Arrows are created with a call to Gtk_New. The direction or style of an
arrow can be changed after creation by using Set.
      </doc>
   </package>

   <!-- #######################################################
        ## Gtk.Viewport
        #######################################################-->

   <package id="Gtk.Viewport">
      <doc group="Scrolling">
This widget is an adapter: it can contain any child, and will make it
scrollable. Its use is not necessary inside a Gtk_Scrolled_Window, which
automatically uses a Gtk_Viewport when necessary.
      </doc>
      <method id="gtk_viewport_new">
         <parameter name="hadjustment" default="null"/>
         <parameter name="vadjustment" default="null"/>
      </method>
   </package>

   <!-- #######################################################
        ## Gtk.Pixmap
        #######################################################-->

   <package id="Gtk.Pixmap">
      <doc group="Obsolescent widgets"/>
      <method id="gtk_pixmap_set_build_insensitive">
         <doc>Whether the pixmap should be grayed out, as is done for insensitive widgets that do not accept user interaction</doc>
      </method>

      <extra>
         <with_spec pkg="Gtk.Widget" />
         <with_spec pkg="Gtk.Window" />
         <with_spec pkg="Gtkada.Types" />
         <with_body pkg="Interfaces.C.Strings" />
         <with_body pkg="Gdk.Color" />
         <method>
            <spec>
function Create_Pixmap
  (Filename : String;
   Window   : access Gtk.Window.Gtk_Window_Record'Class) return Gtk_Pixmap;
   --  Create a pixmap given a window and a filename   
            </spec>
            <body>
   Dummy_Pixmap : constant GtkAda.Types.chars_ptr_array :=
     (New_String ("1 1 1 1"),
      New_String ("c None"),
      New_String (" "));
   --  This is a dummy pixmap we use when a pixmap can't be found.

   function Create_Pixmap
     (Filename : String;
      Window   : access Gtk.Window.Gtk_Window_Record'Class) return Gtk_Pixmap
   is
      Gdkpixmap : Gdk.Pixmap.Gdk_Pixmap;
      Mask      : Gdk.Bitmap.Gdk_Bitmap;
      Pixmap    : Gtk_Pixmap;

      use Gtk.Widget;
      use Gtk.Window;

   begin
      if not Realized_Is_Set (Window) then
         Gtk.Window.Realize (Window);
      end if;

      if Filename = "" then
         Gdk.Pixmap.Create_From_Xpm_D
           (Gdkpixmap, Get_Window (Window), Mask,
            Gdk.Color.Null_Color, Dummy_Pixmap);
      else
         Gdk.Pixmap.Create_From_Xpm
           (Gdkpixmap, Get_Window (Window), Mask,
            Gdk.Color.Null_Color, Filename);
      end if;

      Gtk_New (Pixmap, Gdkpixmap, Mask);
      return Pixmap;
   end Create_Pixmap;
            </body>
         </method>
         <method>
            <spec>
function Create_Pixmap
  (Data     : Gtkada.Types.Chars_Ptr_Array;
   Window   : access Gtk.Window.Gtk_Window_Record'Class) return Gtk_Pixmap;
--  Create a pixmap given a window and a buffer.
            </spec>
            <body>
   function Create_Pixmap
     (Data   : Gtkada.Types.Chars_Ptr_Array;
      Window : access Gtk.Window.Gtk_Window_Record'Class) return Gtk_Pixmap
   is
      Gdkpixmap : Gdk.Pixmap.Gdk_Pixmap;
      Mask      : Gdk.Bitmap.Gdk_Bitmap;
      Pixmap    : Gtk_Pixmap;

      use Gtk.Widget;
      use Gtk.Window;

   begin
      if not Realized_Is_Set (Window) then
         Gtk.Window.Realize (Window);
      end if;

      Gdk.Pixmap.Create_From_Xpm_D
        (Gdkpixmap, Get_Window (Window), Mask, Gdk.Color.Null_Color, Data);
      Gtk_New (Pixmap, Gdkpixmap, Mask);

      return Pixmap;
   end Create_Pixmap;
            </body>
         </method>
      </extra>
   </package>

</GIR>
