<?xml version="1.0"?>

<!--  This file overrides parts of the .gir files. -->

<GIR xmlns:gir="http://www.gtk.org/introspection/core/1.0"
     xmlns:c="http://www.gtk.org/introspection/c/1.0">

   <!-- ################################################
        Gdk.Device
        ################################################-->

   <package id="Gdk.Device">
      <enum ctype="GdkDeviceType" />
      <method id="gdk_device_get_axis" bind="False" /><!-- need support for array of gdoubles -->
      <method id="gdk_device_get_axis_value" bind="False" /><!-- need support for array of gdoubles -->
      <method id="gdk_device_get_history" bind="False" /><!-- need support for array of Gdk_Time_Coord -->
      <method id="gdk_device_free_history" bind="False" /><!-- no need while we don't bind get_history -->
      <method id="gdk_device_grab_info_libgtk_only" bind="False" /><!-- not part of library -->
      <method id="gdk_device_get_key" return="" bind="False"/><!-- pending L118-010 -->
      <method id="gdk_device_get_window_at_position" bind="False"/><!-- below -->
      <method id="gdk_device_get_position" bind="False"/><!-- pending resolution of a problem with generating the stub object -->
      <method id="gdk_device_grab" bind="False"/><!-- no support for Gdk_Grab_Ownership yet -->
      <method id="gdk_device_list_axes" bind="False"/><!-- no support for atom lists -->
      <method id="gdk_device_list_slave_devices" bind="False"/><!-- no support for Gdk_Device_Type_Master lists -->
      <extra>
         <spec>
   procedure Get_Window_At_Position
      (Self   : not null access Gdk_Device_Record;
       Win_X  : out Gint;
       Win_Y  : out Gint;
       Window : out Gdk.Window.Gdk_Window);
   --  Obtains the window underneath Device, returning the location of the
   --  device in Win_X and Win_Y. Returns null if the window tree under Device
   --  is not known to GDK (for example, belongs to another application).
   --  As a slave device coordinates are those of its master pointer, This
   --  function may not be called on devices of type
   --  Gdk.Device.Gdk_Device_Type_Slave, unless there is an ongoing grab on
   --  them, see Gdk.Device.Grab.
   --  Since: gtk+ 3.0
   --  "win_x": return location for the X coordinate of the device location,
   --  relative to the window origin, or null.
   --  "win_y": return location for the Y coordinate of the device location,
   --  relative to the window origin, or null.
         </spec>
         <body>
   procedure Get_Window_At_Position
      (Self   : not null access Gdk_Device_Record;
       Win_X  : out Gint;
       Win_Y  : out Gint;
       Window : out Gdk.Window.Gdk_Window)
   is
      function Internal
         (Self      : System.Address;
          Acc_Win_X : access Gint;
          Acc_Win_Y : access Gint) return Gdk.Window.Gdk_Window;
      pragma Import (C, Internal, "gdk_device_get_window_at_position");
      Acc_Win_X  : aliased Gint;
      Acc_Win_Y  : aliased Gint;
      Tmp_Return : Gdk.Window.Gdk_Window;
   begin
      Tmp_Return := Internal (Get_Object (Self), Acc_Win_X'Access, Acc_Win_Y'Access);
      Win_X := Acc_Win_X;
      Win_Y := Acc_Win_Y;
      Window :=  Tmp_Return;
   end Get_Window_At_Position;
         </body>
      </extra>
   </package>

   <!-- ################################################
        Gdk.Drag_Contexts
        ################################################-->

   <package id="Gdk.Drag_Contexts">
      <enum ctype="GdkDragAction" prefix="GDK_"/>
      <enum ctype="GdkDragProtocol" prefix="GDK_"/>
      <method id="gdk_drag_context_list_targets" bind="False"/><!-- not supposed to be used by applications -->
   </package>

   <!-- ################################################
        Gdk.Screen
        ################################################-->

   <package id="Gdk.Screen">
     <doc  group="Gdk, the low-level API"/>
     <parameter name="self" ada="Screen"/>
     <method id="gdk_screen_get_setting" bind="False" />
     <method id="gdk_screen_get_toplevel_windows" return="WindowList" />
     <method id="gdk_screen_get_window_stack" return="WindowList" />
     <method id="gdk_screen_list_visuals" return="WindowList" />
     <extra>
       <with_spec pkg="Gdk.Types" />
       <spec>
   -------------
   -- Display --
   -------------
   --  These subprograms should really be in gdk-display.ads to match what is
   --  done for gtk+ itself, but that would create dependency circularities.
   --  Ada 2005 has support for these, but we want GtkAda to build with Ada95
   --  compilers.

   function Get_Screen
     (Display    : access Gdk.Display.Gdk_Display_Record'Class;
      Screen_Num : Glib.Gint)
      return Gdk_Screen;
   --  Returns a screen object for one of the screens of the display.

   function Get_Default_Screen
     (Display : access Gdk.Display.Gdk_Display_Record'Class) return Gdk_Screen;
   --  Get the default Gdk_Screen for display.

   procedure Get_Pointer
     (Display : access Gdk.Display.Gdk_Display_Record'Class;
      Screen  : out Gdk_Screen;
      X       : out Glib.Gint;
      Y       : out Glib.Gint;
      Mask    : out Gdk.Types.Gdk_Modifier_Type);
   --  Gets the current location of the pointer and the current modifier
   --  mask for a given display.
   --  (X, Y) are coordinates relative to the root window on the display

   procedure Warp_Pointer
     (Display : access Gdk.Display.Gdk_Display_Record'Class;
      Screen  : access Gdk_Screen_Record;
      X       : Glib.Gint;
      Y       : Glib.Gint);
   --  Warps the pointer of display to the point x,y on the screen screen,
   --  unless the pointer is confined to a window by a grab, in which case it
   --  will be moved as far as allowed by the grab. Warping the pointer creates
   --  events as if the user had moved the mouse instantaneously to the
   --  destination.
   --
   --  Note that the pointer should normally be under the control of the user.
   --  This function was added to cover some rare use cases like keyboard
   --  navigation support for the color picker in the GtkColorSelectionDialog.
       </spec>
       <body>
   function Get_Screen
     (Display    : access Gdk_Display_Record'Class;
      Screen_Num : Gint)
      return Gdk_Screen
   is
      function Internal
        (Display    : System.Address;
         Screen_Num : Gint)
         return System.Address;
      pragma Import (C, Internal, "gdk_display_get_screen");
      --  External binding: gdk_display_get_screen
      Stub : Gdk_Screen_Record;
   begin
      return Gdk_Screen
        (Get_User_Data
          (Internal (Get_Object (Display), Screen_Num), Stub));
   end Get_Screen;

   function Get_Default_Screen
     (Display : access Gdk_Display_Record'Class)
      return Gdk_Screen
   is
      function Internal
        (Display : System.Address)
         return System.Address;
      pragma Import (C, Internal, "gdk_display_get_default_screen");
      --  External binding: gdk_display_get_default_screen
      Stub : Gdk_Screen_Record;
   begin
      return Gdk_Screen
        (Get_User_Data
          (Internal (Get_Object (Display)), Stub));
   end Get_Default_Screen;

   procedure Get_Pointer
     (Display : access Gdk_Display_Record'Class;
      Screen  : out Gdk_Screen;
      X       : out Gint;
      Y       : out Gint;
      Mask    : out Gdk_Modifier_Type)
   is
      procedure Internal
        (Display : System.Address;
         Screen  : out System.Address;
         X       : out Gint;
         Y       : out Gint;
         Mask    : out Gdk_Modifier_Type);
      pragma Import (C, Internal, "gdk_display_get_pointer");
      --  External binding: gdk_display_get_pointer

      S    : System.Address;
      Stub : Gdk_Screen_Record;

   begin
      Internal (Get_Object (Display), S, X, Y, Mask);
      Screen := Gdk_Screen (Get_User_Data (S, Stub));
   end Get_Pointer;

   procedure Warp_Pointer
     (Display : access Gdk.Display.Gdk_Display_Record'Class;
      Screen  : access Gdk_Screen_Record;
      X       : Glib.Gint;
      Y       : Glib.Gint)
   is
      procedure Internal (D, S : System.Address; X, Y : Gint);
      pragma Import (C, Internal, "gdk_display_warp_pointer");
      --  External binding: gdk_display_warp_pointer
   begin
      Internal (Get_Object (Display), Get_Object (Screen), X, Y);
   end Warp_Pointer;
       </body>
     </extra>
   </package>

   <!-- ################################################
        Gtk.Aspect_Frame
        ################################################-->

   <package id="Gtk.Aspect_Frame">
     <doc testgtk="create_frame.adb" group="Layout Containers"/>
     <parameter name="self" ada="Aspect_Frame"/>
     <method id="gtk_aspect_frame_new">
       <parameter name="label" default='""' allow-none="1"/>
     </method>
   </package>

   <!-- ###################################################
        Gtk.Button
        ###################################################-->

   <package id="Gtk.Button">
      <doc screenshot="gtk-button" group="Buttons and Toggles"
           testgtk="create_buttons.adb"/>
      <parameter name="self" ada="Button"/>
      <method id="gtk_button_new" bind="False"/>
      <method id="gtk_button_new_with_label" ada="Gtk_New" >
         <parameter name="label" default='""' allow-none="1"/>
      </method>
   </package>

   <!-- ###################################################
        Gtk.Cell_Area
        ###################################################-->

   <package id="Gtk.Cell_Area">
      <doc group="Layout Containers"/>
      <method id="gtk_cell_area_cell_get_valist" bind="False"/><!-- va_list -->
      <method id="gtk_cell_area_cell_set_valist" bind="False"/><!-- va_list -->
      <method id="gtk_cell_area_add_with_properties" bind="False"/><!-- varargs-->
      <method id="gtk_cell_area_cell_get" bind="False"/><!-- varargs-->
      <method id="gtk_cell_area_cell_set" bind="False"/><!-- varargs-->
      <method id="gtk_cell_area_get_cell_allocation">
         <parameter name="cell_area" direction="access" />
         <parameter name="allocation" direction="access" />
      </method>
      <method id="gtk_cell_area_get_focus_siblings" return="ObjectList"/>
      <method id="gtk_cell_area_get_cell_at_position" bind="False"/>
      <!-- bound manually below -->
      <extra>
        <spec>
   function Get_Area
      (Context : access Gtk_Cell_Area_Context_Record)
       return Gtk.Cell_Area.Gtk_Cell_Area;
   --  Fetches the Gtk.Cell_Area.Gtk_Cell_Area this Context was created by.
   --  This is generally unneeded by layouting widgets; however it is important
   --  for the context implementation itself to fetch information about the
   --  area it is being used for.
   --  For instance at GtkCellAreaContextClass.allocate time its important to
   --  know details about any cell spacing that the Gtk.Cell_Area.Gtk_Cell_Area
   --  is configured with in order to compute a proper allocation.
   --  Since: gtk+ 3.0

   function Get_Area
      (Cell_Layout : Gtk_Cell_Layout) return Gtk.Cell_Area.Gtk_Cell_Area;
   --  Returns the underlying Gtk.Cell_Area.Gtk_Cell_Area which might be
   --  Cell_Layout if called on a Gtk.Cell_Area.Gtk_Cell_Area or might be null
   --  if no Gtk.Cell_Area.Gtk_Cell_Area is used by Cell_Layout.
   --  Since: gtk+ 3.0

   procedure Get_Cell_At_Position
      (Self       : access Gtk_Cell_Area_Record;
       Context    : access Gtk.Cell_Area_Context.Gtk_Cell_Area_Context_Record'Class;
       Widget     : access Gtk.Widget.Gtk_Widget_Record'Class;
       Cell_Area  : Gdk.Rectangle.Gdk_Rectangle;
       X          : Gint;
       Y          : Gint;
       Alloc_Area : out Gdk.Rectangle.Gdk_Rectangle;
       Renderer   : out Gtk.Cell_Renderer.Gtk_Cell_Renderer);
   --  Gets the Gtk.Cell_Renderer.Gtk_Cell_Renderer at X and Y coordinates
   --  inside Area and optionally returns the full cell allocation for it
   --  inside Cell_Area.
   --  Since: gtk+ 3.0
   --  "context": the Gtk.Cell_Area_Context.Gtk_Cell_Area_Context used to hold
   --  sizes for Area.
   --  "widget": the Gtk.Widget.Gtk_Widget that Area is rendering on
   --  "cell_area": the whole allocated area for Area in Widget for this row
   --  "x": the x position
   --  "y": the y position
   --  "alloc_area": where to store the inner allocated area of the returned
   --  cell renderer, or null.
   --  "renderer": the rendered that was found.
        </spec>
        <body>
   --------------
   -- Get_Area --
   --------------

   function Get_Area
      (Context : access Gtk_Cell_Area_Context_Record)
       return Gtk.Cell_Area.Gtk_Cell_Area
   is
      function Internal (Context : System.Address) return System.Address;
      pragma Import (C, Internal, "gtk_cell_area_context_get_area");
      Stub_Gtk_Cell_Area : Gtk.Cell_Area.Gtk_Cell_Area_Record;
   begin
      return Gtk.Cell_Area.Gtk_Cell_Area
        (Get_User_Data (Internal (Get_Object (Context)), Stub_Gtk_Cell_Area));
   end Get_Area;

   --------------
   -- Get_Area --
   --------------

   function Get_Area
      (Cell_Layout : Gtk_Cell_Layout) return Gtk.Cell_Area.Gtk_Cell_Area
   is
      function Internal
         (Cell_Layout : Gtk_Cell_Layout) return System.Address;
      pragma Import (C, Internal, "gtk_cell_layout_get_area");
      Stub_Gtk_Cell_Area : Gtk.Cell_Area.Gtk_Cell_Area_Record;
   begin
      return Gtk.Cell_Area.Gtk_Cell_Area (Get_User_Data (Internal (Cell_Layout), Stub_Gtk_Cell_Area));
   end Get_Area;

   --------------------------
   -- Get_Cell_At_Position --
   --------------------------

   procedure Get_Cell_At_Position
      (Self       : access Gtk_Cell_Area_Record;
       Context    : access Gtk.Cell_Area_Context.Gtk_Cell_Area_Context_Record'Class;
       Widget     : access Gtk.Widget.Gtk_Widget_Record'Class;
       Cell_Area  : Gdk.Rectangle.Gdk_Rectangle;
       X          : Gint;
       Y          : Gint;
       Alloc_Area : out Gdk.Rectangle.Gdk_Rectangle;
       Renderer   : out Gtk.Cell_Renderer.Gtk_Cell_Renderer)
   is
      function Internal
         (Self           : System.Address;
          Context        : System.Address;
          Widget         : System.Address;
          Cell_Area      : Gdk.Rectangle.Gdk_Rectangle;
          X              : Gint;
          Y              : Gint;
          Acc_Alloc_Area : access Gdk.Rectangle.Gdk_Rectangle)
          return System.Address;
      pragma Import (C, Internal, "gtk_cell_area_get_cell_at_position");
      Acc_Alloc_Area         : aliased Gdk.Rectangle.Gdk_Rectangle;
      Stub_Gtk_Cell_Renderer : Gtk.Cell_Renderer.Gtk_Cell_Renderer_Record;
      Tmp_Return             : System.Address;
   begin
      Tmp_Return := Internal
        (Get_Object (Self), Get_Object (Context), Get_Object (Widget),
         Cell_Area, X, Y, Acc_Alloc_Area'Access);
      Alloc_Area := Acc_Alloc_Area;
      Renderer := Gtk.Cell_Renderer.Gtk_Cell_Renderer
        (Get_User_Data (Tmp_Return, Stub_Gtk_Cell_Renderer));
   end Get_Cell_At_Position;
        </body>
      </extra>
   </package>


   <!-- ###################################################
        Gtk.Cell_Area_Context
        ###################################################-->

   <package id="Gtk.Cell_Area_Context">
      <doc group="Layout Containers"/>
      <method id="gtk_cell_area_context_get_area" bind="False"/>
      <!-- in Gtk.Cell_Area -->
   </package>

   <!-- ################################################
        Gtk.Color_Selection
        ################################################-->

   <package id="Gtk.Color_Selection">
      <doc testgtk="create_color_selection.adb"
           screenshot="gtk-colorsel"
           group="Drawing">
A Gtk_Color_Selection widget is a complex dialog that allows the user
to select a color based either on its (Red, Green, Blue) or its
(Hue, Saturation, Value).
An additional field is provided to select the opacity of the color (this
is usually called the alpha channel).

See Gtk.Color_Selection_Dialog for a version of this widget that comes with
its own dialog.

See Gtk.Extra.Color_Combo for a different way to select colors.
      </doc>
     <parameter name="self" ada="Colorsel"/>

     <!-- Bound manually below -->
     <method id="gtk_color_selection_palette_from_string" bind="False"/>
     <method id="gtk_color_selection_palette_to_string" bind="False"/>

     <extra>
        <spec>
   type Gtk_Color_Selection_Change_Palette_With_Screen_Func is access procedure
      (Screen   : Gdk.Gdk_Screen;
       Colors   : Gdk.Color.Gdk_Color_Unconstrained_Array;
       N_Colors : Gint);
   pragma Convention (C, Gtk_Color_Selection_Change_Palette_With_Screen_Func);
   --  This function should save the new palette contents, and update the
   --  Gtk_Settings property "gtk-color-palette" so all Gtk_Color_Selection
   --  widgets will be modified, including the current one. For instance, you
   --  would do:
   --    Set_String_Property
   --      (Get_Default, Gtk_Color_Palette, Palette_To_String (Colors), "Foo");

   function Palette_From_String
     (Str : String) return Gdk.Color.Gdk_Color_Array;
   --  Parses a color palette string. This string is a colon-separated list of
   --  color names readable by Gdk.Color.Parse.
   --  An empty array is returned if Str couldn't be parsed

   function Palette_To_String
     (Colors   : Gdk.Color.Gdk_Color_Array) return String;
   --  Encodes a palette as a string, useful for persistent storage.
        </spec>

        <with_body pkg="GtkAda.C"/>
        <with_body pkg="Interfaces.C.Strings"/>

        <body>
   package Color_Arrays is new Gtkada.C.Unbounded_Arrays
     (Gdk.Color.Gdk_Color, Gdk.Color.Null_Color, Natural,
      Gdk.Color.Gdk_Color_Array);

   function Palette_From_String (Str : String) return Gdk_Color_Array is
      use Color_Arrays;
      function Internal
        (Str : String;
         Colors : access Unbounded_Array_Access; N : access Gint)
         return Gboolean;
      pragma Import (C, Internal, "gtk_color_selection_palette_from_string");

      N      : aliased Gint;
      Output : aliased Unbounded_Array_Access;
   begin
      if Internal (Str &amp; ASCII.NUL, Output'Access, N'Access) = 0 then
         Output := null;
      end if;

      declare
         Result : constant Gdk_Color_Array := To_Array (Output, Integer (N));
      begin
         G_Free (Output);
         return Result;
      end;
   end Palette_From_String;

   function Palette_To_String (Colors : Gdk_Color_Array) return String is
      function Internal
        (Colors   : System.Address;
         N_Colors : Gint)
         return Interfaces.C.Strings.chars_ptr;
      pragma Import (C, Internal, "gtk_color_selection_palette_to_string");
      Str : chars_ptr;
   begin
      if Colors'Length = 0 then
         return "";
      else
         Str := Internal (Colors (Colors'First)'Address, Colors'Length);
         declare
            Result : constant String := Value (Str);
         begin
            Free (Str);
            return Result;
         end;
      end if;
   end Palette_To_String;
       </body>
     </extra>
   </package>

   <!-- ################################################
        Gtk.Color_Selection_Dialog
        ################################################-->

   <package id="Gtk.Color_Selection_Dialog">
      <doc group="Drawing">
The Gtk_Color_Selection_Dialog provides a standard dialog which allows the
user to select a color much like the Gtk_File_Selection provides a standard
dialog for file selection.
      </doc>
     <parameter name="self" ada="Color_Selection_Dialog"/>
     <method id="gtk_color_selection_dialog_get_color_selection"
         return="GtkColorSelection">
     </method>
   </package>

   <!-- ################################################
        Gtk.Combo_Box
        ################################################-->

   <package id="Gtk.Combo_Box">
     <doc group="Numeric/Text Data Entry"/>
     <parameter name="self" ada="Combo_Box"/>
     <method id="gtk_combo_box_popup_for_device" bind="False" />
     <method id="gtk_combo_box_get_popup_accessible" bind="False" />
     <method id="gtk_combo_box_get_active_iter" bind="False"/> <!-- below-->
     <extra>
        <spec>
   function Get_Active_Iter
     (Combo_Box : access Gtk_Combo_Box_Record)
      return Gtk.Tree_Model.Gtk_Tree_Iter;
        </spec>
        <body>
   function Get_Active_Iter
     (Combo_Box : access Gtk_Combo_Box_Record) return Gtk_Tree_Iter
   is
      function Internal
        (Combo_Box : System.Address;
         Iter      : System.Address)
         return Gboolean;
      pragma Import (C, Internal, "gtk_combo_box_get_active_iter");
      Iter : aliased Gtk_Tree_Iter;
      Tmp  : constant Gboolean := Internal
        (Get_Object (Combo_Box), Iter'Address);
   begin
      if Tmp /= 0 then
         return Iter;
      else
         return Null_Iter;
      end if;
   end Get_Active_Iter;
        </body>
     </extra>
   </package>

   <!-- ################################################
        Gtk.Combo_Box_Text
        ################################################-->

   <package id="Gtk.Combo_Box_Text">
     <doc group="Numeric/Text Data Entry"/>
   </package>

   <!-- ################################################
        Gtk.EventBox
        ################################################-->

   <package id="Gtk.Event_Box">
     <doc group="Layout Containers"/>
     <parameter name="self" ada="Event_Box"/>
     <method id="gtk_event_box_new">
         <doc>
Create a new box.

The box's child can then be set using the Gtk.Container.Add function.
         </doc>
     </method>
   </package>


   <!-- ################################################
        Gtk.Font_Selection
        ################################################-->

   <package id="Gtk.Font_Selection">
      <doc testgtk="create_font_selection.adb"
           screenshot="gtk-fontsel"
           group="Selectors">
This widget provides a nice way for the user of your application to
select fonts.
It first searches on your system for the list of fonts available, and
displays a set of boxes to select them based on their name, their
weight, their size, etc.
This widget is provided in two forms, one widget that can be embedded
in any container, a Gtk_Font_Selection, whereas the other one comes
directly in its own separate window (to be popped up as a dialog).

Some filters can be applied to the widget, when you want the user to
select only a font only among a specific subset (like bitmap or
true-type fonts for instance).
There are two kinds of filters: a base filter, set in your application
and that the user can not change; a user filter that can be modified
interactively by the user.
      </doc>
     <parameter name="self" ada="Fontsel"/>
     <method id="gtk_font_selection_get_family" bind="False"/>
     <method id="gtk_font_selection_get_face" bind="False"/>
   </package>

   <!-- ################################################
        Gtk.Font_Selection_Dialog
        ################################################-->

   <package id="Gtk.Font_Selection_Dialog">
      <doc testgtk="create_font_selection.adb"
           screenshot="gtk-fontsel"
           group="Selectors">
This widget provides a dialog for selecting a font.
See also Gtk.Font_Selection.
      </doc>
     <parameter name="self" ada="Dialog"/>
   </package>

   <!-- ###################################################
        Gtk.Frame
        ###################################################-->
   <package id="Gtk.Frame">
      <doc screenshot="gtk-frame" testgtk="create_frame.adb"
           group="Ornaments">
This is a very convenient widget to visually group related widgets (like
groups of buttons for instance), possibly with a title to explain the
purpose of this group.

A Gtk_Frame has only one child, so you have to put a container like for
instance a Gtk_Box inside if you want the frame to surround multiple
widgets.
      </doc>
      <parameter name="self" ada="Frame"/>

      <method id="gtk_frame_new">
         <parameter name="label" default='""' allow-none="1"/>
      </method>
   </package>

   <!-- ################################################
        Gtk.Label
        ################################################-->

   <package id="Gtk.Label">
      <doc screenshot="gtk-label" testgtk="create_label.adb"
           group="Display widgets"/>
      <parameter name="self" ada="Label"/>
      <method id="gtk_label_new">
         <parameter name="str" default='""'/>
      </method>
      <method id="gtk_label_get" bind="false"/>
      <method id="gtk_label_select_region">
         <parameter name="start_offset" default="-1"/>
         <parameter name="end_offset" default="-1"/>
      </method>
      <method id="gtk_label_get_selection_bounds"
         return_as_param="Has_Selection"/>
      <method id="gtk_label_set_pattern">
         <doc>
Change the underlines pattern.

Pattern is a simple string made of underscore and space characters,
matching the ones in the string. GtkAda will underline every letter
that matches an underscore.

An empty string disables the underlines.

example: If the text is FooBarBaz and the Pattern is "___   ___"
then both "Foo" and "Baz" will be underlined, but not "Bar".
         </doc>
      </method>
   </package>

   <!-- ###################################################
        Gtk.Notebook
        ###################################################-->

   <package id="Gtk.Notebook">
      <doc screenshot="gtk-notebook" group="Layout containers"
           testgtk="create_notebook.adb"/>
      <parameter name="self" ada="Notebook"/>
      <method id="gtk_notebook_set_scrollable">
         <parameter name="scrollable" default="True" />
      </method>
      <method id="gtk_notebook_set_tab_reorderable">
         <parameter name="reorderable" default="True" />
      </method>
      <method id="gtk_notebook_set_current_page">
         <parameter name="page_num" default="-1" />
      </method>
      <method id="gtk_notebook_set_show_border">
         <parameter name="show_border" default="True" />
      </method>
      <method id="gtk_notebook_append_page_menu" return="void" />
      <method id="gtk_notebook_set_show_tabs">
         <parameter name="show_tabs" default="True" />
      </method>
      <method id="gtk_notebook_set_tab_detachable">
         <parameter name="detachable" default="True" />
      </method>
      <extra>
        <spec>
   procedure Append_Page
     (Notebook  : access Gtk_Notebook_Record;
      Child     : access Gtk.Widget.Gtk_Widget_Record'Class);
   procedure Append_Page
     (Notebook  : access Gtk_Notebook_Record;
      Child     : access Gtk.Widget.Gtk_Widget_Record'Class;
      Tab_Label : access Gtk.Widget.Gtk_Widget_Record'Class);
   procedure Prepend_Page
     (Notebook  : access Gtk_Notebook_Record;
      Child     : access Gtk.Widget.Gtk_Widget_Record'Class;
      Tab_Label : access Gtk.Widget.Gtk_Widget_Record'Class);
   --  Convenience functions, same as above but discarding the return value.
        </spec>
        <body>
   procedure Append_Page
     (Notebook  : access Gtk_Notebook_Record;
      Child     : access Gtk.Widget.Gtk_Widget_Record'Class)
   is
      Ignored : Gint;
      pragma Unreferenced (Ignored);
   begin
      Ignored := Append_Page (Notebook, Child, null);
   end Append_Page;

   procedure Append_Page
     (Notebook  : access Gtk_Notebook_Record;
      Child     : access Gtk.Widget.Gtk_Widget_Record'Class;
      Tab_Label : access Gtk.Widget.Gtk_Widget_Record'Class)
   is
      Ignored : Gint;
      pragma Unreferenced (Ignored);
   begin
      Ignored := Append_Page (Notebook, Child, Tab_Label);
   end Append_Page;

   procedure Prepend_Page
     (Notebook  : access Gtk_Notebook_Record;
      Child     : access Gtk.Widget.Gtk_Widget_Record'Class;
      Tab_Label : access Gtk.Widget.Gtk_Widget_Record'Class)
   is
      Ignored : Gint;
      pragma Unreferenced (Ignored);
   begin
      Ignored := Append_Page (Notebook, Child, Tab_Label);
   end Prepend_Page;
        </body>
      </extra>
   </package>

   <!-- ################################################
        Gtk.Paned
        ################################################-->

   <package id="Gtk.Paned">
      <doc screenshot="gtk-paned" testgtk="create_paned.adb"
           group="Layout container"/>
      <parameter name="self" ada="Paned"/>
      <method id="gtk_paned_pack1">
         <parameter name="self" ada="Paned"/>
         <parameter name="resize" default="False" />
         <parameter name="shrink" default="True" />
         <doc>
Add a child to the top or left pane.
You can not change dynamically the attributes Resize and Shrink.
Instead, you have to remove the child from the container, and put it
back with the new value of the attributes. You should also first
call Glib.Object.Ref on the child so as to be sure it is not destroyed
when you remove it, and Glib.Object.Unref it at the end. See the
example in testgtk/ in the GtkAda distribution.
         </doc>
      </method>
      <method id="gtk_paned_pack2">
         <parameter name="self" ada="Paned"/>
         <parameter name="resize" default="False" />
         <parameter name="shrink" default="False" />
      </method>
      <method id="gtk_paned_add1">
         <parameter name="self" ada="Paned"/>
         <doc>
Add the first child of the container.
The child will be displayed either in the top or in the left pane,
depending on the orientation of the container.
This is equivalent to using the Pack1 procedure with its default parameters.
         </doc>
      </method>
      <method id="gtk_paned_add2">
         <parameter name="self" ada="Paned"/>
         <doc>
Add the second child of the container.
It will be displayed in the bottom or right pane, depending on the
container's orientation.
This is equivalent to using Pack2 with its default parameters.
         </doc>
      </method>
   </package>

   <package id="Gtk.Vpaned" into="GtkPaned">
      <type name="Gtk_Vpaned" subtype="true"/>
      <parameter name="self" ada="Paned"/>
      <method id="gtk_vpaned_new" ada="Gtk_New_Vpaned">
         <doc>The children will be displayed one on top of the other</doc>
      </method>
      <method id="gtk_vpaned_get_type" ada="Get_Type_Vpaned" />
   </package>

   <package id="Gtk.Hpaned" into="GtkPaned">
      <type name="Gtk_Hpaned" subtype="true"/>
      <parameter name="self" ada="Paned"/>
      <method id="gtk_hpaned_new" ada="Gtk_New_Hpaned">
         <doc>The children will be displayed next to each other</doc>
      </method>
      <method id="gtk_hpaned_get_type" ada="Get_Type_Hpaned" />
   </package>


   <!-- ################################################
        Gtk.Box, Gtk.Vbox, Gtk.Hbox
        ################################################-->
   <package id="Gtk.Box">
      <doc screenshot="gtk-box" testgtk="create_box.adb"
           group="Layout containers">
See the testgtk example in the GtkAda distribution to see concrete examples
on how all the parameters for the boxes work.
      </doc>
      <method id="gtk_box_pack_start">
         <parameter name="self" ada="In_Box"/>
         <parameter name="expand" default="True"/>
         <parameter name="fill" default="True"/>
         <parameter name="padding" default="0"/>
      </method>
      <method id="gtk_box_pack_end">
         <parameter name="self" ada="In_Box"/>
         <parameter name="expand" default="True"/>
         <parameter name="fill" default="True"/>
         <parameter name="padding" default="0"/>
      </method>
      <parameter name="self" ada="Box"/>

      <extra>
         <gir:method c:identifier="ada_box_get_child" name="Get_Child"
                     version="GtkAda 1.0">
            <gir:doc>Return the Num-th child of the box, or null if there is no such child</gir:doc>
            <gir:return-value>
               <gir:type name="GtkWidget" c:type="GtkWidget*"/>
            </gir:return-value>
            <gir:parameters>
               <gir:parameter name="num">
                  <gir:type name="Gint" c:type="gint"/>
               </gir:parameter>
            </gir:parameters>
         </gir:method>
      </extra>
   </package>

   <package id="Gtk.Vbox" into="GtkBox">
      <type name="Gtk_Vbox" subtype="true"/>
      <method id="gtk_vbox_new" ada="Gtk_New_Vbox">
         <parameter name="homogeneous" default="False"/>
         <parameter name="spacing" default="0"/>
      </method>
      <parameter name="self" ada="Box"/>
      <method id="gtk_vbox_get_type" ada="Get_Vbox_Type" />
   </package>

   <package id="Gtk.Hbox" into="GtkBox">
      <type name="Gtk_Hbox" subtype="true"/>
      <method id="gtk_hbox_new" ada="Gtk_New_Hbox" >
         <parameter name="homogeneous" default="False"/>
         <parameter name="spacing" default="0"/>
      </method>
      <parameter name="self" ada="Box"/>
      <method id="gtk_hbox_get_type" ada="Get_Hbox_Type" />
   </package>

   <package id="Gtk.Scale">
      <doc group="Numeric/Text Data Entry" screenshot="gtk-scale.png"/>
      <parameter name="self" ada="Scale"/>
   </package>
   <package id="Gtk.Vscale" into="GtkScale">
      <parameter name="self" ada="Scale"/>
      <type name="Gtk_Vscale" subtype="true"/>
      <method id="gtk_vscale_new" ada="Gtk_New_Vscale">
         <parameter name="adjustment" default="null"/>
      </method>
      <method id="gtk_vscale_new_with_range" ada="Gtk_New_Vscale"/>
      <method id="gtk_vscale_get_type" ada="Vscale_Get_Type" />
   </package>
   <package id="Gtk.Hscale" into="GtkScale">
      <parameter name="self" ada="Scale"/>
      <type name="Gtk_Hscale" subtype="true"/>
      <method id="gtk_hscale_new" ada="Gtk_New_Hscale">
         <parameter name="adjustment" default="null"/>
      </method>
      <method id="gtk_hscale_new_with_range" ada="Gtk_New_Hscale"/>
      <method id="gtk_hscale_get_type" ada="Hscale_Get_Type" />
   </package>

   <!-- ########################################################
        ## Gtk.Arrow
        ########################################################-->

   <package id="Gtk.Arrow">
      <doc screenshot="gtk-arrow" testgtk="create_arrow.adb"/>
      <parameter name="self" ada="Arrow"/>
   </package>

   <!-- #######################################################
        ## Gtk.Viewport
        #######################################################-->

   <package id="Gtk.Viewport">
      <doc group="Scrolling"/>
      <parameter name="self" ada="Viewport"/>
      <method id="gtk_viewport_new">
         <parameter name="hadjustment" default="null"/>
         <parameter name="vadjustment" default="null"/>
      </method>

      <!-- These are now inherited from the Scrollable interface -->
      <method id="gtk_viewport_get_hadjustment" bind="false"/>
      <method id="gtk_viewport_get_vadjustment" bind="false"/>
      <method id="gtk_viewport_set_hadjustment" bind="false"/>
      <method id="gtk_viewport_set_vadjustment" bind="false"/>
   </package>

   <!-- #######################################################
        ## Gtk.Pixmap
        #######################################################-->

   <package id="Gtk.Pixmap">
      <doc group="Obsolescent widgets"/>
      <parameter name="self" ada="Pixmap"/>
      <parameter name="pixmap" ada="Val"/>
      <method id="gtk_pixmap_set_build_insensitive">
         <doc>Whether the pixmap should be grayed out, as is done for insensitive widgets that do not accept user interaction</doc>
      </method>

      <extra>
         <with_spec pkg="Gtk.Widget" />
         <with_spec pkg="Gtk.Window" />
         <with_spec pkg="Gtkada.Types" />
         <with_body pkg="Interfaces.C.Strings" />
         <with_body pkg="Gdk.Color" />
         <spec>
   function Create_Pixmap
     (Filename : String;
      Window   : access Gtk.Window.Gtk_Window_Record'Class) return Gtk_Pixmap;
      --  Create a pixmap given a window and a filename

   function Create_Pixmap
     (Data     : Gtkada.Types.Chars_Ptr_Array;
      Window   : access Gtk.Window.Gtk_Window_Record'Class) return Gtk_Pixmap;
   --  Create a pixmap given a window and a buffer.
            </spec>
            <body>
   Dummy_Pixmap : constant GtkAda.Types.chars_ptr_array :=
     (New_String ("1 1 1 1"),
      New_String ("c None"),
      New_String (" "));
   --  This is a dummy pixmap we use when a pixmap can't be found.

   function Create_Pixmap
     (Filename : String;
      Window   : access Gtk.Window.Gtk_Window_Record'Class) return Gtk_Pixmap
   is
      Gdkpixmap : Gdk.Pixmap.Gdk_Pixmap;
      Mask      : Gdk.Bitmap.Gdk_Bitmap;
      Pixmap    : Gtk_Pixmap;

      use Gtk.Widget;
      use Gtk.Window;

   begin
      if not Realized_Is_Set (Window) then
         Gtk.Window.Realize (Window);
      end if;

      if Filename = "" then
         Gdk.Pixmap.Create_From_Xpm_D
           (Gdkpixmap, Get_Window (Window), Mask,
            Gdk.Color.Null_Color, Dummy_Pixmap);
      else
         Gdk.Pixmap.Create_From_Xpm
           (Gdkpixmap, Get_Window (Window), Mask,
            Gdk.Color.Null_Color, Filename);
      end if;

      Gtk_New (Pixmap, Gdkpixmap, Mask);
      return Pixmap;
   end Create_Pixmap;

   function Create_Pixmap
     (Data   : Gtkada.Types.Chars_Ptr_Array;
      Window : access Gtk.Window.Gtk_Window_Record'Class) return Gtk_Pixmap
   is
      Gdkpixmap : Gdk.Pixmap.Gdk_Pixmap;
      Mask      : Gdk.Bitmap.Gdk_Bitmap;
      Pixmap    : Gtk_Pixmap;

      use Gtk.Widget;
      use Gtk.Window;

   begin
      if not Realized_Is_Set (Window) then
         Gtk.Window.Realize (Window);
      end if;

      Gdk.Pixmap.Create_From_Xpm_D
        (Gdkpixmap, Get_Window (Window), Mask, Gdk.Color.Null_Color, Data);
      Gtk_New (Pixmap, Gdkpixmap, Mask);

      return Pixmap;
   end Create_Pixmap;
         </body>
      </extra>
   </package>

   <package id="Gtk.Misc">
      <doc group="Abstract base classes"/>
      <parameter name="self" ada="Misc"/>
      <method id="gtk_misc_set_alignment">
         <doc>
Modify the alignment for the widget.
Xalign and Yalign are both values between 0.0 and 1.0 that specify the
alignment: if Xalign is 0.0, the widget will be left aligned; if it is
0.5, the widget will be centered; if it is 1.0 the widget will be
right aligned. Yalign is from top (0.0) to bottom (1.0).
Both Xalign and Yalign will be constrained to the range 0.0 .. 1.0
Note that if the widget fills its allocated area, these two parameters
won't have any effect.
         </doc>
      </method>
   </package>

   <package id="Gtk.Bin">
      <doc group="Abstract base classes"/>
      <parameter name="self" ada="Bin"/>
   </package>

   <!-- #################################################################
        Gtk.Layout
        ################################################################ -->

   <package id="Gtk.Layout">
      <doc group="Layout containers" testgtk="create_layout.adb"
           screenshot="gtk-layout">
A Gtk_Layout is a widget that can have an almost infinite size, without
occupying a lot of memory. Its children can be located anywhere within
it, but will only appear on the screen if the visible area of the layout
contains them.
Just like a Gtk_Viewport, its visible area is indicated by two
Gtk_Adjustment widgets, and thus a Gtk_Layout can be put as is in a
Gtk_Scrolled_Window.
As for Gtk_Fixed containers, the children can be located anywhere in the
layout (no automatic organization is done). But, as opposed to Gtk_Fixed
widgets, a Gtk_Layout does not try to resize itself to show all its
children.

Starting from GtkAda 2.0, you have to call Set_Size and specify the maximum
size of the layout, otherwise children added with Put outside the size
defined for the layout will never be visible.
One way to do this is to systematically call Set_Size before calling Put,
and make sure you specify a size big enough for the layout.
      </doc>
      <parameter name="self" ada="Layout"/> <!-- for all methods -->
      <method id="gtk_layout_new">
         <parameter name="hadjustment" default="null"/>
         <parameter name="vadjustment" default="null"/>
      </method>
      <method id="gtk_layout_put">
         <doc>The child will be displayed on the screen only if at least part of it intersects the visible area of the layout. The layout does not resize itself to automatically show the widget. You also need to call Set_Size, if the size you initially defined is smaller than (X, Y), or the child will never be visible even if the layout is scrolled.</doc>
      </method>

      <!-- These are now inherited from the Scrollable interface -->
      <method id="gtk_layout_get_hadjustment" bind="false"/>
      <method id="gtk_layout_get_vadjustment" bind="false"/>
      <method id="gtk_layout_set_hadjustment" bind="false"/>
      <method id="gtk_layout_set_vadjustment" bind="false"/>
   </package>

   <package id="Gtk.GRange">
      <doc testgtk="create_range.adb" screenshot="gtk-range"/>
      <parameter name="self" ada="The_Range"/>
   </package>

   <package id="Gtk.Button_Box">
      <doc testgtk="create_button_box.adb" screenshot="gtk-button_box"
           group="Layout containers">
A Gtk_Button_Box is a special type of Gtk_Box specially tailored to contain
buttons.

This is only a base class for Gtk_Hbutton_Box and Gtk_Vbutton_Box which
provide a way to arrange their children horizontally (resp. vertically).
You can not instantiate a Gtk_Button_Box directly, and have to use one the
above two instead.
      </doc>
      <parameter name="self" ada="Widget"/>
   </package>

   <package id="Gtk.Hbutton_Box">
      <doc group="Layout containers">
A Gtk_Hbutton_Box is a specific Gtk_Button_Box that organizes its
children horizontally.
The beginning of the box (when you add children with Gtk.Box.Pack_Start)
is on the left of the box. Its end (for Gtk.Box.Pack_End) is on the right.
      </doc>
      <parameter name="self" ada="Widget"/>
   </package>

   <package id="Gtk.Vbutton_Box">
      <doc group="Layout containers">
A Gtk_Vbutton_Box is a specific Gtk_Button_Box that organizes its
children vertically.
The beginning of the box (when you add children with Gtk.Box.Pack_Start)
is on the top of the box. Its end (for Gtk.Box.Pack_End) is on the bottom.
      </doc>
      <parameter name="self" ada="Widget"/>
   </package>

   <package id="Gtk.Volume_Button">
      <parameter name="self" ada="Widget"/>
   </package>

   <package id="Gtk.About_Dialog">
      <doc group="Windows" testgtk="create_about.adb"/>
      <parameter name="self" ada="About"/>
      <enum ctype="GtkLicense"/>
  </package>

  <package id="Gtk.GEntry">
     <doc testgtk="create_entry.adb" group="Numeric/Text Data Entry"
          screenshot="gtk-gentry">
A Gtk_Entry is a single line text editing widget.
The text is automatically scrolled if it is longer than can be displayed
on the screen, so that the cursor position is visible at all times.

See Gtk_Text_View for a multiple-line text editing widget.
     </doc>
     <parameter name="self" ada="The_Entry"/>
     <enum ctype="GtkEntryIconPosition" prefix=""/>

     <method id="gtk_entry_set_invisible_char">
        <parameter name="ch" ada="Char"/>
     </method>
     <method id="gtk_entry_set_has_frame">
        <parameter name="setting" default="True"/>
     </method>
     <method id="gtk_entry_set_width_chars">
        <parameter name="n_chars" ada="Width"/>
     </method>

     <extra>
        <spec>subtype Gtk_GEntry is Gtk_Entry;</spec>
        <spec>
   procedure Insert_Text
      (Editable : access Gtk_Entry_Record;
       New_Text : UTF8_String;
       Position : in out Gint);
   --  Convenience subprogram, identical to Insert_Text above without
   --  the requirement to supply the New_Text_Length argument.
        </spec>
        <body>
   procedure Insert_Text
      (Editable : access Gtk_Entry_Record;
       New_Text : UTF8_String;
       Position : in out Gint) is
   begin
      Insert_Text
        (Editable, New_Text &amp; ASCII.NUL, New_Text'Length, Position);
   end Insert_Text;
        </body>
     </extra>
  </package>

  <package id="Gtk.Dialog">
     <doc group="Windows" testgtk="create_dialog.adb"
          screenshot="gtk-dialog">
          See Gtkada.Dialogs for a higher level dialog interface.
     </doc>
     <parameter name="self" ada="Dialog" />
     <parameter name="response_id" type="Gtk_Response_Type"/>
     <method id="gtk_dialog_get_action_area" return="GtkBox*"/>
     <method id="gtk_dialog_get_content_area" return="GtkBox*"/>
     <method id="gtk_dialog_get_response_for_widget" return="GtkResponseType"/>
     <method id="gtk_dialog_run" return="GtkResponseType"/>
     <method id="gtkada_GtkDialog_get_vbox" bind="true" return="GtkBox*"/>
     <method id="gtk_dialog_add_button">
        <parameter name="button_text" ada="text"/>
     </method>

     <!-- Bound manually below -->
     <method id="gtk_dialog_set_alternative_button_order_from_array" bind="False"/>

     <!-- Following methods have varargs -->
     <method id="gtk_dialog_new_with_buttons" bind="False"/>
     <method id="gtk_dialog_add_buttons" bind="False"/>
     <method id="gtk_dialog_set_alternative_button_order" bind="False"/>

     <method id="ada_gtk_dialog_new_with_buttons">
        <parameter name="parent" default="null"/>
     </method>

     <extra>
        <gir:constructor c:identifier="ada_gtk_dialog_new_with_buttons"
             name="new" version="GtkAda 1.0">
             <gir:doc>Create a new dialog with a specific title, and specific attributes. Parent is the transient parent for the dialog (ie the one that is used for reference for the flag Destroy_With_Parent, or to compute the initial position of the dialog).</gir:doc>
           <gir:return-value>
              <gir:type name="GtkDialog" c:type="GtkDialog*"/>
           </gir:return-value>
           <gir:parameters>
              <gir:parameter name="title">
                 <gir:type name="utf8" c:type="gchar*"/>
              </gir:parameter>
              <gir:parameter name="parent">
                 <gir:type name="Window" c:type="GtkWindow*"/>
              </gir:parameter>
              <gir:parameter name="flags">
                 <gir:type name="DialogFlags" c:type="GtkDialogFlags"/>
              </gir:parameter>
           </gir:parameters>
        </gir:constructor>

        <spec>
   procedure Set_Alternative_Button_Order_From_Array
     (Dialog    : access Gtk_Dialog_Record;
      New_Order : Response_Type_Array);
   --  Sets an alternative button order. If the gtk-alternative-button-order
   --  setting is set to %TRUE, the dialog buttons are reordered according to
   --  the order of the response ids passed to this function.
   --
   --  By default, GTK+ dialogs use the button order advocated by the Gnome
   --  Human Interface Guidelines with the affirmative button at the far right,
   --  and the cancel button left of it. But the builtin GTK+ dialogs and
   --  message dialogs' do provide an alternative button order, which is more
   --  suitable on some platforms, e.g. Windows.
   --
   --  Use this function after adding all the buttons to your dialog.

   function Gtk_Alternative_Dialog_Button_Order
     (Screen : Gdk.Gdk_Screen := null)  return Boolean;
   --  Returns True if dialogs are expected to use an alternative button order
   --  on the given screen (or current screen if null) . See
   --  Set_Alternative_Button_Order_From_Array for more details about
   --  alternative button order.
   --
   --  If you need to use this function, you should probably connect to the
   --  ::notify:gtk-alternative-button-order signal on the Gtk_Settings object
   --  associated to Screen, in order to be notified if the button order
   --  setting changes.
   --
   --  Returns: Whether the alternative button order should be used
        </spec>
        <body>
   procedure Set_Alternative_Button_Order_From_Array
     (Dialog    : access Gtk_Dialog_Record;
      New_Order : Response_Type_Array)
   is
      procedure Internal
        (Dialog    : System.Address;
         N_Params  : Gint;
         New_Order : System.Address);
      pragma Import
        (C, Internal, "gtk_dialog_set_alternative_button_order_from_array");
   begin
      Internal (Get_Object (Dialog), New_Order'Length,
                New_Order (New_Order'First)'Address);
   end Set_Alternative_Button_Order_From_Array;

   function Gtk_Alternative_Dialog_Button_Order
     (Screen : Gdk.Gdk_Screen := null) return Boolean
   is
      function Internal (Screen : Gdk.Gdk_Screen) return Gboolean;
      pragma Import (C, Internal, "gtk_alternative_dialog_button_order");
   begin
      return Boolean'Val (Internal (Screen));
   end Gtk_Alternative_Dialog_Button_Order;
        </body>

        <type ctype="GtkDialogFlags" ada="Gtk_Dialog_Flags">
   type Gtk_Dialog_Flags is mod 8;
   for Gtk_Dialog_Flags'Size use Gint'Size;
   pragma Convention (C, Gtk_Dialog_Flags);
   Modal               : constant Gtk_Dialog_Flags := 2 ** 0;
   Destroy_With_Parent : constant Gtk_Dialog_Flags := 2 ** 1;
   No_Separator        : constant Gtk_Dialog_Flags := 2 ** 2;
   --  Various flags that can be set for the dialog, with the following
   --  implications:
   --     - Modal : the dialog is modal, see Gtk.Window.Set_Modal
   --     - Destroy_With_Parent: The dialog is destroyed if its parent is
   --       destroyed. See Gtk.Window.Set_Destroy_With_Parent
   --     - No_Separator: No separator bar above the buttons.
        </type>

        <type ctype="GtkResponseType" ada="Gtk_Response_Type">
   type Gtk_Response_Type is new Gint;
   --  Type used for Response_Id's.
   --  Positive values are totally user-interpreted.
   --  GtkAda will sometimes return Gtk_Response_None if no Response_Id is
   --  available.
   --
   --  Typical usage is:
   --    if Gtk.Dialog.Run (Dialog) = Gtk_Response_Accept then
   --       blah;
   --    end if;

   Gtk_Response_None : constant Gtk_Response_Type := -1;
   --  GtkAda returns this if a response widget has no Response_Id,
   --  or if the dialog gets programmatically hidden or destroyed.

   Gtk_Response_Reject : constant Gtk_Response_Type := -2;
   Gtk_Response_Accept : constant Gtk_Response_Type := -3;
   --  GtkAda won't return these unless you pass them in
   --  as the response for an action widget. They are
   --  for your convenience.

   Gtk_Response_Delete_Event : constant Gtk_Response_Type := -4;
   --  If the dialog is deleted through the button in the titlebar

   Gtk_Response_OK     : constant Gtk_Response_Type := -5;
   Gtk_Response_Cancel : constant Gtk_Response_Type := -6;
   Gtk_Response_Close  : constant Gtk_Response_Type := -7;
   Gtk_Response_Yes    : constant Gtk_Response_Type := -8;
   Gtk_Response_No     : constant Gtk_Response_Type := -9;
   Gtk_Response_Apply  : constant Gtk_Response_Type := -10;
   Gtk_Response_Help   : constant Gtk_Response_Type := -11;
   --  These are returned from dialogs, and you can also use them
   --  yourself if you like.
        </type>

        <type ctype="GtkResponseType*" ada="Response_Type_Array">
   type Response_Type_Array is array (Natural range &lt;&gt;) of Gtk_Response_Type;
        </type>
     </extra>
  </package>

  <package id="Gtk.Curve">
     <doc group="Drawing">
The Gtk_Curve widget allows the user to edit a curve covering a range of values. It is typically used to fine-tune color balances in graphics applications like the Gimp.

The Gtk_Curve widget has 3 modes of operation: spline, linear and free.  In spline mode the user places points on the curve which are automatically connected together into a smooth curve. In linear mode the user places points on the curve which are connected by straight lines. In free mode the user can draw the points of the curve freely, and they are not connected at all.
     </doc>
     <parameter name="self" ada="Curve"/>
     <method id="gtk_curve_set_vector" bind="False"/>
     <method id="gtk_curve_get_vector" bind="False"/>
     <method id="gtk_curve_set_gamma">
        <doc>Recompute the entire curve using the given gamma value. A gamma value of 1.0 results in a straight line. Values greater than 1.0 result in a curve above the straight line. Values less than 1.0 result in a curve below the straight line. The curve type is changed to Curve_Type_Free.</doc>
     </method>
     <method id="gtk_curve_set_range">
        <doc>Set the minimum and maximum x &amp; y values of the curve. The curve is also reset with a call to Reset.</doc>
     </method>
     <method id="gtk_curve_set_curve_type">
        <doc>Set the type of the curve. The curve will remain unchanged except when changing from a free curve to a linear or spline curve, in which case the curve will be changed as little as possible.</doc>
     </method>
     <method id="gtk_curve_reset">
        <doc>Reset the curve. Reset to a straight line from the minimum x &amp; y values to the maximum x &amp; y values (i.e. from the bottom-left to the top-right corners). The curve type is not changed.</doc>
     </method>

     <extra>
        <spec>
   procedure Set_Vector
     (Curve  : access Gtk_Curve_Record; Vector : Gfloat_Array);
   procedure Get_Vector
     (Curve  : access Gtk_Curve_Record; Vector : out Gfloat_Array);
   --  Set the vector of points on the curve.
   --  The curve type is set to Curve_Type_Free.
       </spec>
       <body>
   procedure Get_Vector
     (Curve  : access Gtk_Curve_Record;
      Vector : out Gfloat_Array)
   is
      procedure Internal
        (Curve  : System.Address;
         Veclen : Integer;
         Vector : System.Address);
      pragma Import (C, Internal, "gtk_curve_get_vector");

   begin
      Internal (Get_Object (Curve), Vector'Length, Vector'Address);
   end Get_Vector;

   procedure Set_Vector
     (Curve  : access Gtk_Curve_Record;
      Vector : Gfloat_Array)
   is
      procedure Internal
        (Curve  : System.Address;
         Veclen : Integer;
         Vector : System.Address);
      pragma Import (C, Internal, "gtk_curve_set_vector");

   begin
      Internal (Get_Object (Curve), Vector'Length,
                Vector (Vector'First)'Address);
   end Set_Vector;
       </body>
    </extra>
  </package>

  <package id="Gtk.Expander">
     <doc group="Layout containers" screenshot="gtk-expanded"/>
     <parameter name="self" ada="Expander"/>
  </package>

  <package id="Gtk.Drawing_Area">
     <doc group="Drawing" testgtk="libart_demo.adb">
See also the Double_Buffer widget provided in the GtkAda examples for an advanced example that demonstrates how to use double buffering, to avoid flickering in your drawings.</doc>
     <parameter name="self" ada="Drawing_Area"/>
  </package>

  <package id="Gtk.Adjustment">
     <doc group="Scrolling">
The meaning of the most important fields can be explained on the following figure (imagine this is a scrollbar):

[-------|=================|-------------------]

lower    value        value + page_size       upper
     </doc>
     <parameter name="self" ada="Adjustment"/>
     <method id="gtk_adjustment_new">
        <parameter name="page_size" default="0.0"/>
        <doc>Create a new adjustment. Value is the initial value of the adjustment. It must be in the range (Lower .. Upper) and the adjustment's value will never be outside this range. Step_Increment is the value used to make minor adjustments, such as when the user clicks on the arrows of a scrollbar. Page_Increment is used to make major adjustments, such as when the user clicks in the through on a scrollbar. Page_Size is deprecated, use the default value.</doc>
     </method>
     <method id="gtk_adjustment_clamp_page">
        <doc>Update the Adjustment value to ensure that the range between Lower and Upper is in the current page (i.e. between value and value + page_size). If the range is larger than the page size, then only the start of it will be in the current page. A "value_changed" signal will be emitted if the value is changed.</doc>
     </method>
  </package>

  <package id="Gtk.Image">
     <doc group="Display widgets" screenshot="gtk-image"/>
     <parameter name="self" ada="Image"/>
     <parameter name="image" ada="Val"/>
     <parameter name="size" type="Gtk.Enums.Gtk_Icon_Size"/>
     <method id="gtk_image_new_from_animation" ada="Gtk_New"/>
     <method id="gtk_image_new_from_file"      ada="Gtk_New"/>
     <method id="gtk_image_new_from_image"     ada="Gtk_New"/>
     <method id="gtk_image_new_from_pixbuf"    ada="Gtk_New"/>
     <method id="gtk_image_new_from_icon_set"  ada="Gtk_New"/>
     <method id="gtk_image_new_from_pixmap"    ada="Gtk_New"/>
     <method id="gtk_image_new_from_stock"     ada="Gtk_New"/>
     <method id="gtk_image_get_animation"      ada="Get"/>
     <method id="gtk_image_set_from_animation" ada="Set"/>
     <method id="gtk_image_get_image"          ada="Get"/>
     <method id="gtk_image_get" bind="False"/> <!-- same as get_image -->
     <method id="gtk_image_set_from_image"     ada="Set"/>
     <method id="gtk_image_set" bind="False"/> <!-- same as set_from_image -->
     <method id="gtk_image_get_pixbuf"         ada="Get"/>
     <method id="gtk_image_set_from_pixbuf"    ada="Set"/>
     <method id="gtk_image_get_icon_set"       ada="Get"/>
     <method id="gtk_image_set_from_icon_set"  ada="Set"/>
     <method id="gtk_image_get_pixmap"         ada="Get"/>
     <method id="gtk_image_set_from_pixmap"    ada="Set"/>
     <method id="gtk_image_get_stock"          ada="Get" bind="False"/>
     <method id="gtk_image_set_from_stock"     ada="Set"/>
     <method id="gtk_image_get_gicon"          ada="Get"/>
     <method id="gtk_image_set_from_gicon"     ada="Set"/>
     <method id="gtk_image_set_from_file"      ada="Set"/>
     <method id="gtk_image_get_icon_name"      ada="Get" bind="False"/>
     <enum ctype="GtkImageType"/>
     <extra>
        <with_spec pkg="GNAT.Strings"/>
        <spec>
   function Get
     (Image : access Gtk_Image_Record;
      Size  : access Gtk.Enums.Gtk_Icon_Size) return String;
   --  Get the stock_id for the image displayed

   procedure Get_Icon_Name
     (Image : access Gtk_Image_Record;
      Name  : out GNAT.Strings.String_Access;
      Size  : out Gtk.Enums.Gtk_Icon_Size);
        </spec>
        <body>
   procedure Get_Icon_Name
     (Image : access Gtk_Image_Record;
      Name  : out GNAT.Strings.String_Access;
      Size  : out Gtk_Icon_Size)
   is
      procedure Internal
        (Image : System.Address;
         Name  : out Interfaces.C.Strings.chars_ptr;
         Size  : out Gtk_Icon_Size);
      pragma Import (C, Internal, "gtk_image_get_icon_name");
      Str : chars_ptr;
   begin
      Internal (Get_Object (Image), Str, Size);
      Name := new String'(Value (Str));
   end Get_Icon_Name;

   function Get
     (Image : access Gtk_Image_Record;
      Size  : access Gtk.Enums.Gtk_Icon_Size) return String
   is
      procedure Internal
        (Image    : System.Address;
         Stock_Id : out Interfaces.C.Strings.chars_ptr;
         Size     : out Gint);
      pragma Import (C, Internal, "gtk_image_get_stock");

      Stock : Interfaces.C.Strings.chars_ptr;
      Sze   : Gint;

   begin
      Internal (Get_Object (Image), Stock, Sze);
      Size.all := Gtk.Enums.Gtk_Icon_Size'Val (Sze);
      return Interfaces.C.Strings.Value (Stock);
   end Get;
        </body>
     </extra>
  </package>

  <package id="Gtk.Calendar">
     <doc group="Selectors" testgtk="create_calendar.adb"
          screenshot="gtk-calendar"/>
     <parameter name="self" ada="Calendar"/>
     <enum ctype="GtkCalendarDisplayOptions" prefix="GTK_CALENDAR_"/>
  </package>

  <package id="Gtk.Size_Group">
     <doc testgtk="create_size_groups.adb"/>
     <parameter name="self" ada="Size_Group" />
     <method id="gtk_size_group_new">
        <parameter name="mode" default="Both"/>
     </method>
     <method id="gtk_size_group_get_widgets" return="WidgetSList"/>
     <enum ctype="GtkSizeGroupMode" ada="Size_Group_Mode" prefix="GTK_SIZE_GROUP_"/>
  </package>

  <package id="Gtk.Alignment">
     <doc testgtk="create_alignment.adb" screenshot="gtk-alignment"/>
     <parameter name="self" ada="Alignment"/>
     <method id="gtkada_GtkAlignment_get_xalign" bind="True"/>
     <method id="gtkada_GtkAlignment_get_xscale" bind="True"/>
     <method id="gtkada_GtkAlignment_get_yalign" bind="True"/>
     <method id="gtkada_GtkAlignment_get_yscale" bind="True"/>
  </package>

  <package id="Gtk.Status_Bar">
     <doc group="Display widgets" testgtk="create_status.adb"
          screenshot="gtk-status_bar"/>
     <parameter name="self" ada="Statusbar"/>
     <parameter name="context" type="Context_Id"/>
     <parameter name="context_id" ada="context" type="Context_Id"/>
     <parameter name="message_id" ada="Message" type="Message_Id"/>
     <method id="gtk_statusbar_get_context_id" return="Context_Id"/>
     <method id="gtkada_GtkStatusbar_get_messages" return="MessagesList"
             bind="True"/>
     <method id="gtk_statusbar_push" return="Message_Id"/>
     <extra>
        <type>
   type Context_Id is new Guint;
   type Message_Id is new Guint;
        </type>
     </extra>
  </package>

  <package id="Gtk.Table">
     <doc group="Layout containers"/>
     <parameter name="self" ada="Table"/>
     <method id="gtk_table_new">
        <doc>Create a new table. The width allocated to the table is divided into Columns columns, which all have the same width if Homogeneous is True. If Homogeneous is False, the width will be calculated with the children contained in the table. Same behavior for the rows.</doc>
     </method>
     <method id="gtk_table_attach">
        <doc>Insert a new widget in the table. All the attachments are relative to the separations between columns and rows (for instance, to insert a widget spanning the first two columns in the table, you should put Left_Attach=0 and Right_Attach=2). Same behavior for the rows. Xoptions and Yoptions indicate the behavior of the child when the table is resized (whether the child can shrink or expand). See the description in Gtk.Box for more information on the possible values. Xpadding and Ypadding are the amount of space left around the child.</doc>
        <parameter name="xoptions" default="Expand or Fill"/>
        <parameter name="yoptions" default="Expand or Fill"/>
        <parameter name="xpadding" default="0"/>
        <parameter name="ypadding" default="0"/>
     </method>
     <method id="gtk_table_attach_defaults">
        <doc>Insert a new widget in the table, with default values. No padding is put around the child, and the options are set to Expand and Fill. This call is similar to Attach with default values and is only provided for compatibility.</doc>
     </method>
     <method id="gtk_table_set_col_spacing">
        <doc>Set the spacing in pixels between Column and the next one.</doc>
     </method>
     <method id="gtk_table_set_homogeneous">
        <doc>Indicate the homogeneous status of the table. If Homogeneous is True, the rows and columns of the table will all be allocated the same width or height.</doc>
     </method>
  </package>

  <package id="Gtk.Check_Button">
     <doc screenshot="gtk-check_button" group="Buttons and Toggles"
        testgtk="create_check_buttons.adb"/>
     <parameter name="self" ada="Check_Button"/>
     <method id="gtk_check_button_new" bind="False"/>
     <method id="gtk_check_button_new_with_label" ada="Gtk_New" >
        <parameter name="label" default='""' allow-none="1"/>
        <doc>Create a check button. if Label is null, then no widget is associated with the button, and any widget can be added to the button (with Gtk.Container.Add).</doc>
     </method>
  </package>

  <package id="Gtk.Toggle_Button">
     <doc screenshot="gtk-toggle_button" group="Buttons and Toggles"
          testgtk="create_toggle_buttons.adb">
You should consider using a Gtk_Check_Button instead, since it looks nicer and provides more visual clues that the button can be toggled.
     </doc>
     <parameter name="self" ada="Toggle_Button"/>
     <method id="gtk_toggle_button_new" bind="False"/>
     <method id="gtk_toggle_button_new_with_label" ada="Gtk_New" >
        <doc>Initialize a button. If Label is "", then no label is created inside the button and you will have to provide your own child through a call to Gtk.Container.Add. This is the recommended way to put a pixmap inside a toggle button.</doc>
        <parameter name="label" default='""' allow-none="1"/>
     </method>
     <method id="gtk_toggle_button_set_active">
        <doc>Change the state of the button. When Is_Active is True, the button is drawn as a pressed button</doc>
     </method>
     <method id="gtk_toggle_button_set_inconsistent">
        <parameter name="Setting" default="True"/>
     </method>
  </package>

  <package id="Gtk.Accel_Group">
     <parameter name="self" ada="Accel_Group"/>
     <method id="gtk_accel_group_new">
        <doc>Creates a new Gtk.Accel_Group.Gtk_Accel_Group.
Remember to call Gtk.Window.Add_Accel_Group to active the group.</doc>
     </method>
     <method id="gtk_accel_group_connect">
        <parameter name="closure" type="C_Gtk_Accel_Group_Activate"/>
     </method>
     <method id="gtk_accel_group_disconnect">
        <parameter name="closure" type="C_Gtk_Accel_Group_Activate"/>
     </method>
     <method id="gtk_accel_group_connect_by_path">
        <parameter name="closure" type="C_Gtk_Accel_Group_Activate"/>
     </method>
     <method id="gtk_accel_group_query" bind="False"/>
        <!-- ???Would be nice -->
     <method id="gtk_accel_group_from_accel_closure">
        <parameter name="closure" type="C_Gtk_Accel_Group_Activate"/>
     </method>
     <function id="gtk_accel_groups_activate">
        <parameter name="accel_key" type="Gdk.Types.Gdk_Key_Type"/>
     </function>
     <function id="gtk_accel_groups_from_object" ada="From_Object"
               return="ObjectSList"/>
     <function id="gtk_accelerator_valid">
        <parameter name="keyval" type="Gdk.Types.Gdk_Key_Type"/>
     </function>
     <function id="gtk_accelerator_parse">
        <parameter name="accelerator_key" ctype="GdkKeyType*"/>
     </function>
     <function id="gtk_accelerator_name">
        <parameter name="accelerator_key" type="Gdk.Types.Gdk_Key_Type"/>
     </function>
     <function id="gtk_accelerator_get_label">
        <parameter name="accelerator_key" type="Gdk.Types.Gdk_Key_Type"/>
     </function>
     <function id="gtk_accelerator_set_default_mod_mask"
               ada="Set_Default_Mod_Mask" />
     <function id="gtk_accelerator_get_default_mod_mask"
               return="GdkModifierType" ada="Get_Default_Mod_Mask"/>
     <enum ctype="GtkAccelFlags" prefix="GTK_"/>
     <record ctype="GtkAccelKey">
       <field name="accel_key" ctype="GdkKeyType"/>
       <field name="accel_flags" ctype="GtkAccelFlags"/>
     </record>
     <extra>
        <type ctype="GtkAccelGroupActive" ada="Gtk_Accel_Group_Activate">
   type Gtk_Accel_Group_Activate is access function
     (Accel_Group   : access Gtk_Accel_Group_Record'Class;
      Acceleratable : Glib.Object.GObject;
      Keyval        : Gdk.Types.Gdk_Key_Type;
      Modifier      : Gdk.Types.Gdk_Modifier_Type) return Boolean;

   type C_Gtk_Accel_Group_Activate is access function
     (Accel_Group   : System.Address;
      Acceleratable : System.Address;
      Keyval        : Gdk.Types.Gdk_Key_Type;
      Modifier      : Gdk.Types.Gdk_Modifier_Type) return Boolean;
   pragma Convention (C, C_Gtk_Accel_Group_Activate);
   --  Same as Gtk_Accel_Group_Activate, but passing directly the C values.
   --  You must use Get_User_Data to convert to the Ada types.
        </type>
     </extra>
  </package>

  <package id="Gtk.Radio_Button">
     <doc screenshot="gtk-radio_button" group="Buttons and Toggles"
          testgtk="create_radio_button.adb"/>
     <parameter name="self" ada="Radio_Button"/>
     <parameter name="radio_group_member" ada="Group"/>
     <method id="gtk_radio_button_new" bind="False"/>
     <method id="gtk_radio_button_new_from_widget" bind="False"/>
     <method id="gtk_radio_button_new_with_label" ada="Gtk_New" >
        <doc>Creates or initializes a new radio button, belonging to Group. If Label is left as the empty string, then the button will not have any child and you are free to put any thing you want in it, including a pixmap. To initialize the group (when creating the first button), leave Group to the Null_List. You can later get the new group that is created with a call to the Group subprogram below.</doc>
        <parameter name="group" default="Widget_SList.Null_List" ctype="WidgetSList"/>
        <parameter name="label" default='""' allow-none="1"/>
     </method>
     <method id="gtk_radio_button_new_with_label_from_widget" ada="Gtk_New" >
        <parameter name="radio_group_member" allow-none="1"/>
        <parameter name="label" default='""' allow-none="1"/>
     </method>
     <method id="gtk_radio_button_new_with_mnemonic">
        <parameter name="group" default="Widget_SList.Null_List" ctype="WidgetSList"/>
     </method>
     <method id="gtk_radio_button_new_with_mnemonic_from_widget" ada="Gtk_New_With_Mnemonic">
        <doc extend="true">To initialize a new group (when creating the first button), you should pass it null or a button that has not been created with Gtk_New, as in the example below.</doc>
        <parameter name="radio_group_member" allow-none="1"/>
     </method>
     <method id="gtk_radio_button_get_group" return="WidgetSList"/>
     <method id="gtk_radio_button_set_group">
        <parameter name="group" ctype="WidgetSList"/>
     </method>
  </package>

  <package id="Gtk.Radio_Action">
     <doc group="Action-based menus" see="Gtk_Action"/>
     <parameter name="self" ada="Action"/>
     <method id="gtk_radio_action_new">
        <parameter name="label" default='""'/>
        <parameter name="tooltip" default='""'/>
        <parameter name="stock_id" default='""'/>
     </method>
     <method id="gtk_radio_action_set_group">
        <parameter name="group" ctype="WidgetSList"/>
        <doc extend="true">A common way to set up a group of radio group is the following:

%PRE%      Group  : GSlist := null;
      Action : Gtk_Radio_Action;
      while ... loop
         Gtk_New (Action, ...);
         Set_Group (Action, Group);
         Group := Get_Group (Action);
      end loop;</doc>
     </method>
     <method id="gtk_radio_action_get_group" return="WidgetSList"/>
  </package>

  <package id="Gtk.Separator">
      <doc group="Ornaments" screenshot="gtk-separator"/>
      <parameter name="self" ada="Separator"/>
  </package>
  <package id="Gtk.Vseparator" into="GtkSeparator">
      <type name="Gtk_Vseparator" subtype="true"/>
      <method id="gtk_vseparator_new" ada="Gtk_New_Vseparator"/>
      <parameter name="self" ada="Separator"/>
      <method id="gtk_vseparator_get_type" ada="Vseparator_Get_Type" />
  </package>
  <package id="Gtk.Hseparator" into="GtkSeparator">
      <type name="Gtk_Hseparator" subtype="true"/>
      <method id="gtk_hseparator_new" ada="Gtk_New_Hseparator"/>
      <parameter name="self" ada="Separator"/>
      <method id="gtk_hseparator_get_type" ada="Hseparator_Get_Type" />
  </package>

  <package id="Gtk.Separator_Menu_Item">
     <doc group="Menus and Toolbars"/>
     <parameter name="self" ada="Widget" />
  </package>

  <package id="Gtk.Separator_Tool_Item">
     <doc group="Menus and Toolbars"/>
     <parameter name="self" ada="Item" />
  </package>

  <package id="Gtk.Ruler">
     <doc group="Drawing" testgtk="create_rulers.adb"
          screenshot="gtk-rulers">
 This widget is generally put on the sides of a drawing area to help the user measure distances. It indicates the current position of the mouse cursor within the drawing area, and can be graduated in multiple units.</doc>
     <parameter name="self" ada="Ruler" />
     <method id="gtk_ruler_set_metric">
        <doc>Set or get the units used for a Gtk_Ruler. See Set_Metric</doc>
     </method>
  </package>
  <package id="Gtk.Vruler" into="GtkRuler">
      <type name="Gtk_Vruler" subtype="true"/>
      <method id="gtk_vruler_new" ada="Gtk_New_Vruler"/>
      <parameter name="self" ada="Ruler"/>
      <method id="gtk_vruler_get_type" ada="Vruler_Get_Type" />
  </package>
  <package id="Gtk.Hruler" into="GtkRuler">
      <type name="Gtk_Hruler" subtype="true"/>
      <method id="gtk_hruler_new" ada="Gtk_New_Hruler"/>
      <parameter name="self" ada="Ruler"/>
      <method id="gtk_hruler_get_type" ada="Hruler_Get_Type" />
  </package>

  <package id="Gtk.Fixed">
      <doc group="Layout containers" testgtk="create_fixed.adb"
           screenshot="gtk-fixed"/>
      <parameter name="self" ada="Fixed" />
      <method id="gtk_fixed_put">
         <doc>Add Widget to a Fixed container at the given position. X indicates the horizontal position to place the widget at. Y is the vertical position to place the widget at.</doc>
      </method>
      <method id="gtk_fixed_move">
         <doc>Move a child of a GtkFixed container to the given position. X indicates the horizontal position to place the widget at. Y is the vertical position to place the widget at.</doc>
      </method>
      <method id="gtk_fixed_set_has_window">
         <parameter name="has_window" default="False"/>
      </method>
  </package>

  <package id="Gtk.Cell_Editable">
     <doc group="Trees and Lists"/>
     <parameter name="self" ada="Cell_Editable"/>
  </package>

  <package id="Gtk.Buildable">
     <method id="gtk_buildable_custom_tag_start" bind="False"/>
  </package>

  <package id="Gtk.File_Chooser">
     <doc group="Selectors">
This package provides an interface implemented by Gtk.File_Chooser_Widget and Gtk.File_Chooser_Button, and by your own file selection widgets if you wish to expose a standard interface.

Gtk_File_Chooser allows for shortcuts to various places in the filesystem.  In the default implementation these are displayed in the left pane. It may be a bit confusing at first that these shortcuts come from various sources and in various flavours, so lets explain the terminology here:

%PRE%  - Bookmarks
    are created by the user, by dragging folders from the right pane to the
    left pane, or by using the "Add". Bookmarks can be renamed and deleted
    by the user.
  - Shortcuts
    can be provided by the application or by the underlying filesystem
    abstraction (e.g. both the gnome-vfs and the Windows filesystems
    provide "Desktop" shortcuts). Shortcuts cannot be modified by the user.
  - Volumes
    are provided by the underlying filesystem abstraction. They are the
    "roots" of the filesystem.

File Names and Encodings

When the user is finished selecting files in a Gtk_File_Chooser, your program can get the selected names either as filenames or as URIs. For URIs, the normal escaping rules are applied if the URI contains non-ASCII characters. However, filenames are always returned in the character set specified by the G_FILENAME_ENCODING environment variable. Please see the Glib documentation for more details about this variable.

Important: This means that while you can pass the result of Get_Filename to low-level file system primitives , you will need to convert it to UTF-8 before using it in a Gtk_Label for instance. Conversion is done through Glib.Convert.Filename_To_UTF8.

You can add a custom preview widget to a file chooser and then get notification about when the preview needs to be updated. To install a preview widget, use gtk_file_chooser_set_preview_widget(). Then, connect to the GtkFileChooser::update-preview signal to get notified when you need to update the contents of the preview.

Preview widgets

You can add a custom preview widget to a file chooser and then get notification about when the preview needs to be updated. To install a preview widget, use Set_Preview_Widget. Then, connect to the GtkFileChooser::update-preview signal to get notified when you need to
update the contents of the preview.

Your callback should use Get_Preview_Filename to see what needs previewing.  Once you have generated the preview for the corresponding file, you must call Set_Preview_Widget_Active with a boolean flag that indicates whether your callback could successfully generate a preview.

Adding Extra Widgets

You can add extra widgets to a file chooser to provide options that are not present in the default design. For example, you can add a toggle button to give the user the option to open a file in read-only mode. You can use Set_Extra_Widget to insert additional widgets in a file chooser.

If you want to set more than one extra widget in the file chooser, you can a container such as a GtkVBox or a GtkTable and include your widgets in it.  Then, set the container as the whole extra widget.

Key bindings

The following default key bindings are provided, but you can use a gtkrc file to override them if you need (see gtk-rc.ads).

%PRE%
   Signal name    | Key binding
   location-popup | Control-L  (empty path)
                  | /          (path of "/")
                  | ~          (home directory)
   up-folder      | Alt-Up  or backspace
   down-folder    | Alt-Down
   home-folder    | Alt-Home
   desktop-folder | Alt-D
   quick-bookmark | Alt-1 through Alt-0
     </doc>
  </package>

  <package id="Gtk.Cell_Layout">
     <doc group="Trees and Lists" testgtk="create_cell_view.adb"/>
     <parameter name="self" ada="Cell_Layout"/>
     <method id="gtk_cell_layout_get_area" bind="False"/>
     <!-- in Gtk.Cell_Area -->

     <method id="gtk_cell_layout_set_attributes" bind="False"/>
     <method id="gtk_cell_layout_get_cells" return="ObjectList"/>
     <!--<method id="gtk_cell_layout_set_cell_data_func" bind="False"/>-->
  </package>

  <package id="Gtk.Assistant">
     <doc group="Windows" testgtk="create_assistant.adb"/>
     <parameter name="self" ada="Assistant"/>
     <enum ctype="GtkAssistantPageType" prefix=""/>
  </package>

  <package id="Gtk.Spinner">
     <doc group="Ornaments"/>
     <parameter name="self" ada="Spinner"/>
  </package>

  <package id="Gtk.Entry_Completion">
     <doc group="Numeric/Text Data Entry"/>
     <parameter name="self" ada="Completion"/>
  </package>

  <package id="Gtk.Scrollable">
     <doc group="Interfaces"/>
  </package>

  <package id="Gtk.Progress_Bar">
     <doc testgtk="create_progress.adb"
          screenshot="gtk-progress_bar"
          group="Display widgets"/>
     <parameter name="self" ada="Progress_Bar"/>
  </package>

  <package id="Gtk.Color_Button">
     <doc group="Buttons and Toggles"/>
     <parameter name="self" ada="Button"/>
  </package>

  <package id="Gtk.Link_Button">
     <doc group="Buttons and Toggles"/>
     <parameter name="self" ada="Widget" />
  </package>

  <package id="Gtk.File_Filter">
     <enum ctype="GtkFileFilterFlags"/>
     <record ctype="GtkFileFilterInfo"/>
  </package>

  <package id="Gtk.File_Chooser">
     <doc group=""/>
     <parameter name="self" ada="Chooser"/>
     <enum ctype="GtkFileChooserAction" prefix="GTK_FILE_CHOOSER_"/>
     <enum ctype="GtkFileChooserConfirmation" prefix="GTK_FILE_CHOOSER_"/>
     <enum ctype="GtkFileChooserError" prefix="GTK_FILE_CHOOSER_"/>

     <!-- we won't bind any of these internal functions which pass GFile
          types -->
     <method id="gtk_file_chooser_get_file" bind="False"/>
     <method id="gtk_file_chooser_get_files" bind="False"/>
     <method id="gtk_file_chooser_get_current_folder_file" bind="False"/>
     <method id="gtk_file_chooser_get_preview_file" bind="False"/>
     <method id="gtk_file_chooser_select_file" bind="False"/>
     <method id="gtk_file_chooser_set_current_folder_file" bind="False"/>
     <method id="gtk_file_chooser_set_file" bind="False"/>
     <method id="gtk_file_chooser_unselect_file" bind="False"/>

     <method id="gtk_file_chooser_get_filenames" return="StringSList"/>
     <method id="gtk_file_chooser_get_uris" return="StringSList"/>
     <method id="gtk_file_chooser_list_shortcut_folder_uris"
             return="StringSList"/>
     <method id="gtk_file_chooser_list_shortcut_folders"
             return="StringSList"/>
     <method id="gtk_file_chooser_list_filters" return="ObjectSList"/>
  </package>

  <package id="Gtk.File_Chooser_Button">
     <doc group="Buttons and Toggles"/>
     <parameter name="self" ada="Button"/>
  </package>

  <package id="Gtk.Toolbar">
     <parameter name="self" ada="Toolbar"/>
     <method id="gtk_toolbar_set_show_arrow">
        <parameter name="show_arrow" default="True"/>
     </method>
     <method id="gtk_toolbar_insert">
        <parameter name="pos" default="-1"/>
     </method>
     <method id="gtk_tool_shell_get_orientation" bind="False"/>
     <method id="gtk_tool_shell_get_icon_size" bind="False"/>
     <method id="gtk_tool_shell_get_relief_style" bind="False"/>
     <method id="gtk_tool_shell_get_style" bind="False"/>
  </package>

  <package id="Gtk.Editable">
     <parameter name="self" ada="Editable"/>
     <method id="gtk_editable_select_region">
        <parameter name="end_pos" default="-1"/>
     </method>
     <method id="gtk_editable_delete_text">
        <parameter name="end_pos" default="-1"/>
     </method>
     <method id="gtk_editable_get_chars">
        <parameter name="end_pos" default="-1"/>
     </method>
     <extra>
        <spec>
   procedure Insert_Text
     (Editable : Gtk_Editable;
      New_Text : UTF8_String;
      Position : in out Gint);
   --  Convenience subprogram, identical to Insert_Text above without
   --  the requirement to supply the New_Text_Length argument.
        </spec>
        <body>
   procedure Insert_Text
     (Editable : Gtk_Editable;
      New_Text : UTF8_String;
      Position : in out Gint) is
   begin
      Insert_Text
        (Editable, New_Text &amp; ASCII.NUL, New_Text'Length, Position);
   end Insert_Text;
        </body>
     </extra>
     <!-- ??? inclusion of below method is pending on L117-038 -->
     <method id="gtk_editable_get_selection_bounds" bind="False"/>
  </package>

  <package id="Gtk.Tool_Item">
     <parameter name="self" ada="Tool_Item"/>
     <method id="gtk_tool_item_retrieve_proxy_menu_item" return="GtkMenuItem"/>
     <method id="gtk_tool_item_get_proxy_menu_item" return="GtkMenuItem"/>
     <method id="gtk_tool_item_set_proxy_menu_item">
        <parameter name="menu_item" ctype="GtkMenuItem"/>
     </method>
  </package>

   <package id="Gtk.Scrollbar">
      <parameter name="self" ada="Scrollbar"/>
   </package>

   <package id="Gtk.Hscrollbar" into="GtkScrollbar">
      <parameter name="self" ada="Scrollbar"/>
      <type name="Gtk_Hscrollbar" subtype="true"/>
      <method id="gtk_hscrollbar_new" ada="Gtk_New_Hscrollbar"/>
      <method id="gtk_hscrollbar_get_type" ada="Hscrollbar_Get_Type"/>
   </package>

   <package id="Gtk.Vscrollbar" into="GtkScrollbar">
      <parameter name="self" ada="Scrollbar"/>
      <type name="Gtk_Vscrollbar" subtype="true"/>
      <method id="gtk_vscrollbar_new" ada="Gtk_New_Vscrollbar"/>
      <method id="gtk_vscrollbar_get_type" ada="Vscrollbar_Get_Type"/>
   </package>

   <package id="Gtk.Cell_Renderer">
      <parameter name="self" ada="Cell"/>
      <enum ctype="GtkCellRendererState"/>
      <enum ctype="GtkCellRendererMode"/>
      <method id="gtk_cell_renderer_get_size">
         <!-- hack to make cell_area an in-out parameter -->
         <parameter name="cell_area" ctype="GdkRectangle**"/>
      </method>
      <list ada="Cell_Renderer_List" ctype="GtkCellRenderer"/>
   </package>

   <package id="Gtk.Status_Icon">
      <parameter name="self" ada="Status_Icon"/>
      <!-- ??? inclusion of below method is pending on L117-038 -->
      <method id="gtk_status_icon_get_geometry" bind="False"/>

      <method id="gtk_status_icon_position_menu" convention="C">
         <!-- The purpose of this method is to provide a canned
              implementation of a menu position function for use with
              Gtk.Menu.  Pass all parameters through unchanged.
              May be used as a Gtk.Menu.C_Gtk_Menu_Position_Func. -->
         <parameter name="menu" ctype="gpointer"/>
         <parameter name="push_in" ctype="gboolean*" type="gboolean"/>
      </method>
   </package>

   <package id="Gtk.Menu_Item">
      <parameter name="self" ada="Menu_Item"/>
      <method id="gtk_menu_item_select" ada="Gtk_Select"/>
      <method id="gtk_menu_item_set_right_justified">
         <parameter name="right_justified" default="True"/>
      </method>
      <extra>
         <spec>
   procedure Gtk_New
      (Menu_Item : out Gtk_Menu_Item;
       Label     : UTF8_String) renames Gtk_New_With_Label;
   procedure Initialize
      (Menu_Item : access Gtk_Menu_Item_Record'Class;
       Label     : UTF8_String) renames Initialize_With_Label;
   --  For backwards compatibility.
         </spec>
      </extra>
   </package>

   <package id="Gtk.Recent_Filter">
     <parameter name="self" ada="Filter"/>
     <enum ctype="GtkRecentFilterFlags" />
     <record ctype="GtkRecentFilterInfo" />
     <slist ada="Gtk_Recent_Filter_List" ctype="GtkRecentFilter"/>
   </package>

   <package id="Gtk.File_Chooser_Dialog">
      <parameter name="self" ada="Dialog"/>
      <method id="gtk_file_chooser_dialog_new" ada="Gtk_New" bind="False"/> <!-- varargs -->

      <extra>
         <gir:constructor name="new"
                          c:identifier="ada_gtk_file_chooser_dialog_new"
                          version="2.4"
                          introspectable="0">
            <gir:doc xml:whitespace="preserve">Creates a new #GtkFileChooserDialog.  This function is analogous to gtk_dialog_new_with_buttons().</gir:doc>
            <gir:return-value transfer-ownership="none">
               <gir:doc xml:whitespace="preserve">a new #GtkFileChooserDialog</gir:doc>
               <gir:type name="Widget" c:type="GtkWidget*"/>
            </gir:return-value>
            <gir:parameters>
               <gir:parameter name="title" transfer-ownership="none" allow-none="1">
                  <gir:doc xml:whitespace="preserve">Title of the dialog, or %NULL</gir:doc>
                  <gir:type name="utf8" c:type="gchar*"/>
               </gir:parameter>
               <gir:parameter name="parent" transfer-ownership="none" allow-none="1">
                  <gir:doc xml:whitespace="preserve">Transient parent of the dialog, or %NULL</gir:doc>
                  <gir:type name="Window" c:type="GtkWindow*"/>
               </gir:parameter>
               <gir:parameter name="action" transfer-ownership="none">
                  <gir:doc xml:whitespace="preserve">Open or save mode for the dialog</gir:doc>
                  <gir:type name="FileChooserAction" c:type="GtkFileChooserAction"/>
               </gir:parameter>
            </gir:parameters>
         </gir:constructor>
      </extra>
   </package>

   <package id="Gtk.Handle_Box">
     <parameter name="self" ada="Handle_Box"/>
   </package>

   <package id="Gtk.Scale_Button">
      <parameter name="self" ada="Button"/>
  </package>

   <package id="Gtk.Recent_Manager">
     <doc>
In case the default screen is being used, adding a new recently used file is as
simple as:

%PRE%
     declare
        Manager : constant Gtk_Recent_Manager := Get_Default;
     begin
        Add_Item (Manager, File_URI);
     end;

While looking up a recently used file is as simple as using:

%PRE%
     declare
        Manager : constant Gtk_Recent_Manager := Get_Default;
        Info    : Gtk_Recent_Info;
        Error   : Glib.Error.GError;
     begin
        Lookup_Item (Info, Manager, File_URI, Error);
        if Error /= null then
           --  Use the info object
           Unref (Info);
        else
           Put_Line
             ("Could not find the file: " &amp; Glib.Error.Get_Message (Error));
           Glib.Error.Error_Free (Error);
        end if;
     end;
     </doc>
     <param name="self" ada="Manager" />
     <record ctype="GtkRecentData" />
     <method id="gtk_recent_manager_get_items" return="GtkRecentInfoList"/>
     <list ada="Gtk_Recent_Info_List" ctype="GtkRecentInfo"/>

     <!-- Bound below -->
     <method id="gtk_recent_manager_add_full" bind="False" />

     <extra>
       <with_spec pkg="GNAT.Strings" />
       <with_body pkg="Gtkada.Bindings" />
       <spec>
   function Add_Full
     (Manager      : access Gtk_Recent_Manager_Record;
      Uri          : UTF8_String;
      Display_Name : UTF8_String := "";
      Description  : UTF8_String := "";
      Mime_Type    : UTF8_String;
      App_Name     : UTF8_String;
      App_Exec     : UTF8_String;
      Groups       : GNAT.Strings.String_List;
      Is_Private   : Boolean)
      return Boolean;
   --  Manager      : the Gtk_Recent_Manager on which to operate
   --  Uri          : pointer to resource
   --  Display_Name : a UTF-8 encoded string, containing the name of the
   --                 recently used resource to be displayed, or "".
   --  Description  : a UTF-8 encoded string, containing a short description
   --                 of the resource, or "".
   --  Mime_Type    : the MIME type of the resource.
   --  App_Name     : the name of the application that is registering this
   --                 recently used resource.
   --  App_Exec     : command line used to launch this resource; may contain
   --                 the "%f" and "%u" escape characters which will be
   --                 expanded to the resource file path and URI, respectively,
   --                 when the command line is retrieved.
   --  Groups       : a vector of strings containing groups names.
   --  Is_Private   : whether this resource should be displayed only by the
   --                 applications that have registered it or not.
   --
   --  Adds a new resource, pointed by Uri, into the recently used
   --  resources list, using the metadata specified.
   --
   --  The passed URI will be used to identify this resource inside the
   --  list.
   --
   --  In order to register the new recently used resource, metadata about
   --  the resource must be passed as well as the URI.  This metadata must
   --  contain the MIME type of the resource pointed by the URI; the name of
   --  the application that is registering the item, and a command line to be
   --  used when launching the item.
   --
   --  Optionally, it is possible to specify a UTF-8 string to be used when
   --  viewing the item instead of the last component of the URI; a short
   --  description of the item; whether the item should be considered private -
   --  that is, should be displayed only by the applications that have
   --  registered it.
   --
   --  Returns True if the new item was successfully added to the recently
   --  used resources list, False otherwise.
       </spec>
       <body>
   function Add_Full
     (Manager      : access Gtk_Recent_Manager_Record;
      Uri          : UTF8_String;
      Display_Name : UTF8_String := "";
      Description  : UTF8_String := "";
      Mime_Type    : UTF8_String;
      App_Name     : UTF8_String;
      App_Exec     : UTF8_String;
      Groups       : GNAT.Strings.String_List;
      Is_Private   : Boolean)
      return Boolean
   is
      function Internal
        (Manager     : System.Address;
         Uri         : String;
         Recent_Data : System.Address)
         return Gboolean;
      pragma Import (C, Internal, "gtk_recent_manager_add_full");

      type Gtk_Recent_Data_Record is record
         display_name : chars_ptr;
         description  : chars_ptr;
         mime_type    : chars_ptr;
         app_name     : chars_ptr;
         app_exec     : chars_ptr;
         groups       : System.Address;
         is_private   : Gboolean;
      end record;
      pragma Convention (C, Gtk_Recent_Data_Record);
      --  Internal record that matches struct _GtkRecentData in
      --  gtkrecentmanager.h

      C_Groups : aliased chars_ptr_array := From_String_List (Groups);
      --  Temporary variable to aid translation

      GRD : aliased Gtk_Recent_Data_Record;
      --  Data to feed in to gtk_recent_manager_add_full()

      Result : Gboolean;
   begin
      --  Set up.
      GRD.display_name := String_Or_Null (Display_Name);
      GRD.description  := String_Or_Null (Description);
      GRD.mime_type    := New_String (Mime_Type);
      GRD.app_name     := New_String (App_Name);
      GRD.app_exec     := New_String (App_Exec);
      GRD.is_private   := Boolean'Pos (Is_Private);

      if C_Groups'Length > 0 then
         GRD.groups := C_Groups (C_Groups'First)'Address;
      else
         GRD.groups := System.Null_Address;
      end if;
      --  Invoke function.
      Result := Internal (Get_Object (Manager), Uri &amp; ASCII.NUL, GRD'Address);

      --  Clean up, making sure to avoid double-deallocations where such
      --  may be possible.
      if GRD.display_name /= Null_Ptr then
         Free (GRD.display_name);
      end if;
      if GRD.description /= Null_Ptr then
         Free (GRD.description);
      end if;
      Free (GRD.mime_type);
      Free (GRD.app_name);
      Free (GRD.app_exec);
      for I in C_Groups'Range loop
         if C_Groups (I) /= Null_Ptr then
            Free (C_Groups (I));
         end if;
      end loop;

      --  Return result.
      return Boolean'Val (Result);
   end Add_Full;
       </body>
     </extra>
   </package>

   <package id="Gtk.Recent_Info">  <!-- into="GtkRecentManager">-->
     <method id="gtk_recent_info_ref" return="void" />

     <!-- ??? Disabled for now, we are creating an unconstrained local var -->
     <method id="gtk_recent_info_get_application_info" return="void" bind="False"/>

     <!-- These functions return the length separately, not needed in Ada-->
     <method id="gtk_recent_info_get_applications" bind="False" />
     <method id="gtk_recent_info_get_groups" bind="False" />

     <extra>
       <type>
   subtype time_t is Long_Integer;
   --  Type to interface with C's time_t type.  To convert this to/from
   --  an Ada type, look at Ada.Calendar.Conversion_Operations and be
   --  sure to pay special attention to the ranges each type is capable
   --  of representing.
       </type>
     </extra>
   </package>

   <package id="Gtk.Recent_Chooser">
     <parameter name="self" ada="Chooser" />
     <method id="gtk_recent_chooser_get_items" return="RecentInfoList"/>
     <enum ctype="GtkRecentSortType" />

     <!-- These functions return the length separately, not needed in Ada-->
     <method id="gtk_recent_chooser_get_uris" bind="False" />

     <method id="gtk_recent_chooser_list_filters" return="RecentFilterSList"/>
   </package>

   <package id="Gtk.Widget" needs_merge="false">
     <parameter name="self" ada="Widget" />
     <enum ctype="GtkAlign"/>
     <record ctype="GtkRequisition"/>
     <record ctype="GtkWidgetPath"/>
     <list ada="Widget_List" ctype="Widget"/>
     <slist ada="Widget_SList" ctype="Widget"/>

     <method id="gtk_widget_new" bind="False" /> <!-- varargs -->
     <method id="gtk_widget_style_get" bind="False" /> <!-- varargs -->
     <method id="gtk_widget_style_get_valist" bind="False"/><!-- varargs -->
     <method id="gtk_widget_get_accessible" bind="False"/> <!-- Requires ATK -->
     <method id="gtk_widget_get_clipboard" bind="False"/><!-- in Gtk.Clipboard -->
     <method id="gtk_widget_get_settings" bind="False"/><!-- in Gtk.Settings -->
     <method id="gtk_widget_modify_style" bind="False"/><!-- in Gtk.RC -->
     <method id="gtk_widget_class_path" bind="False"/><!-- deprecated -->
     <method id="gtk_widget_path" bind="False"/><!-- deprecated -->
     <method id="gtk_drag_source_get_target_list" bind="False"/><!-- in Gtk.Dnd -->
     <method id="gtk_drag_source_set_target_list" bind="False"/><!-- in Gtk.Dnd-->
     <method id="gtk_drag_begin" bind="False"/><!-- in Gtk.Dnd -->
     <method id="gtk_drag_dest_find_target" bind="False"/><!-- in Gtk.Dnd-->
     <method id="gtk_drag_dest_get_target_list" bind="False"/><!-- in Gtk.Dnd-->
     <method id="gtk_drag_dest_set_target_list" bind="False"/><!-- in Gtk.Dnd-->
     <method id="gtk_drag_dest_set" bind="False"/><!-- in Gtk.Dnd -->
     <method id="gtk_drag_source_set" bind="False"/><!-- in Gtk.Dnd -->
     <method id="gtk_widget_modify_base" obsolescent="True"/>
     <method id="gtk_widget_modify_fg" obsolescent="True"/>
     <method id="gtk_widget_modify_bg" obsolescent="True"/>
     <method id="gtk_widget_modify_text" obsolescent="True"/>
     <method id="gtk_widget_set_sensitive">
       <parameter name="Sensitive" default="True"/>
     </method>
     <method id="gtk_widget_add_accelerator">
       <parameter name="Accel_Key" ctype="GtkAccelKey" />
     </method>
     <method id="gtk_widget_remove_accelerator">
       <parameter name="Accel_Key" ctype="GtkAccelKey" />
     </method>
     <method id="gtk_widget_add_events">
       <parameter name="Events" ctype="GdkEventMask"/>
     </method>
     <method id="gtk_widget_set_events">
       <parameter name="Events" ctype="GdkEventMask"/>
     </method>
     <method id="gtk_widget_get_events" return="GdkEventMask"/>
     <method id="gtk_widget_get_tooltip_window" return="GtkWidget*" />
     <method id="gtk_widget_set_tooltip_window">
       <parameter name="Custom_Window" ctype="GtkWidget*"/>
     </method>
     <method id="gtk_widget_list_mnemonic_labels" return="WidgetList" />
     <method id="gtk_widget_render_icon">
       <parameter name="Detail" default='""'/>
     </method>
     <method id="gtk_widget_create_pango_layout">
       <parameter name="Text" allow-none="1"/>
     </method>
     <method id="gtk_widget_destroy">
       <body>
   procedure Destroy (Widget : not null access Gtk_Widget_Record) is
      procedure Internal (Widget : System.Address);
      pragma Import (C, Internal, "gtk_widget_destroy");

      procedure Unref_Internal (Widget : System.Address);
      pragma Import (C, Unref_Internal, "g_object_unref");
      --  External binding: g_object_unref

      Ptr : constant System.Address := Get_Object (Widget);

      use type System.Address;
   begin
      --  Keep a reference on the object, so that the Ada structure is
      --  never automatically deleted when the C object is.
      --  We can't reset the content of Widget to System.Null_Address before
      --  calling the C function, because we want the user's destroy
      --  callbacks to be called with the appropriate object.
      Ref (Widget);
      Internal (Ptr);

      --  We then can make sure that the object won't be referenced any
      --  more, (The Ada structure won't be free before the ref count goes
      --  down to 0, and we don't want the user to use a deleted object...).
      Set_Object (Widget, System.Null_Address);

      --  Free the reference we had. In most cases, this results in the
      --  object being freed. We can't use directly Unref, since the Ptr
      --  field for Object is Null_Address.
      Unref_Internal (Ptr);
   end Destroy;
       </body>
     </method>

     <extra>
       <with_spec pkg="Gdk.Rectangle"/>
       <type>
   subtype Gtk_Allocation is Gdk.Rectangle.Gdk_Rectangle;

   type Gtk_Requisition_Access is access all Gtk_Requisition;
   type Gtk_Allocation_Access is access all Gtk_Allocation;
   pragma Convention (C, Gtk_Requisition_Access);
   pragma Convention (C, Gtk_Allocation_Access);
       </type>
     </extra>

     <!-- Need GtkAda-custom binding -->
     <method id="gtk_widget_intersect" bind="False"/><!-- Need out parameter-->
     <method id="gtk_widget_list_accel_closures" bind="False"/>
     <method id="gtk_widget_region_intersect" bind="False"> <!-- Wrong mode -->
       <parameter name="Region" direction="in"/>
     </method>
     <method id="gtk_widget_translate_coordinates" bind="False"/><!-- function with out param -->
     <method id="gtk_widget_get_style_context" bind="False"/><!-- Needs Gtk.Style_Context-->
   </package>

   <!-- Below were added just for the sake of parsing the files to get information
        on their symbols, and properly substitute them in the docs.
        No file is generated from them.
   -->

   <package id="Gtk.Menu" needs_merge="true"/>
   <package id="Gtk.Tooltip" needs_merge="true"/>
   <package id="Gtk.Text_View" needs_merge="true"/>
   <package id="Gtk.Rc_Style" needs_merge="true"/>
   <package id="Gtk.Container" needs_merge="true">
     <method id="gtk_container_add_with_properties" bind="False"/><!-- varargs -->
     <method id="gtk_container_child_get" bind="False"/> <!-- varargs -->
     <method id="gtk_container_child_set" bind="False"/> <!-- varargs -->
   </package>
   <package id="Gtk.Tree_Model" needs_merge="true">
     <method id="gtk_tree_model_get" bind="False"/> <!-- varargs -->
   </package>

</GIR>
