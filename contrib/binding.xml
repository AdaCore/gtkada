<?xml version="1.0"?>

<!--  This file overrides parts of the .gir files. -->

<GIR xmlns:gir="http://www.gtk.org/introspection/core/1.0"
     xmlns:c="http://www.gtk.org/introspection/c/1.0">

   <!-- ###################################################
        Gtk.Button
        ###################################################-->
   <package id="Gtk.Button">
      <doc screenshot="gtk-button"
           group="Buttons and Toggles"
           testgtk="create_buttons.adb">
This package implements a general button widget. This button can
be clicked on by the user to start any action.
This button does not have multiple states, it can just be temporarily
pressed while the mouse is on it, but does not keep its pressed state.

The gtk+ sources provide the following drawing that explains the role of
the various spacings that can be set for a button:
      </doc>
      <method id="gtk_button_new" bind="False"/>
      <method id="gtk_button_new_with_label" ada="Gtk_New" >
         <parameter name="label" default='""' empty_maps_to_null="True"/>
      </method>
   </package>

   <!-- ###################################################
        Gtk.Frame
        ###################################################-->
   <package id="Gtk.Frame">
      <doc screenshot="gtk-frame" testgtk="create_frame.adb"
           group="Ornaments">
A Gtk_Frame is a simple border than can be added to any widget or
group of widget to enhance its visual aspect.
Optionally, a frame can have a title.

This is a very convenient widget to visually group related widgets (like
groups of buttons for instance), possibly with a title to explain the
purpose of this group.

A Gtk_Frame has only one child, so you have to put a container like for
instance a Gtk_Box inside if you want the frame to surround multiple
widgets.
      </doc>

      <method id="gtk_frame_new">
         <parameter name="label" default='""' empty_maps_to_null="True" />
      </method>
   </package>

   <!-- ################################################
        Gtk.Label
        ################################################-->

   <package id="Gtk.Label">
      <doc screenshot="gtk-label" testgtk="create_label.adb"
           group="Display widgets">
A Gtk_Label is a light widget associated with some text you want
to display on the screen. You can change the text dynamically if
needed.

The text can be on multiple lines if you separate each line with
the ASCII.LF character. However, this is not the recommended way
to display long texts (see the Gtk_Text widget instead).

== Mnemonics ==

Labels may contain mnemonics. Mnemonics are underlined characters in the
label, used for keyboard navigation. Mnemonics are created by providing
string with an underscore before the mnemonic character, such as "_File",
to the functions gtk_new_with_mnemonic or set_text_with_mnemonic().

Mnemonics automatically activate any activatable widget the label is
inside, such as a Gtk_Button; if the label is not inside the mnemonic's
target widget, you have to tell the label about the target using
set_mnemonic_widget(). For instance:
    declare
       Button : Gtk_Button;
       Label  : Gtk_Label;
    begin
       Gtk_New (Button);
       Gtk_New_With_Mnemonic (Label, "_File");
       Add (Button, Label);
    end;
However, there exists a convenience function in Gtk.Button to create such
a button already.

== Markup ==

To make it easy to format text in a label (changing colors, fonts, etc.),
label text can be provided in a simple markup format. Here's how to create
a label with a small font:
     Gtk_New (Label, "&lt;small&gt;hello&lt;/small&gt;");

The markup must be valid, and &lt;&gt;&amp; characters must be escaped with
&amp;lt; &amp;gt; and &amp;amp;

Markup strings are just a convenient way to set the Pango_Attr_List on
label; Set_Attributes() may be a simpler way to set attributes in some
cases. Be careful though; Pango_Attr_List tends to cause
internationalization problems, unless you're applying attributes to the
entire string (i.e. unless you set the range of each attribute to [0,
G_MAXINT)). The reason is that specifying the start_index and end_index for
a Pango_Attribute requires knowledge of the exact string being displayed,
so translations will cause problems.

== Selectable labels ==

Labels can be made selectable with Set_Selectable. Selectable
labels allow the user to copy the label contents to the clipboard. Only
should be made selectable.
      </doc>

      <method id="gtk_label_new">
         <parameter name="str" default='""'/>
      </method>
      <method id="gtk_label_get" bind="false"/>
      <method id="gtk_label_select_region">
         <parameter name="start_offset" default="-1"/>
         <parameter name="end_offset" default="-1"/>
      </method>
      <method id="gtk_label_get_selection_bounds"
         return_as_param="Has_Selection"/>
      <method id="gtk_label_set_pattern">
         <doc>
Change the underlines pattern.

Pattern is a simple string made of underscore and space characters,
matching the ones in the string. GtkAda will underline every letter
that matches an underscore.

An empty string disables the underlines.

example: If the text is FooBarBaz and the Pattern is "___   ___"
then both "Foo" and "Baz" will be underlined, but not "Bar".
         </doc>
      </method>
   </package>

   <!-- ################################################
        Gtk.Paned
        ################################################-->

   <package id="Gtk.Paned">
      <doc screenshot="gtk-paned" testgtk="create_paned.adb"
           group="Layout container">
A Gtk_Paned is a container that organizes its two children either
horizontally or vertically.
The initial size allocated to the children depends on the size
they request. However, the user has the possibility to interactively
move a separation bar between the two to enlarge one of the children,
while at the same time shrinking the second one.
The bar can be moved by clicking with the mouse on a small cursor
displayed in the bar, and then dragging the mouse.

No additional decoration is provided around the children.

Each child has two parameters, Resize and Shrink.

If Shrink is True, then the widget can be made smaller than its
requisition size by the user. Set this to False if you want to
set a minimum size.

if Resize is True, this means that the child accepts to be resized, and
will not require any size. Thus, the size allocated to it will be
the total size allocated to the container minus the size requested by
the other child.
If Resize is False, the child should ask for a specific size, which it
will get. The other child will be resized accordingly.
If both Child have the same value for Resize (either True or False), then
the size allocated to each is a ratio between the size requested by both.

When you use Set_Position with a parameter other than -1, or the user
moves the handle to resize the widgets, the behavior of Resize is
canceled.
      </doc>
      <method id="gtk_paned_pack1">
         <parameter name="self" ada="Paned"/>
         <parameter name="resize" default="False" />
         <parameter name="shrink" default="True" />
         <doc>
Add a child to the top or left pane.
You can not change dynamically the attributes Resize and Shrink.
Instead, you have to remove the child from the container, and put it
back with the new value of the attributes. You should also first
call Gtk.Object.Ref on the child so as to be sure it is not destroyed
when you remove it, and Gtk.Object.Unref it at the end. See the
example in testgtk/ in the GtkAda distribution.
         </doc>
      </method>
      <method id="gtk_paned_pack2">
         <parameter name="self" ada="Paned"/>
         <parameter name="resize" default="False" />
         <parameter name="shrink" default="False" />
      </method>
      <method id="gtk_paned_add1">
         <parameter name="self" ada="Paned"/>
         <doc>
Add the first child of the container.
The child will be displayed either in the top or in the left pane,
depending on the orientation of the container.
This is equivalent to using the Pack1 procedure with its default parameters.
         </doc>
      </method>
      <method id="gtk_paned_add2">
         <parameter name="self" ada="Paned"/>
         <doc>
Add the second child of the container.
It will be displayed in the bottom or right pane, depending on the
container's orientation.
This is equivalent to using Pack2 with its default parameters.
         </doc>
      </method>
   </package>

   <package id="Gtk.Vpaned" into="Paned">
      <type name="Gtk_Vpaned" subtype="true"/>
      <method id="gtk_vpaned_new" ada="Gtk_New_Vpaned">
         <doc>The children will be displayed one on top of the other</doc>
      </method>
      <method id="gtk_vpaned_get_type" ada="Get_Type_Vpaned" />
   </package>

   <package id="Gtk.Hpaned" into="Paned">
      <type name="Gtk_Hpaned" subtype="true"/>
      <method id="gtk_hpaned_new" ada="Gtk_New_Hpaned">
         <doc>The children will be displayed next to each other</doc>
      </method>
      <method id="gtk_hpaned_get_type" ada="Get_Type_Hpaned" />
   </package>


   <!-- ################################################
        Gtk.Box, Gtk.Vbox, Gtk.Hbox
        ################################################-->
   <package id="Gtk.Box">
      <doc screenshot="gtk-box" testgtk="create_box.adb"
           group="Layout containers">
A box is a container that can have multiple children, organized either
horizontally or vertically. Two subtypes are provided, Gtk_Hbox and
Gtk_Vbox, to conform to the C API. In Ada, you do not need to
distinguish between the two, but note that the Gtk_Box type is conceptually
an abstract type: there is no way to create a "Gtk_Box", only ways to
create either an horizontal box, or a vertical box.

Children can be added to one of two positions in the box, either at the
beginning (ie left or top) or at the end (ie right or bottom). Each of
these positions can contain multiple widgets.

Every time a child is added to the start, it is placed to the right
(resp. the bottom) of the previous widget added to the start.

Every time a child is added to the end, it is placed to the left (resp.
the top) of the previous widget added to the end.

There are a number of parameters to specify the behavior of the box when
it is resized, and how the children should be reorganized and/or resized.

See the testgtk example in the GtkAda distribution to see concrete examples
on how all the parameters for the boxes work.
      </doc>
      <method id="gtk_box_pack_start">
         <parameter name="self" ada="In_Box"/>
         <parameter name="expand" default="True"/>
         <parameter name="fill" default="True"/>
         <parameter name="padding" default="0"/>
      </method>
      <method id="gtk_box_pack_end">
         <parameter name="self" ada="In_Box"/>
         <parameter name="expand" default="True"/>
         <parameter name="fill" default="True"/>
         <parameter name="padding" default="0"/>
      </method>

      <extra>
         <gir:method c:identifier="ada_box_get_child" name="Get_Child"
                     version="GtkAda 1.0">
            <gir:doc>Return the Num-th child of the box, or null if there is no such child</gir:doc>
            <gir:return-value>
               <gir:type name="GtkWidget" c:type="GtkWidget*"/>
            </gir:return-value>
            <gir:parameters>
               <gir:parameter name="num">
                  <gir:type name="Gint" c:type="gint"/>
               </gir:parameter>
            </gir:parameters>
         </gir:method>
      </extra>
   </package>

   <package id="Gtk.Vbox" into="Box">
      <type name="Gtk_Vbox" subtype="true"/>
      <method id="gtk_vbox_new" ada="Gtk_New_Vbox">
         <parameter name="homogeneous" default="False"/>
         <parameter name="spacing" default="0"/>
      </method>
      <method id="gtk_vbox_get_type" ada="Get_Vbox_Type" />
   </package>

   <package id="Gtk.Hbox" into="Box">
      <type name="Gtk_Hbox" subtype="true"/>
      <method id="gtk_hbox_new" ada="Gtk_New_Hbox" >
         <parameter name="homogeneous" default="False"/>
         <parameter name="spacing" default="0"/>
      </method>
      <method id="gtk_hbox_get_type" ada="Get_Hbox_Type" />
   </package>

   <package id="Gtk.Scale">
      <doc group="Numeric/Text Data Entry" screenshot="gtk-scale.png">
A scale is a horizontal or vertical widget that a user can slide to choose
a value in a given range. This is a kind of cursor, similar to what one
finds on audio systems to select the volume for instance.
      </doc>
      <parameter name="self" ada="Scale"/>
   </package>
   <package id="Gtk.Vscale" into="Scale">
      <parameter name="self" ada="Scale"/>
      <type name="Gtk_Vscale" subtype="true"/>
      <method id="gtk_vscale_new" ada="Gtk_New_Vscale">
         <parameter name="adjustment" default="null"/>
      </method>
      <method id="gtk_vscale_new_with_range" ada="Gtk_New_Vscale"/>
      <method id="gtk_vscale_get_type" ada="Vscale_Get_Type" />
   </package>
   <package id="Gtk.Hscale" into="Scale">
      <parameter name="self" ada="Scale"/>
      <type name="Gtk_Hscale" subtype="true"/>
      <method id="gtk_hscale_new" ada="Gtk_New_Hscale">
         <parameter name="adjustment" default="null"/>
      </method>
      <method id="gtk_hscale_new_with_range" ada="Gtk_New_Hscale"/>
      <method id="gtk_hscale_get_type" ada="Hscale_Get_Type" />
   </package>

   <!-- ########################################################
        ## Gtk.Arrow
        ########################################################-->

   <package id="Gtk.Arrow">
      <doc screenshot="gtk-arrow" testgtk="create_arrow.adb">
Gtk_Arrow should be used to draw simple arrows that need to point in one
of the four cardinal directions (up, down, left, or right). The style of
the arrow can be one of shadow in, shadow out, etched in, or etched out.
Note that these directions and style types may be ammended in versions of
Gtk to come.

Gtk_Arrow will fill any space alloted to it, but since it is inherited from
Gtk_Misc, it can be padded and/or aligned, to fill exactly the space you
desire.

Arrows are created with a call to Gtk_New. The direction or style of an
arrow can be changed after creation by using Set.
      </doc>
   </package>

   <!-- #######################################################
        ## Gtk.Viewport
        #######################################################-->

   <package id="Gtk.Viewport">
      <doc group="Scrolling">
This widget is an adapter: it can contain any child, and will make it
scrollable. Its use is not necessary inside a Gtk_Scrolled_Window, which
automatically uses a Gtk_Viewport when necessary.
      </doc>
      <method id="gtk_viewport_new">
         <parameter name="hadjustment" default="null"/>
         <parameter name="vadjustment" default="null"/>
      </method>
   </package>

   <!-- #######################################################
        ## Gtk.Pixmap
        #######################################################-->

   <package id="Gtk.Pixmap">
      <doc group="Obsolescent widgets"/>
      <method id="gtk_pixmap_set_build_insensitive">
         <doc>Whether the pixmap should be grayed out, as is done for insensitive widgets that do not accept user interaction</doc>
      </method>

      <extra>
         <with_spec pkg="Gtk.Widget" />
         <with_spec pkg="Gtk.Window" />
         <with_spec pkg="Gtkada.Types" />
         <with_body pkg="Interfaces.C.Strings" />
         <with_body pkg="Gdk.Color" />
         <spec>
   function Create_Pixmap
     (Filename : String;
      Window   : access Gtk.Window.Gtk_Window_Record'Class) return Gtk_Pixmap;
      --  Create a pixmap given a window and a filename   

   function Create_Pixmap
     (Data     : Gtkada.Types.Chars_Ptr_Array;
      Window   : access Gtk.Window.Gtk_Window_Record'Class) return Gtk_Pixmap;
   --  Create a pixmap given a window and a buffer.
            </spec>
            <body>
   Dummy_Pixmap : constant GtkAda.Types.chars_ptr_array :=
     (New_String ("1 1 1 1"),
      New_String ("c None"),
      New_String (" "));
   --  This is a dummy pixmap we use when a pixmap can't be found.

   function Create_Pixmap
     (Filename : String;
      Window   : access Gtk.Window.Gtk_Window_Record'Class) return Gtk_Pixmap
   is
      Gdkpixmap : Gdk.Pixmap.Gdk_Pixmap;
      Mask      : Gdk.Bitmap.Gdk_Bitmap;
      Pixmap    : Gtk_Pixmap;

      use Gtk.Widget;
      use Gtk.Window;

   begin
      if not Realized_Is_Set (Window) then
         Gtk.Window.Realize (Window);
      end if;

      if Filename = "" then
         Gdk.Pixmap.Create_From_Xpm_D
           (Gdkpixmap, Get_Window (Window), Mask,
            Gdk.Color.Null_Color, Dummy_Pixmap);
      else
         Gdk.Pixmap.Create_From_Xpm
           (Gdkpixmap, Get_Window (Window), Mask,
            Gdk.Color.Null_Color, Filename);
      end if;

      Gtk_New (Pixmap, Gdkpixmap, Mask);
      return Pixmap;
   end Create_Pixmap;

   function Create_Pixmap
     (Data   : Gtkada.Types.Chars_Ptr_Array;
      Window : access Gtk.Window.Gtk_Window_Record'Class) return Gtk_Pixmap
   is
      Gdkpixmap : Gdk.Pixmap.Gdk_Pixmap;
      Mask      : Gdk.Bitmap.Gdk_Bitmap;
      Pixmap    : Gtk_Pixmap;

      use Gtk.Widget;
      use Gtk.Window;

   begin
      if not Realized_Is_Set (Window) then
         Gtk.Window.Realize (Window);
      end if;

      Gdk.Pixmap.Create_From_Xpm_D
        (Gdkpixmap, Get_Window (Window), Mask, Gdk.Color.Null_Color, Data);
      Gtk_New (Pixmap, Gdkpixmap, Mask);

      return Pixmap;
   end Create_Pixmap;
         </body>
      </extra>
   </package>

   <package id="Gtk.Misc">
      <doc group="Abstract base classes">
This widget is a base class for all the widgets that require an
alignment and padding.
This widget can not be instantiated directly.
      </doc>
      <method id="gtk_misc_set_alignment">
         <doc>
Modify the alignment for the widget.
Xalign and Yalign are both values between 0.0 and 1.0 that specify the
alignment: if Xalign is 0.0, the widget will be left aligned; if it is
0.5, the widget will be centered; if it is 1.0 the widget will be
right aligned. Yalign is from top (0.0) to bottom (1.0).
Both Xalign and Yalign will be constrained to the range 0.0 .. 1.0
Note that if the widget fills its allocated area, these two parameters
won't have any effect.
         </doc>
      </method>
      <method id="gtk_misc_set_padding">
         <doc>
Set the padding (i.e. the extra spaces on the side of the widget).
If Xpad or Ypad is negative, they will be changed to 0.
         </doc>
      </method>
   </package>

   <package id="Gtk.Bin">
      <doc group="Abstract base classes">
Base class for containers that have only one child.
This widget can not be instantiated directly.
      </doc>
   </package>

   <package id="Gtk.List" obsolescent="True">
      <doc group="Obsolescent widgets" testgtk="create_list.adb"/>
      <method id="gtk_list_append_items">
         <parameter name="items" type="Widget_List.Glist"/>
      </method>
      <method id="gtk_list_prepend_items">
         <parameter name="items" type="Widget_List.Glist"/>
      </method>
      <method id="gtk_list_insert_items">
         <parameter name="items" type="Widget_List.Glist"/>
      </method>
      <method id="gtk_list_remove_items">
         <parameter name="items" type="Widget_List.Glist"/>
      </method>
      <method id="gtk_list_remove_items_no_unref">
         <parameter name="items" type="Widget_List.Glist"/>
      </method>
      <method id="gtk_list_clear_items">
         <doc>Remove some items from the list. If The_End is negative, it means the end of the list. The first item in the list has an index of 0</doc>
      </method>
      <extra>
         <spec>
   function Get_Selection (Widget : access Gtk.List.Gtk_List_Record)
      return Widget_List.Glist;
         </spec>
         <body>
   function Get_Selection (Widget : access Gtk.List.Gtk_List_Record)
      return Widget_List.Glist
   is
      use Widget_List;
      function Internal (Widget : in System.Address)
                         return      System.Address;
      pragma Import (C, Internal, "ada_list_get_selection");
      List : Gtk.Widget.Widget_List.Glist;
   begin
      Set_Object (List, Internal (Get_Object (Widget)));
      return List;
   end Get_Selection;
         </body>
      </extra>
   </package>

   <package id="Gtk.Progress" obsolescent="True">
      <doc group="Obsolescent widgets">This package is deprecated. It now only acts as an abstract base class for other widgets.</doc>
      <parameter name="self" ada="Progress"/> <!-- for all methods -->
      <method id="gtk_progress_get_adjustment">
         <parameter name="self" ada="widget"/>
      </method>
      <method id="gtkada_GtkProgress_get_adjustment" bind="true"/>
      <method id="gtkada_GtkProgress_get_activity_mode" bind="true"/>
   </package>

   <package id="Gtk.Layout">
      <doc group="Layout containers" testgtk="create_layout.adb"
           screenshot="gtk-layout">
A Gtk_Layout is a widget that can have an almost infinite size, without
occupying a lot of memory. Its children can be located anywhere within
it, but will only appear on the screen if the visible area of the layout
contains them.
Just like a Gtk_Viewport, its visible area is indicated by two
Gtk_Adjustment widgets, and thus a Gtk_Layout can be put as is in a
Gtk_Scrolled_Window.
As for Gtk_Fixed containers, the children can be located anywhere in the
layout (no automatic organization is done). But, as opposed to Gtk_Fixed
widgets, a Gtk_Layout does not try to resize itself to show all its
children.

Starting from GtkAda 2.0, you have to call Set_Size and specify the maximum
size of the layout, otherwise children added with Put outside the size
defined for the layout will never be visible.
One way to do this is to systematically call Set_Size before calling Put,
and make sure you specify a size big enough for the layout.
      </doc>
      <parameter name="self" ada="Layout"/> <!-- for all methods -->
      <method id="gtk_layout_new">
         <parameter name="hadjustment" default="null"/>
         <parameter name="vadjustment" default="null"/>
      </method>
      <method id="gtk_layout_put">
         <doc>The child will be displayed on the screen only if at least part of it intersects the visible area of the layout. The layout does not resize itself to automatically show the widget. You also need to call Set_Size, if the size you initially defined is smaller than (X, Y), or the child will never be visible even if the layout is scrolled.</doc>
      </method>
      <method id="gtk_layout_set_hadjustment">
         <doc>Return the adjustment that indicate the horizontal visual area of the layout. You generally do not have to modify the value of this adjustment yourself, since this is done automatically when the layout has been put in a Gtk_Scrolled_Window.</doc>
      </method>
   </package>

   <package id="Gtk.GRange">
      <doc testgtk="create_range.adb" screenshot="gtk-range">This widget provides a low level graphical representation of a range of values. It is used by other widgets such as Gtk_Scale and Gtk_Scrollbar.</doc>
      <parameter name="self" ada="The_Range"/>
   </package>

   <package id="Gtk.Button_Box">
      <doc testgtk="create_button_box.adb" screenshot="gtk-button_box"
           group="Layout containers">
A Gtk_Button_Box is a special type of Gtk_Box specially tailored to contain
buttons.

This is only a base class for Gtk_Hbutton_Box and Gtk_Vbutton_Box which
provide a way to arrange their children horizontally (resp. vertically).
You can not instantiate a Gtk_Button_Box directly, and have to use one the
above two instead.
      </doc>
      <method id="gtk_button_box_set_child_size" obsolescent="True"/>
      <method id="gtk_button_box_get_child_size" obsolescent="True"/>
      <method id="gtk_button_box_set_child_ipadding" obsolescent="True"/>
      <method id="gtk_button_box_set_child_secondary">
         <doc>
Set whether Child should appear in a secondary group of children.
A typical use of a secondary child is the help button in a dialog.

This group appears after the other children if the style is
Buttonbox_Start, Buttonbox_Spread or Buttonbox_Edge, and before the
other children if the style is Buttonbox_End. For horizontal button
boxes, the definition of before/after depends on direction of the
widget. (See Gtk.Widget.Set_Direction) If the style is Buttonbox_Start,
or Buttonbox_End, then the secondary children are aligned at
the other end of the button box from the main children. For the
other styles, they appear immediately next to the main children.

Is_Secondary: if True, the Child appears in a secondary group of the
              button box.
         </doc>
      </method>
   </package>

   <package id="Gtk.Hbutton_Box">
      <doc group="Layout containers">
A Gtk_Hbutton_Box is a specific Gtk_Button_Box that organizes its
children horizontally.
The beginning of the box (when you add children with Gtk.Box.Pack_Start)
is on the left of the box. Its end (for Gtk.Box.Pack_End) is on the right.
      </doc>
      <method id="gtk_hbutton_box_get_spacing_default" obsolescent="True"/>
      <method id="gtk_hbutton_box_set_spacing_default" obsolescent="True">
         <doc>Set the default spacing (space between two adjacent children). This is done for all the Hbutton_Boxes in your application. This can be overridden for a specific box by calling Gtk.Button_Box.Set_Spacing.</doc>
      </method>
      <method id="gtk_hbutton_box_get_layout_default" obsolescent="True"/>
      <method id="gtk_hbutton_box_set_layout_default" obsolescent="True">
         <doc>Set the the default layout to use for all the hbutton_boxes in your application that don't have a specific value set by Gtk.Button_Box.Set_Layout. The default value is Buttonbox_Edge</doc>
      </method>
   </package>

   <package id="Gtk.Vbutton_Box">
      <doc group="Layout containers">
A Gtk_Vbutton_Box is a specific Gtk_Button_Box that organizes its
children vertically.
The beginning of the box (when you add children with Gtk.Box.Pack_Start)
is on the top of the box. Its end (for Gtk.Box.Pack_End) is on the bottom.
      </doc>
      <method id="gtk_vbutton_box_get_spacing_default" obsolescent="True"/>
      <method id="gtk_vbutton_box_set_spacing_default" obsolescent="True"/>
      <method id="gtk_vbutton_box_get_layout_default" obsolescent="True"/>
      <method id="gtk_vbutton_box_get_layout_default" obsolescent="True"/>
   </package>

   <package id="Gtk.Volume_Button">
      <doc>
Gtk_Volume_Button is a subclass of Gtk_Scale_Button that has been tailored
for use as a volume control widget with suitable icons, tooltips and
accessible labels.
      </doc>
   </package>

   <package id="Gtk.About_Dialog">
      <doc group="Windows" testgtk="create_about.adb">
The Gtk_About_Dialog offers a simple way to display information about a
program like its logo, name, copyright, website and license. It is also
possible to give credits to the authors, documenters, translators and
artists who have worked on the program. An about dialog is typically opened
when the user selects the About option from the Help menu. All parts of the
dialog are optional.

About dialog often contain links and email addresses. Gtk_About_Dialog
supports this by offering global hooks, which are called when the user
clicks on a link or email address, see Set_Email_Hook and Set_Url_Hook.
Email addresses in the authors, documenters and artists properties are
recognized by looking for &lt;user@host&gt;, URLs are recognized by looking for
http://url, with url extending to the next space, tab or line break.

To make constructing a Gtk_About_Dialog as convenient as possible, you can
use the function gtk_show_about_dialog which constructs and shows a dialog
and keeps it around so that it can be shown again.
     </doc>
     <extra>
        <with_spec pkg="Interfaces.C.Strings"/>
        <!-- This is defined in a <callback> node in GIR, but not processed
             automatically yet -->
        <type ctype="GtkAboutDialogActivateLinkFunc"
           ada="Activate_Link_Func">
   type Activate_Link_Func is access procedure
     (About : System.Address;
      Link  : Interfaces.C.Strings.chars_ptr;
      Data  : System.Address);
   pragma Convention (C, Activate_Link_Func);
   --  A callback called when the user presses an hyper link in the about
   --  dialog. This is a low-level function, and you'll need to convert the
   --  parameters to more useful types with:
   --     Stub : Gtk_About_Dialog_Record;
   --     A    : constant Gtk_About_Dialog :=
   --       Gtk_About_Dialog (Get_User_Data (About, Stub));
   --     L    : constant String := Interfaces.C.Strings.Value (Link);
        </type>
     </extra>
  </package>

  <package id="Gtk.GEntry">
     <doc testgtk="create_entry.adb" group="Numeric/Text Data Entry"
          screenshot="gtk-gentry">
A Gtk_Entry is a single line text editing widget.
The text is automatically scrolled if it is longer than can be displayed
on the screen, so that the cursor position is visible at all times.

See Gtk_Text_View for a multiple-line text editing widget.
     </doc>
     <parameter name="self" ada="The_Entry"/>
  </package>

  <package id="Gtk.Combo" obsolescent="True">
     <doc group="Obsolescent widgets" screenshot="gtk-combo"
          see="Gtk.Combo_Box">
The Gtk_Combo widget consists of a single-line text entry field and a
drop-down list. The drop-down list is displayed when the user clicks on a
small arrow button to the right of the entry field.

The drop-down list is a Gtk_List widget and can be accessed using the list
member of the Gtk_Combo. List elements can contain arbitrary widgets, but
if an element is not a plain label, then you must use the
Gtk_List.Set_Item_String function. This sets the string which will be
placed in the text entry field when the item is selected.

By default, the user can step through the items in the list using the arrow
(cursor) keys, though this behaviour can be turned off with Set_Use_Arrows.

Normally the arrow keys are only active when the contents of the text entry
field matches one of the items in the list. If the contents of the entry
field do not match any of the list items, then pressing the arrow keys does
nothing. However, by calling Set_Use_Arrows_Always you can specify that the
arrow keys are always active. If the contents of the entry field does not
match any of the items in the list, then pressing the up or down arrow key
will set the entry field to the last or first item in the list,
respectively.
     </doc>
     <method id="gtk_combo_set_value_in_list">
        <parameter name="val" default="True"/>
        <parameter name="ok_if_empty" default="False"/>
        <doc>Specify whether the value entered in the text entry field must match one of the values in the list. If this is set then the user will not be able to perform any other action until a valid value has been entered. If an empty field is acceptable, the Ok_If_Empty parameter should be True. If the value entered must match one of the values in the list, val should be True.</doc>
     </method>
     <method id="gtk_combo_set_use_arrows">
        <parameter name="val" default="True"/>
        <doc>Specify if the arrow (cursor) keys can be used to step through the items in the list. This is on by default.</doc>
     </method>
     <method id="gtk_combo_set_use_arrows_always">
        <parameter name="val" default="True"/>
        <doc>Specify if the arrow keys will still work even if the current contents of the Gtk_Entry field do not match any of the list items.</doc>
     </method>
     <method id="gtk_combo_set_case_sensitive">
        <parameter name="val" default="True"/>
        <doc>Specify whether the text entered into the Gtk_Entry field and the text in the list items are case sensitive. This may be useful, for example, when you have called Set_Value_In_List to limit the values entered, but you are not worried about differences in case.</doc>
     </method>
     <method id="gtk_combo_set_popdown_strings">
        <parameter name="strings" type="Gtk.Enums.String_List.Glist"/>
        <doc>Set all the items in the popup list.</doc>
     </method>
     <method id="gtk_combo_disable_activate">
        <doc>Disable the standard handler for the return key in the entry field. The default behavior is to popdown the combo box list, so that the user can choose from it. However, if you want to add your own callback for the return key, you need to call this subprogram, and connect a handler to the "activate" signal for the entry.</doc>
     </method>
     <method id="gtk_combo_set_item_string">
        <doc>Set the string to place in the Gtk_Entry field when a particular list item is selected. This is needed if the list item is not a simple label.</doc>
     </method>
     <method id="gtkada_GtkCombo_get_entry"  bind="True"/>
     <method id="gtkada_GtkCombo_set_entry"  bind="True"/>
     <method id="gtkada_GtkCombo_get_list"   bind="True"/>
     <method id="gtkada_GtkCombo_get_popwin" bind="True"/>
     <extra>
        <with_spec pkg="Gtk.Enums" />  <!--  for String_List -->
     </extra>
  </package>

  <package id="Gtk.Dialog">
     <doc group="Windows" testgtk="create_dialog.adb"
          screenshot="gtk-dialog">Dialog boxes are a convenient way to prompt the user for a small amount of input, eg. to display a message, ask a question, or anything else that does not require extensive effort on the user's part.

Gtkada treats a dialog as a window split horizontally. The top section is a Gtk_Vbox, and is where widgets such as a Gtk_Label or a Gtk_Entry should be packed. The second area is known as the action_area. This is generally used for packing buttons into the dialog which may perform functions such as cancel, ok, or apply. The two areas are separated by a Gtk_Hseparator.

If 'dialog' is a newly created dialog, the two primary areas of the window can be accessed using Get_Vbox and Get_Action_Area as can be seen from the example, below.

A 'modal' dialog (that is, one which freezes the rest of the application from user input), can be created by calling Set_Modal on the dialog.

See Gtkada.Dialogs for a higher level dialog interface.
     </doc>
     <parameter name="self" ada="Dialog" />
     <parameter name="response_id" type="Gtk_Response_Type"/>
     <method id="gtk_dialog_get_action_area" return="GtkBox*"/>
     <method id="gtk_dialog_get_content_area" return="GtkBox*"/>
     <method id="gtk_dialog_get_response_for_widget" return="GtkResponseType"/>
     <method id="gtk_dialog_run" return="GtkResponseType"/>
     <method id="gtkada_GtkDialog_get_vbox" bind="true" return="GtkBox*"/>
     <method id="gtk_dialog_add_button">
        <parameter name="button_text" ada="text"/>
     </method>

     <!-- Bound manually below -->
     <method id="gtk_dialog_set_alternative_button_order_from_array" bind="False"/>

     <!-- Following methods have varargs -->
     <method id="gtk_dialog_new_with_buttons" bind="False"/>
     <method id="gtk_dialog_add_buttons" bind="False"/>
     <method id="gtk_dialog_set_alternative_button_order" bind="False"/>

     <method id="ada_gtk_dialog_new_with_buttons">
        <parameter name="parent" default="null"/>
     </method>

     <extra>
        <gir:constructor c:identifier="ada_gtk_dialog_new_with_buttons"
             name="new" version="GtkAda 1.0">
             <gir:doc>Create a new dialog with a specific title, and specific attributes. Parent is the transient parent for the dialog (ie the one that is used for reference for the flag Destroy_With_Parent, or to compute the initial position of the dialog).</gir:doc>
           <gir:return-value>
              <gir:type name="GtkDialog" c:type="GtkDialog*"/>
           </gir:return-value>
           <gir:parameters>
              <gir:parameter name="title">
                 <gir:type name="utf8" c:type="gchar*"/>
              </gir:parameter>
              <gir:parameter name="parent">
                 <gir:type name="Window" c:type="GtkWindow*"/>
              </gir:parameter>
              <gir:parameter name="flags">
                 <gir:type name="DialogFlags" c:type="GtkDialogFlags"/>
              </gir:parameter>
           </gir:parameters>
        </gir:constructor>

        <spec>
   procedure Set_Alternative_Button_Order_From_Array
     (Dialog    : access Gtk_Dialog_Record;
      New_Order : Response_Type_Array);
   --  Sets an alternative button order. If the gtk-alternative-button-order
   --  setting is set to %TRUE, the dialog buttons are reordered according to
   --  the order of the response ids passed to this function.
   --
   --  By default, GTK+ dialogs use the button order advocated by the Gnome
   --  Human Interface Guidelines with the affirmative button at the far right,
   --  and the cancel button left of it. But the builtin GTK+ dialogs and
   --  message dialogs' do provide an alternative button order, which is more
   --  suitable on some platforms, e.g. Windows.
   --
   --  Use this function after adding all the buttons to your dialog.

   function Gtk_Alternative_Dialog_Button_Order
     (Screen : Gdk.Gdk_Screen := null)  return Boolean;
   --  Returns True if dialogs are expected to use an alternative button order
   --  on the given screen (or current screen if null) . See
   --  Set_Alternative_Button_Order_From_Array for more details about
   --  alternative button order.
   --
   --  If you need to use this function, you should probably connect to the
   --  ::notify:gtk-alternative-button-order signal on the Gtk_Settings object
   --  associated to Screen, in order to be notified if the button order
   --  setting changes.
   --
   --  Returns: Whether the alternative button order should be used
        </spec>
        <body>
   procedure Set_Alternative_Button_Order_From_Array
     (Dialog    : access Gtk_Dialog_Record;
      New_Order : Response_Type_Array)
   is
      procedure Internal
        (Dialog    : System.Address;
         N_Params  : Gint;
         New_Order : System.Address);
      pragma Import
        (C, Internal, "gtk_dialog_set_alternative_button_order_from_array");
   begin
      Internal (Get_Object (Dialog), New_Order'Length,
                New_Order (New_Order'First)'Address);
   end Set_Alternative_Button_Order_From_Array;

   function Gtk_Alternative_Dialog_Button_Order
     (Screen : Gdk.Gdk_Screen := null) return Boolean
   is
      function Internal (Screen : Gdk.Gdk_Screen) return Gboolean;
      pragma Import (C, Internal, "gtk_alternative_dialog_button_order");
   begin
      return Boolean'Val (Internal (Screen));
   end Gtk_Alternative_Dialog_Button_Order;
        </body>

        <type ctype="GtkDialogFlags" ada="Gtk_Dialog_Flags">
   type Gtk_Dialog_Flags is mod 8;
   for Gtk_Dialog_Flags'Size use Gint'Size;
   pragma Convention (C, Gtk_Dialog_Flags);
   Modal               : constant Gtk_Dialog_Flags := 2 ** 0;
   Destroy_With_Parent : constant Gtk_Dialog_Flags := 2 ** 1;
   No_Separator        : constant Gtk_Dialog_Flags := 2 ** 2;
   --  Various flags that can be set for the dialog, with the following
   --  implications:
   --     - Modal : the dialog is modal, see Gtk.Window.Set_Modal
   --     - Destroy_With_Parent: The dialog is destroyed if its parent is
   --       destroyed. See Gtk.Window.Set_Destroy_With_Parent
   --     - No_Separator: No separator bar above the buttons.
        </type>

        <type ctype="GtkResponseType" ada="Gtk_Response_Type">
   type Gtk_Response_Type is new Gint;
   --  Type used for Response_Id's.
   --  Positive values are totally user-interpreted.
   --  GtkAda will sometimes return Gtk_Response_None if no Response_Id is
   --  available.
   --
   --  Typical usage is:
   --    if Gtk.Dialog.Run (Dialog) = Gtk_Response_Accept then
   --       blah;
   --    end if;
   
   Gtk_Response_None : constant Gtk_Response_Type := -1;
   --  GtkAda returns this if a response widget has no Response_Id,
   --  or if the dialog gets programmatically hidden or destroyed.
   
   Gtk_Response_Reject : constant Gtk_Response_Type := -2;
   Gtk_Response_Accept : constant Gtk_Response_Type := -3;
   --  GtkAda won't return these unless you pass them in
   --  as the response for an action widget. They are
   --  for your convenience.
   
   Gtk_Response_Delete_Event : constant Gtk_Response_Type := -4;
   --  If the dialog is deleted through the button in the titlebar
   
   Gtk_Response_OK     : constant Gtk_Response_Type := -5;
   Gtk_Response_Cancel : constant Gtk_Response_Type := -6;
   Gtk_Response_Close  : constant Gtk_Response_Type := -7;
   Gtk_Response_Yes    : constant Gtk_Response_Type := -8;
   Gtk_Response_No     : constant Gtk_Response_Type := -9;
   Gtk_Response_Apply  : constant Gtk_Response_Type := -10;
   Gtk_Response_Help   : constant Gtk_Response_Type := -11;
   --  These are returned from dialogs, and you can also use them
   --  yourself if you like.
        </type>

        <type ctype="GtkResponseType*" ada="Response_Type_Array">
   type Response_Type_Array is array (Natural range &lt;&gt;) of Gtk_Response_Type;
        </type>
     </extra>
  </package>

  <package id="Gtk.Curve">
     <doc group="Drawing">
The Gtk_Curve widget allows the user to edit a curve covering a range of values. It is typically used to fine-tune color balances in graphics applications like the Gimp.

The Gtk_Curve widget has 3 modes of operation: spline, linear and free.  In spline mode the user places points on the curve which are automatically connected together into a smooth curve. In linear mode the user places points on the curve which are connected by straight lines. In free mode the user can draw the points of the curve freely, and they are not connected at all.
     </doc>
     <method id="gtk_curve_set_vector" bind="False"/>
     <method id="gtk_curve_get_vector" bind="False"/>
     <method id="gtk_curve_set_gamma">
        <doc>Recompute the entire curve using the given gamma value. A gamma value of 1.0 results in a straight line. Values greater than 1.0 result in a curve above the straight line. Values less than 1.0 result in a curve below the straight line. The curve type is changed to Curve_Type_Free.</doc>
     </method>
     <method id="gtk_curve_set_range">
        <doc>Set the minimum and maximum x &amp; y values of the curve. The curve is also reset with a call to Reset.</doc>
     </method>
     <method id="gtk_curve_set_curve_type">
        <doc>Set the type of the curve. The curve will remain unchanged except when changing from a free curve to a linear or spline curve, in which case the curve will be changed as little as possible.</doc>
     </method>
     <method id="gtk_curve_reset">
        <doc>Reset the curve. Reset to a straight line from the minimum x &amp; y values to the maximum x &amp; y values (i.e. from the bottom-left to the top-right corners). The curve type is not changed.</doc>
     </method>

     <extra>
        <spec>
   procedure Set_Vector
     (Curve  : access Gtk_Curve_Record; Vector : Gfloat_Array);
   procedure Get_Vector
     (Curve  : access Gtk_Curve_Record; Vector : out Gfloat_Array);
   --  Set the vector of points on the curve.
   --  The curve type is set to Curve_Type_Free.
       </spec>
       <body>
   procedure Get_Vector
     (Curve  : access Gtk_Curve_Record;
      Vector : out Gfloat_Array)
   is
      procedure Internal
        (Curve  : System.Address;
         Veclen : Integer;
         Vector : System.Address);
      pragma Import (C, Internal, "gtk_curve_get_vector");

   begin
      Internal (Get_Object (Curve), Vector'Length, Vector'Address);
   end Get_Vector;

   procedure Set_Vector
     (Curve  : access Gtk_Curve_Record;
      Vector : Gfloat_Array)
   is
      procedure Internal
        (Curve  : System.Address;
         Veclen : Integer;
         Vector : System.Address);
      pragma Import (C, Internal, "gtk_curve_set_vector");

   begin
      Internal (Get_Object (Curve), Vector'Length,
                Vector (Vector'First)'Address);
   end Set_Vector;
       </body>
    </extra>
  </package>

  <package id="Gtk.Expander">
     <doc group="Layout containers" screenshot="gtk-expanded">A container that can hide its child.</doc>
  </package>

  <package id="Gtk.Drawing_Area">
     <doc group="Drawing" testgtk="libart_demo.adb">
This widget provides an empty canvas on which the application can draw anything.

Note that this widget is simply an empty space, and that you need to connect it to events to make it useful. For instance, you might want to do one of the following :

* Connect it to "expose_event": The handlers are called every time the widget needs to be redrawn. You can then draw anything you want on the canvas, after getting its associated window with a call to Gtk.Widget.Get_Window. Note that the event mask is automatically set up to accept expose_events.

* Connect it to "button_press_event" and "button_release_event" events, when you want it to react to user input. Note that you need to set up the event mask with a call to Gtk.Widget.Set_Events.

See also the Double_Buffer widget provided in the GtkAda examples for an advanced example that demonstrates how to use double buffering, to avoid flickering in your drawings.</doc>
     <method id="gtk_drawing_area_size" obsolescent="True">
        <doc>Request a new size for the area. This queues a resize request for the area.</doc>
     </method>
  </package>

  <package id="Gtk.Adjustment">
     <doc group="Scrolling">This object represents an adjustable bounded value. It is used in many other widgets that have such internal values, like Gtk_Scrollbar, Gtk_Spin_Button, Gtk_Range, ... Modifying the value of these widgets is done through their associated adjustments.

The modification of the value is left to the user, who should call Value_Changed or Changed to emit the relevant signals.

The meaning of the most important fields can be explained on the following figure (imagine this is a scrollbar):

[-------|=================|-------------------]

lower    value        value + page_size       upper
     </doc>
     <parameter name="self" ada="Adjustment"/>
     <method id="gtk_adjustment_new">
        <parameter name="page_size" default="0.0"/>
        <doc>Create a new adjustment. Value is the initial value of the adjustment. It must be in the range (Lower .. Upper) and the adjustment's value will never be outside this range. Step_Increment is the value used to make minor adjustments, such as when the user clicks on the arrows of a scrollbar. Page_Increment is used to make major adjustments, such as when the user clicks in the through on a scrollbar. Page_Size is deprecated, use the default value.</doc>
     </method>
     <method id="gtk_adjustment_clamp_page">
        <doc>Update the Adjustment value to ensure that the range between Lower and Upper is in the current page (i.e. between value and value + page_size). If the range is larger than the page size, then only the start of it will be in the current page. A "value_changed" signal will be emitted if the value is changed.</doc>
     </method>
  </package>

  <package id="Gtk.Image">
     <doc group="Display widgets" screenshot="gtk-image">The Gtk_Image widget displays a graphical image. The image is typically created using Gdk.Image.Gdk_New.

The pixels in a Gtk_Image may be manipulated by the application after creation, as Gtk_Image store the pixel data on the client side. If you wish to store the pixel data on the server side (thus not allowing manipulation of the data after creation) you should use Gtk_Pixmap.</doc>
     <parameter name="size" type="Gtk.Enums.Gtk_Icon_Size"/>
     <method id="gtk_image_new_from_animation" ada="Gtk_New"/>
     <method id="gtk_image_new_from_file"      ada="Gtk_New"/>
     <method id="gtk_image_new_from_image"     ada="Gtk_New"/>
     <method id="gtk_image_new_from_pixbuf"    ada="Gtk_New"/>
     <method id="gtk_image_new_from_icon_set"  ada="Gtk_New"/>
     <method id="gtk_image_new_from_pixmap"    ada="Gtk_New"/>
     <method id="gtk_image_new_from_stock"     ada="Gtk_New"/>
     <method id="gtk_image_get_animation"      ada="Get"/>
     <method id="gtk_image_set_from_animation" ada="Set"/>
     <method id="gtk_image_get_image"          ada="Get"/>
     <method id="gtk_image_get" bind="False"/> <!-- same as get_image -->
     <method id="gtk_image_set_from_image"     ada="Set"/>
     <method id="gtk_image_set" bind="False"/> <!-- same as set_from_image -->
     <method id="gtk_image_get_pixbuf"         ada="Get"/>
     <method id="gtk_image_set_from_pixbuf"    ada="Set"/>
     <method id="gtk_image_get_icon_set"       ada="Get"/>
     <method id="gtk_image_set_from_icon_set"  ada="Set"/>
     <method id="gtk_image_get_pixmap"         ada="Get"/>
     <method id="gtk_image_set_from_pixmap"    ada="Set"/>
     <method id="gtk_image_get_stock"          ada="Get" bind="False"/>
     <method id="gtk_image_set_from_stock"     ada="Set"/>
     <method id="gtk_image_get_gicon"          ada="Get"/>
     <method id="gtk_image_set_from_gicon"     ada="Set"/>
     <method id="gtk_image_set_from_file"      ada="Set"/>
     <method id="gtk_image_get_icon_name"      ada="Get" bind="False"/>
     <extra>
        <type ctype="GtkImageType" ada="Gtk_Image_Type">
   type Gtk_Image_Type is
     (Image_Empty,
      Image_Pixmap,
      Image_Image,
      Image_Pixbuf,
      Image_Stock,
      Image_Icon_Set,
      Image_Animation,
      Image_Icon_Name,
      Image_Gicon);
   pragma Convention (C, Gtk_Image_Type);
        </type>
        <with_spec pkg="GNAT.Strings"/>
        <spec>
   function Get
     (Image : access Gtk_Image_Record;
      Size  : access Gtk.Enums.Gtk_Icon_Size) return String;
   --  Get the stock_id for the image displayed

   procedure Get_Icon_Name
     (Image : access Gtk_Image_Record;
      Name  : out GNAT.Strings.String_Access;
      Size  : out Gtk.Enums.Gtk_Icon_Size);
        </spec>
        <body>
   procedure Get_Icon_Name
     (Image : access Gtk_Image_Record;
      Name  : out GNAT.Strings.String_Access;
      Size  : out Gtk_Icon_Size)
   is
      procedure Internal
        (Image : System.Address;
         Name  : out Interfaces.C.Strings.chars_ptr;
         Size  : out Gtk_Icon_Size);
      pragma Import (C, Internal, "gtk_image_get_icon_name");
      Str : chars_ptr;
   begin
      Internal (Get_Object (Image), Str, Size);
      Name := new String'(Value (Str));
   end Get_Icon_Name;

   function Get
     (Image : access Gtk_Image_Record;
      Size  : access Gtk.Enums.Gtk_Icon_Size) return String
   is
      procedure Internal
        (Image    : System.Address;
         Stock_Id : out Interfaces.C.Strings.chars_ptr;
         Size     : out Gint);
      pragma Import (C, Internal, "gtk_image_get_stock");

      Stock : Interfaces.C.Strings.chars_ptr;
      Sze   : Gint;

   begin
      Internal (Get_Object (Image), Stock, Sze);
      Size.all := Gtk.Enums.Gtk_Icon_Size'Val (Sze);
      return Interfaces.C.Strings.Value (Stock);
   end Get;

        </body>
     </extra>
  </package>

</GIR>
