<?xml version="1.0"?>

<!--  This file overrides parts of the .gir files. -->

<GIR xmlns:gir="http://www.gtk.org/introspection/core/1.0"
     xmlns:c="http://www.gtk.org/introspection/c/1.0">

   <!-- ################################################
        Gdk.Device
        ################################################-->

   <package id="GdkDevice">
      <enum ctype="GdkDeviceType" />
      <list ada="Device_List" ctype="GdkDevice"/>
      <method id="::changed" bind="False" /> <!-- elaboration circularity -->
      <method id="gdk_device_get_axis" bind="False" /><!-- need support for array of gdoubles -->
      <method id="gdk_device_get_axis_value" bind="False" /><!-- need support for array of gdoubles -->
      <method id="gdk_device_get_history" bind="False" /><!-- need support for array of Gdk_Time_Coord -->
      <method id="gdk_device_free_history" bind="False" /><!-- no need while we don't bind get_history -->
      <method id="gdk_device_grab_info_libgtk_only" bind="False" /><!-- not part of library -->
      <method id="gdk_device_get_key" return="" bind="False"/><!-- pending L118-010 -->
      <method id="gdk_device_get_window_at_position" bind="False"/><!-- below -->
      <method id="gdk_device_get_position" bind="False"/><!-- pending resolution of a problem with generating the stub object -->
      <method id="gdk_device_list_axes" bind="False"/><!-- no support for atom lists -->
      <method id="gdk_device_list_slave_devices" bind="False"/><!-- no support
      for Gdk_Device_Type_Master lists -->

      <extra>
         <spec>
   procedure Get_Window_At_Position
      (Self   : not null access Gdk_Device_Record;
       Win_X  : out Gint;
       Win_Y  : out Gint;
       Window : out Gdk.Gdk_Window);
   --  Obtains the window underneath Device, returning the location of the
   --  device in Win_X and Win_Y. Returns null if the window tree under Device
   --  is not known to GDK (for example, belongs to another application).
   --  As a slave device coordinates are those of its master pointer, This
   --  function may not be called on devices of type
   --  Gdk.Device.Gdk_Device_Type_Slave, unless there is an ongoing grab on
   --  them, see Gdk.Device.Grab.
   --  Since: gtk+ 3.0
   --  "win_x": return location for the X coordinate of the device location,
   --  relative to the window origin, or null.
   --  "win_y": return location for the Y coordinate of the device location,
   --  relative to the window origin, or null.

   procedure Set_Device
      (Event   : Gdk.Event.Gdk_Event;
       Device  : not null access Gdk_Device_Record);
   --  Sets the device for Event to Device. The event must
   --  have been allocated by GTK+, for instance, by gdk_event_copy().

   procedure Set_Source_Device
      (Event   : Gdk.Event.Gdk_Event;
       Device  : not null access Gdk_Device_Record);
   --  Sets the slave device for Event to Device.
   --  The event must have been allocated by GTK+,
   --  for instance by gdk_event_copy().
         </spec>
         <body>
   procedure Set_Source_Device
      (Event  : Gdk.Event.Gdk_Event;
       Device : not null access Gdk_Device_Record)
   is
      procedure Internal (Event : Gdk.Event.Gdk_Event; D : System.Address);
      pragma Import (C, Internal, "gdk_event_set_source_device");
   begin
      Internal (Event, Get_Object (Device));
   end Set_Source_Device;

   procedure Set_Device
      (Event  : Gdk.Event.Gdk_Event;
       Device : not null access Gdk_Device_Record)
   is
      procedure Internal (Event : Gdk.Event.Gdk_Event; D : System.Address);
      pragma Import (C, Internal, "gdk_event_set_device");
   begin
      Internal (Event, Get_Object (Device));
   end Set_Device;

   procedure Get_Window_At_Position
      (Self   : not null access Gdk_Device_Record;
       Win_X  : out Gint;
       Win_Y  : out Gint;
       Window : out Gdk.Gdk_Window)
   is
      function Internal
         (Self      : System.Address;
          Acc_Win_X : access Gint;
          Acc_Win_Y : access Gint) return Gdk.Gdk_Window;
      pragma Import (C, Internal, "gdk_device_get_window_at_position");
      Acc_Win_X  : aliased Gint;
      Acc_Win_Y  : aliased Gint;
   begin
      Window := Internal (Get_Object (Self), Acc_Win_X'Access, Acc_Win_Y'Access);
      Win_X := Acc_Win_X;
      Win_Y := Acc_Win_Y;
   end Get_Window_At_Position;
         </body>
      </extra>
   </package>

   <!-- ################################################
        Gdk.Drag_Contexts
        ################################################-->

   <package id="GdkDragContext">
      <enum ctype="GdkDragAction" prefix="GDK_"/>
      <enum ctype="GdkDragProtocol" prefix="GDK_"/>
      <method id="gdk_drag_context_list_targets" bind="False"/><!-- not supposed to be used by applications -->
   </package>

   <!-- ################################################
        Gdk.Screen
        ################################################-->

   <package id="GdkScreen">
     <doc group="Gdk, the low-level API"/>
     <parameter name="self" ada="Screen"/>
     <method id="gdk_screen_get_setting" bind="False" />
     <method id="::composited-changed" bind="False" /> <!-- elaboration circularity -->
     <method id="::monitors-changed" bind="False" /> <!-- elaboration circularity -->
     <method id="::size-changed" bind="False" /> <!-- elaboration circularity -->

     <method id="gdk_screen_get_toplevel_windows" return="WindowList" bind="False"/>  <!--  circular dep -->
     <method id="gdk_screen_get_window_stack" return="WindowList" bind="False"/> <!-- circular dep with GdkWindow-->
     <method id="gdk_screen_list_visuals" return="WindowList" bind="False"/> <!-- circular dep with GdkWindow-->
     <extra>
       <with_spec pkg="Gdk.Types" />
       <spec>
   -------------
   -- Display --
   -------------
   --  These subprograms should really be in gdk-display.ads to match what is
   --  done for gtk+ itself, but that would create dependency circularities.
   --  Ada 2005 has support for these, but we want GtkAda to build with Ada95
   --  compilers.

   function Get_Screen
     (Display    : access Gdk.Display.Gdk_Display_Record'Class;
      Screen_Num : Glib.Gint)
      return Gdk_Screen;
   --  Returns a screen object for one of the screens of the display.

   function Get_Default_Screen
     (Display : access Gdk.Display.Gdk_Display_Record'Class) return Gdk_Screen;
   --  Get the default Gdk_Screen for display.

   procedure Get_Pointer
     (Display : access Gdk.Display.Gdk_Display_Record'Class;
      Screen  : out Gdk_Screen;
      X       : out Glib.Gint;
      Y       : out Glib.Gint;
      Mask    : out Gdk.Types.Gdk_Modifier_Type);
   --  Gets the current location of the pointer and the current modifier
   --  mask for a given display.
   --  (X, Y) are coordinates relative to the root window on the display

   procedure Warp_Pointer
     (Display : access Gdk.Display.Gdk_Display_Record'Class;
      Screen  : access Gdk_Screen_Record;
      X       : Glib.Gint;
      Y       : Glib.Gint);
   --  Warps the pointer of display to the point x,y on the screen screen,
   --  unless the pointer is confined to a window by a grab, in which case it
   --  will be moved as far as allowed by the grab. Warping the pointer creates
   --  events as if the user had moved the mouse instantaneously to the
   --  destination.
   --
   --  Note that the pointer should normally be under the control of the user.
   --  This function was added to cover some rare use cases like keyboard
   --  navigation support for the color picker in the GtkColorSelectionDialog.
       </spec>
       <body>
   function Get_Screen
     (Display    : access Gdk_Display_Record'Class;
      Screen_Num : Gint)
      return Gdk_Screen
   is
      function Internal
        (Display    : System.Address;
         Screen_Num : Gint)
         return System.Address;
      pragma Import (C, Internal, "gdk_display_get_screen");
      --  External binding: gdk_display_get_screen
      Stub : Gdk_Screen_Record;
   begin
      return Gdk_Screen
        (Get_User_Data
          (Internal (Get_Object (Display), Screen_Num), Stub));
   end Get_Screen;

   function Get_Default_Screen
     (Display : access Gdk_Display_Record'Class)
      return Gdk_Screen
   is
      function Internal
        (Display : System.Address)
         return System.Address;
      pragma Import (C, Internal, "gdk_display_get_default_screen");
      --  External binding: gdk_display_get_default_screen
      Stub : Gdk_Screen_Record;
   begin
      return Gdk_Screen
        (Get_User_Data
          (Internal (Get_Object (Display)), Stub));
   end Get_Default_Screen;

   procedure Get_Pointer
     (Display : access Gdk_Display_Record'Class;
      Screen  : out Gdk_Screen;
      X       : out Gint;
      Y       : out Gint;
      Mask    : out Gdk_Modifier_Type)
   is
      procedure Internal
        (Display : System.Address;
         Screen  : out System.Address;
         X       : out Gint;
         Y       : out Gint;
         Mask    : out Gdk_Modifier_Type);
      pragma Import (C, Internal, "gdk_display_get_pointer");
      --  External binding: gdk_display_get_pointer

      S    : System.Address;
      Stub : Gdk_Screen_Record;

   begin
      Internal (Get_Object (Display), S, X, Y, Mask);
      Screen := Gdk_Screen (Get_User_Data (S, Stub));
   end Get_Pointer;

   procedure Warp_Pointer
     (Display : access Gdk.Display.Gdk_Display_Record'Class;
      Screen  : access Gdk_Screen_Record;
      X       : Glib.Gint;
      Y       : Glib.Gint)
   is
      procedure Internal (D, S : System.Address; X, Y : Gint);
      pragma Import (C, Internal, "gdk_display_warp_pointer");
      --  External binding: gdk_display_warp_pointer
   begin
      Internal (Get_Object (Display), Get_Object (Screen), X, Y);
   end Warp_Pointer;
       </body>
     </extra>
   </package>

   <!-- ################################################
        Gtk.Aspect_Frame
        ################################################-->

   <package id="GtkAspectFrame">
     <doc testgtk="create_frame.adb" group="Layout Containers"/>
     <parameter name="self" ada="Aspect_Frame"/>
     <method id="gtk_aspect_frame_new">
       <parameter name="label" default='""' allow-none="1"/>
     </method>
   </package>

   <!-- ###################################################
        Gtk.Button
        ###################################################-->

   <package id="GtkButton">
      <doc screenshot="gtk-button" group="Buttons and Toggles"
           testgtk="create_buttons.adb"/>
      <parameter name="self" ada="Button"/>
      <method id="gtk_button_new" bind="False"/>
      <method id="gtk_button_new_with_label" ada="Gtk_New" >
         <parameter name="label" default='""' allow-none="1"/>
      </method>
   </package>

   <!-- ###################################################
        Gtk.Cell_Area
        ###################################################-->

   <package id="GtkCellArea">
      <doc group="Layout Containers"/>
      <method id="gtk_cell_area_cell_get_valist" bind="False"/><!-- va_list -->
      <method id="gtk_cell_area_cell_set_valist" bind="False"/><!-- va_list -->
      <method id="gtk_cell_area_add_with_properties" bind="False"/><!-- varargs-->
      <method id="gtk_cell_area_cell_get" bind="False"/><!-- varargs-->
      <method id="gtk_cell_area_cell_set" bind="False"/><!-- varargs-->
      <method id="gtk_cell_area_get_cell_allocation">
         <parameter name="cell_area" direction="access" />
         <parameter name="allocation" direction="access" />
      </method>
      <method id="gtk_cell_area_get_focus_siblings" return="ObjectList"/>
      <method id="gtk_cell_area_get_cell_at_position" bind="False"/>
      <!-- bound manually below -->
      <extra>
        <spec>
   function Get_Area
      (Context : access Gtk_Cell_Area_Context_Record)
       return Gtk.Cell_Area.Gtk_Cell_Area;
   --  Fetches the Gtk.Cell_Area.Gtk_Cell_Area this Context was created by.
   --  This is generally unneeded by layouting widgets; however it is important
   --  for the context implementation itself to fetch information about the
   --  area it is being used for.
   --  For instance at GtkCellAreaContextClass.allocate time its important to
   --  know details about any cell spacing that the Gtk.Cell_Area.Gtk_Cell_Area
   --  is configured with in order to compute a proper allocation.
   --  Since: gtk+ 3.0

   function Get_Area
      (Cell_Layout : Gtk_Cell_Layout) return Gtk.Cell_Area.Gtk_Cell_Area;
   --  Returns the underlying Gtk.Cell_Area.Gtk_Cell_Area which might be
   --  Cell_Layout if called on a Gtk.Cell_Area.Gtk_Cell_Area or might be null
   --  if no Gtk.Cell_Area.Gtk_Cell_Area is used by Cell_Layout.
   --  Since: gtk+ 3.0

   procedure Get_Cell_At_Position
      (Self       : access Gtk_Cell_Area_Record;
       Context    : access Gtk.Cell_Area_Context.Gtk_Cell_Area_Context_Record'Class;
       Widget     : access Gtk.Widget.Gtk_Widget_Record'Class;
       Cell_Area  : Gdk.Rectangle.Gdk_Rectangle;
       X          : Gint;
       Y          : Gint;
       Alloc_Area : out Gdk.Rectangle.Gdk_Rectangle;
       Renderer   : out Gtk.Cell_Renderer.Gtk_Cell_Renderer);
   --  Gets the Gtk.Cell_Renderer.Gtk_Cell_Renderer at X and Y coordinates
   --  inside Area and optionally returns the full cell allocation for it
   --  inside Cell_Area.
   --  Since: gtk+ 3.0
   --  "context": the Gtk.Cell_Area_Context.Gtk_Cell_Area_Context used to hold
   --  sizes for Area.
   --  "widget": the Gtk.Widget.Gtk_Widget that Area is rendering on
   --  "cell_area": the whole allocated area for Area in Widget for this row
   --  "x": the x position
   --  "y": the y position
   --  "alloc_area": where to store the inner allocated area of the returned
   --  cell renderer, or null.
   --  "renderer": the rendered that was found.
        </spec>
        <body>
   --------------
   -- Get_Area --
   --------------

   function Get_Area
      (Context : access Gtk_Cell_Area_Context_Record)
       return Gtk.Cell_Area.Gtk_Cell_Area
   is
      function Internal (Context : System.Address) return System.Address;
      pragma Import (C, Internal, "gtk_cell_area_context_get_area");
      Stub_Gtk_Cell_Area : Gtk.Cell_Area.Gtk_Cell_Area_Record;
   begin
      return Gtk.Cell_Area.Gtk_Cell_Area
        (Get_User_Data (Internal (Get_Object (Context)), Stub_Gtk_Cell_Area));
   end Get_Area;

   --------------
   -- Get_Area --
   --------------

   function Get_Area
      (Cell_Layout : Gtk_Cell_Layout) return Gtk.Cell_Area.Gtk_Cell_Area
   is
      function Internal
         (Cell_Layout : Gtk_Cell_Layout) return System.Address;
      pragma Import (C, Internal, "gtk_cell_layout_get_area");
      Stub_Gtk_Cell_Area : Gtk.Cell_Area.Gtk_Cell_Area_Record;
   begin
      return Gtk.Cell_Area.Gtk_Cell_Area (Get_User_Data (Internal (Cell_Layout), Stub_Gtk_Cell_Area));
   end Get_Area;

   --------------------------
   -- Get_Cell_At_Position --
   --------------------------

   procedure Get_Cell_At_Position
      (Self       : access Gtk_Cell_Area_Record;
       Context    : access Gtk.Cell_Area_Context.Gtk_Cell_Area_Context_Record'Class;
       Widget     : access Gtk.Widget.Gtk_Widget_Record'Class;
       Cell_Area  : Gdk.Rectangle.Gdk_Rectangle;
       X          : Gint;
       Y          : Gint;
       Alloc_Area : out Gdk.Rectangle.Gdk_Rectangle;
       Renderer   : out Gtk.Cell_Renderer.Gtk_Cell_Renderer)
   is
      function Internal
         (Self           : System.Address;
          Context        : System.Address;
          Widget         : System.Address;
          Cell_Area      : Gdk.Rectangle.Gdk_Rectangle;
          X              : Gint;
          Y              : Gint;
          Acc_Alloc_Area : access Gdk.Rectangle.Gdk_Rectangle)
          return System.Address;
      pragma Import (C, Internal, "gtk_cell_area_get_cell_at_position");
      Acc_Alloc_Area         : aliased Gdk.Rectangle.Gdk_Rectangle;
      Stub_Gtk_Cell_Renderer : Gtk.Cell_Renderer.Gtk_Cell_Renderer_Record;
      Tmp_Return             : System.Address;
   begin
      Tmp_Return := Internal
        (Get_Object (Self), Get_Object (Context), Get_Object (Widget),
         Cell_Area, X, Y, Acc_Alloc_Area'Access);
      Alloc_Area := Acc_Alloc_Area;
      Renderer := Gtk.Cell_Renderer.Gtk_Cell_Renderer
        (Get_User_Data (Tmp_Return, Stub_Gtk_Cell_Renderer));
   end Get_Cell_At_Position;
        </body>
      </extra>
   </package>

   <!-- ###################################################
        Gtk.Cell_Area_Context
        ###################################################-->

   <package id="GtkCellAreaContext">
      <doc group="Layout Containers"/>
      <method id="gtk_cell_area_context_get_area" bind="False"/>
      <!-- in Gtk.Cell_Area -->
   </package>

   <!-- ################################################
        Gtk.Color_Selection
        ################################################-->

   <package id="GtkColorSelection">
      <doc testgtk="create_color_selection.adb"
           screenshot="gtk-colorsel"
           group="Drawing">
A Gtk_Color_Selection widget is a complex dialog that allows the user
to select a color based either on its (Red, Green, Blue) or its
(Hue, Saturation, Value).
An additional field is provided to select the opacity of the color (this
is usually called the alpha channel).

See Gtk.Color_Selection_Dialog for a version of this widget that comes with
its own dialog.

See Gtk.Extra.Color_Combo for a different way to select colors.
      </doc>
     <parameter name="self" ada="Colorsel"/>

     <!-- Bound manually below -->
     <method id="gtk_color_selection_palette_from_string" bind="False"/>
     <method id="gtk_color_selection_palette_to_string" bind="False"/>

     <extra>
        <spec>
   type Gtk_Color_Selection_Change_Palette_With_Screen_Func is access procedure
      (Screen   : System.Address;  --  Convert to Gdk_Screen with Get_User_Data
       Colors   : Gdk.Color.Gdk_Color_Unconstrained_Array;
       N_Colors : Gint);
   pragma Convention (C, Gtk_Color_Selection_Change_Palette_With_Screen_Func);
   --  This function should save the new palette contents, and update the
   --  Gtk_Settings property "gtk-color-palette" so all Gtk_Color_Selection
   --  widgets will be modified, including the current one. For instance, you
   --  would do:
   --    Set_String_Property
   --      (Get_Default, Gtk_Color_Palette, Palette_To_String (Colors), "Foo");

   function Palette_From_String
     (Str : String) return Gdk.Color.Gdk_Color_Array;
   --  Parses a color palette string. This string is a colon-separated list of
   --  color names readable by Gdk.Color.Parse.
   --  An empty array is returned if Str couldn't be parsed

   function Palette_To_String
     (Colors   : Gdk.Color.Gdk_Color_Array) return String;
   --  Encodes a palette as a string, useful for persistent storage.
        </spec>

        <with_body pkg="Gtkada.C"/>
        <with_body pkg="Interfaces.C.Strings"/>

        <body>
   package Color_Arrays is new Gtkada.C.Unbounded_Arrays
     (Gdk.Color.Gdk_Color, Gdk.Color.Null_Color, Natural,
      Gdk.Color.Gdk_Color_Array);

   function Palette_From_String (Str : String) return Gdk_Color_Array is
      use Color_Arrays;
      function Internal
        (Str : String;
         Colors : access Unbounded_Array_Access; N : access Gint)
         return Gboolean;
      pragma Import (C, Internal, "gtk_color_selection_palette_from_string");

      N      : aliased Gint;
      Output : aliased Unbounded_Array_Access;
   begin
      if Internal (Str &amp; ASCII.NUL, Output'Access, N'Access) = 0 then
         Output := null;
      end if;

      declare
         Result : constant Gdk_Color_Array := To_Array (Output, Integer (N));
      begin
         G_Free (Output);
         return Result;
      end;
   end Palette_From_String;

   function Palette_To_String (Colors : Gdk_Color_Array) return String is
      function Internal
        (Colors   : System.Address;
         N_Colors : Gint)
         return Interfaces.C.Strings.chars_ptr;
      pragma Import (C, Internal, "gtk_color_selection_palette_to_string");
      Str : chars_ptr;
   begin
      if Colors'Length = 0 then
         return "";
      else
         Str := Internal (Colors (Colors'First)'Address, Colors'Length);
         declare
            Result : constant String := Value (Str);
         begin
            Free (Str);
            return Result;
         end;
      end if;
   end Palette_To_String;
       </body>
     </extra>
   </package>

   <!-- ################################################
        Gtk.Color_Selection_Dialog
        ################################################-->

   <package id="GtkColorSelectionDialog">
      <doc group="Drawing">
The Gtk_Color_Selection_Dialog provides a standard dialog which allows the
user to select a color much like the Gtk_File_Selection provides a standard
dialog for file selection.
      </doc>
     <parameter name="self" ada="Color_Selection_Dialog"/>
     <method id="gtk_color_selection_dialog_get_color_selection"
         return="GtkColorSelection">
     </method>
   </package>

   <!-- ################################################
        Gtk.Combo_Box
        ################################################-->

   <package id="GtkComboBox">
     <doc group="Numeric/Text Data Entry"/>
     <parameter name="self" ada="Combo_Box"/>
     <method id="gtk_combo_box_popup_for_device" bind="False" />
     <method id="gtk_combo_box_get_popup_accessible" bind="False" />
     <method id="gtk_combo_box_get_active_iter" bind="False"/> <!-- below-->
     <extra>

         <with_body pkg="Gtk.GEntry" />
        <spec>
   function Get_Active_Iter
     (Combo_Box : not null access Gtk_Combo_Box_Record)
      return Gtk.Tree_Model.Gtk_Tree_Iter;
   --  Return the currently active iter

   function Get_Active_Text
     (Combo_Box : not null access Gtk_Combo_Box_Record)
      return UTF8_String;
   --  Return the text present in the entry if it has one, or the empty string

        </spec>
        <body>
   function Get_Active_Iter
     (Combo_Box : not null access Gtk_Combo_Box_Record) return Gtk_Tree_Iter
   is
      function Internal
        (Combo_Box : System.Address;
         Iter      : System.Address)
         return Gboolean;
      pragma Import (C, Internal, "gtk_combo_box_get_active_iter");
      Iter : aliased Gtk_Tree_Iter;
      Tmp  : constant Gboolean := Internal
        (Get_Object (Combo_Box), Iter'Address);
   begin
      if Tmp /= 0 then
         return Iter;
      else
         return Null_Iter;
      end if;
   end Get_Active_Iter;

   function Get_Active_Text
     (Combo_Box : not null access Gtk_Combo_Box_Record)
      return UTF8_String is
   begin
      if not Combo_Box.Get_Has_Entry then
         return "";
      end if;

      return Gtk_Entry (Combo_Box.Get_Child).Get_Text;
   end Get_Active_Text;

        </body>
     </extra>
   </package>

   <!-- ################################################
        Gtk.Combo_Box_Text
        ################################################-->

   <package id="GtkComboBoxText">
     <doc group="Numeric/Text Data Entry"/>
   </package>

   <!-- ################################################
        Gtk.EventBox
        ################################################-->

   <package id="GtkEventBox">
     <doc group="Layout Containers"/>
     <parameter name="self" ada="Event_Box"/>
     <method id="gtk_event_box_new">
         <doc>
Create a new box.

The box's child can then be set using the Gtk.Container.Add function.
         </doc>
     </method>
   </package>


   <!-- ################################################
        Gtk.Font_Selection
        ################################################-->

   <package id="GtkFontSelection">
      <doc testgtk="create_font_selection.adb"
           screenshot="gtk-fontsel"
           group="Selectors">
This widget provides a nice way for the user of your application to
select fonts.
It first searches on your system for the list of fonts available, and
displays a set of boxes to select them based on their name, their
weight, their size, etc.
This widget is provided in two forms, one widget that can be embedded
in any container, a Gtk_Font_Selection, whereas the other one comes
directly in its own separate window (to be popped up as a dialog).

Some filters can be applied to the widget, when you want the user to
select only a font only among a specific subset (like bitmap or
true-type fonts for instance).
There are two kinds of filters: a base filter, set in your application
and that the user can not change; a user filter that can be modified
interactively by the user.
      </doc>
     <parameter name="self" ada="Fontsel"/>
     <method id="gtk_font_selection_get_family" bind="False"/>
     <method id="gtk_font_selection_get_face" bind="False"/>
   </package>

   <!-- ################################################
        Gtk.Font_Selection_Dialog
        ################################################-->

   <package id="GtkFontSelectionDialog">
      <doc testgtk="create_font_selection.adb"
           screenshot="gtk-fontsel"
           group="Selectors">
This widget provides a dialog for selecting a font.
See also Gtk.Font_Selection.
      </doc>
     <parameter name="self" ada="Dialog"/>
   </package>

   <!-- ###################################################
        Gtk.Frame
        ###################################################-->
   <package id="GtkFrame">
      <doc screenshot="gtk-frame" testgtk="create_frame.adb"
           group="Ornaments">
This is a very convenient widget to visually group related widgets (like
groups of buttons for instance), possibly with a title to explain the
purpose of this group.

A Gtk_Frame has only one child, so you have to put a container like for
instance a Gtk_Box inside if you want the frame to surround multiple
widgets.
      </doc>
      <parameter name="self" ada="Frame"/>

      <method id="gtk_frame_new">
         <parameter name="label" default='""' allow-none="1"/>
      </method>
   </package>

   <!-- ################################################
        Gtk.Label
        ################################################-->

   <package id="GtkLabel">
      <doc screenshot="gtk-label" testgtk="create_label.adb"
           group="Display widgets"/>
      <parameter name="self" ada="Label"/>
      <method id="gtk_label_new">
         <parameter name="str" default='""'/>
      </method>
      <method id="gtk_label_get" bind="false"/>
      <method id="gtk_label_select_region">
         <parameter name="start_offset" default="-1"/>
         <parameter name="end_offset" default="-1"/>
      </method>
      <method id="gtk_label_get_selection_bounds"
         return_as_param="Has_Selection"/>
      <method id="gtk_label_set_pattern">
         <doc>
Change the underlines pattern.

Pattern is a simple string made of underscore and space characters,
matching the ones in the string. GtkAda will underline every letter
that matches an underscore.

An empty string disables the underlines.

example: If the text is FooBarBaz and the Pattern is "___   ___"
then both "Foo" and "Baz" will be underlined, but not "Bar".
         </doc>
      </method>
   </package>

   <!-- ###################################################
        Gtk.Notebook
        ###################################################-->

   <package id="GtkNotebook">
      <enum ctype="GtkNotebookTab"/>
      <doc screenshot="gtk-notebook" group="Layout containers"
           testgtk="create_notebook.adb"/>
      <parameter name="self" ada="Notebook"/>
      <method id="gtk_notebook_set_scrollable">
         <parameter name="scrollable" default="True" />
      </method>
      <method id="gtk_notebook_set_tab_reorderable">
         <parameter name="reorderable" default="True" />
      </method>
      <method id="gtk_notebook_set_current_page">
         <parameter name="page_num" default="-1" />
      </method>
      <method id="gtk_notebook_set_show_border">
         <parameter name="show_border" default="True" />
      </method>
      <method id="gtk_notebook_append_page_menu" return="void" />
      <method id="gtk_notebook_set_show_tabs">
         <parameter name="show_tabs" default="True" />
      </method>
      <method id="gtk_notebook_set_tab_detachable">
         <parameter name="detachable" default="True" />
      </method>
      <extra>
        <spec>
   procedure Append_Page
     (Notebook  : access Gtk_Notebook_Record;
      Child     : access Gtk.Widget.Gtk_Widget_Record'Class);
   procedure Append_Page
     (Notebook  : access Gtk_Notebook_Record;
      Child     : access Gtk.Widget.Gtk_Widget_Record'Class;
      Tab_Label : access Gtk.Widget.Gtk_Widget_Record'Class);
   procedure Prepend_Page
     (Notebook  : access Gtk_Notebook_Record;
      Child     : access Gtk.Widget.Gtk_Widget_Record'Class;
      Tab_Label : access Gtk.Widget.Gtk_Widget_Record'Class);
   --  Convenience functions, same as above but discarding the return value.
        </spec>
        <body>
   procedure Append_Page
     (Notebook  : access Gtk_Notebook_Record;
      Child     : access Gtk.Widget.Gtk_Widget_Record'Class)
   is
      Ignored : Gint;
      pragma Unreferenced (Ignored);
   begin
      Ignored := Append_Page (Notebook, Child, null);
   end Append_Page;

   procedure Append_Page
     (Notebook  : access Gtk_Notebook_Record;
      Child     : access Gtk.Widget.Gtk_Widget_Record'Class;
      Tab_Label : access Gtk.Widget.Gtk_Widget_Record'Class)
   is
      Ignored : Gint;
      pragma Unreferenced (Ignored);
   begin
      Ignored := Append_Page (Notebook, Child, Tab_Label);
   end Append_Page;

   procedure Prepend_Page
     (Notebook  : access Gtk_Notebook_Record;
      Child     : access Gtk.Widget.Gtk_Widget_Record'Class;
      Tab_Label : access Gtk.Widget.Gtk_Widget_Record'Class)
   is
      Ignored : Gint;
      pragma Unreferenced (Ignored);
   begin
      Ignored := Append_Page (Notebook, Child, Tab_Label);
   end Prepend_Page;
        </body>
      </extra>
   </package>

   <!-- ################################################
        Gtk.Paned
        ################################################-->

   <package id="GtkPaned">
      <doc screenshot="gtk-paned" testgtk="create_paned.adb"
           group="Layout container"/>
      <parameter name="self" ada="Paned"/>
      <method id="gtk_paned_pack1">
         <parameter name="self" ada="Paned"/>
         <parameter name="resize" default="False" />
         <parameter name="shrink" default="True" />
         <doc>
Add a child to the top or left pane.
You can not change dynamically the attributes Resize and Shrink.
Instead, you have to remove the child from the container, and put it
back with the new value of the attributes. You should also first
call Glib.Object.Ref on the child so as to be sure it is not destroyed
when you remove it, and Glib.Object.Unref it at the end. See the
example in testgtk/ in the GtkAda distribution.
         </doc>
      </method>
      <method id="gtk_paned_pack2">
         <parameter name="self" ada="Paned"/>
         <parameter name="resize" default="False" />
         <parameter name="shrink" default="False" />
      </method>
      <method id="gtk_paned_add1">
         <parameter name="self" ada="Paned"/>
         <doc>
Add the first child of the container.
The child will be displayed either in the top or in the left pane,
depending on the orientation of the container.
This is equivalent to using the Pack1 procedure with its default parameters.
         </doc>
      </method>
      <method id="gtk_paned_add2">
         <parameter name="self" ada="Paned"/>
         <doc>
Add the second child of the container.
It will be displayed in the bottom or right pane, depending on the
container's orientation.
This is equivalent to using Pack2 with its default parameters.
         </doc>
      </method>
   </package>

   <package id="GtkVPaned" into="GtkPaned">
      <type name="Gtk_Vpaned" subtype="true"/>
      <parameter name="self" ada="Paned"/>
      <method id="gtk_vpaned_new" ada="Gtk_New_Vpaned">
         <doc>The children will be displayed one on top of the other</doc>
      </method>
      <method id="gtk_vpaned_get_type" ada="Get_Type_Vpaned" />
   </package>

   <package id="GtkHPaned" into="GtkPaned">
      <type name="Gtk_Hpaned" subtype="true"/>
      <parameter name="self" ada="Paned"/>
      <method id="gtk_hpaned_new" ada="Gtk_New_Hpaned">
         <doc>The children will be displayed next to each other</doc>
      </method>
      <method id="gtk_hpaned_get_type" ada="Get_Type_Hpaned" />
   </package>


   <!-- ################################################
        Gtk.Box, Gtk.Vbox, Gtk.Hbox
        ################################################-->
   <package id="GtkBox">
      <doc screenshot="gtk-box" testgtk="create_box.adb"
           group="Layout containers">
See the testgtk example in the GtkAda distribution to see concrete examples
on how all the parameters for the boxes work.
      </doc>
      <method id="gtk_box_pack_start">
         <parameter name="self" ada="In_Box"/>
         <parameter name="expand" default="True"/>
         <parameter name="fill" default="True"/>
         <parameter name="padding" default="0"/>
      </method>
      <method id="gtk_box_pack_end">
         <parameter name="self" ada="In_Box"/>
         <parameter name="expand" default="True"/>
         <parameter name="fill" default="True"/>
         <parameter name="padding" default="0"/>
      </method>
      <parameter name="self" ada="Box"/>

      <extra>
         <gir:method c:identifier="ada_box_get_child" name="Get_Child"
                     version="GtkAda 1.0">
            <gir:doc>Return the Num-th child of the box, or null if there is no such child</gir:doc>
            <gir:return-value>
               <gir:type name="GtkWidget" c:type="GtkWidget*"/>
            </gir:return-value>
            <gir:parameters>
               <gir:parameter name="num">
                  <gir:type name="Gint" c:type="gint"/>
               </gir:parameter>
            </gir:parameters>
         </gir:method>
      </extra>
   </package>

   <package id="GtkVBox" into="GtkBox">
      <type name="Gtk_Vbox" subtype="true"/>
      <method id="gtk_vbox_new" ada="Gtk_New_Vbox">
         <parameter name="homogeneous" default="False"/>
         <parameter name="spacing" default="0"/>
      </method>
      <parameter name="self" ada="Box"/>
      <method id="gtk_vbox_get_type" ada="Get_Vbox_Type" />
   </package>

   <package id="GtkHBox" into="GtkBox">
      <type name="Gtk_Hbox" subtype="true"/>
      <method id="gtk_hbox_new" ada="Gtk_New_Hbox" >
         <parameter name="homogeneous" default="False"/>
         <parameter name="spacing" default="0"/>
      </method>
      <parameter name="self" ada="Box"/>
      <method id="gtk_hbox_get_type" ada="Get_Hbox_Type" />
   </package>

   <package id="GtkScale">
      <doc group="Numeric/Text Data Entry" screenshot="gtk-scale.png"/>
      <parameter name="self" ada="Scale"/>
   </package>
   <package id="GtkVScale" into="GtkScale">
      <parameter name="self" ada="Scale"/>
      <type name="Gtk_Vscale" subtype="true"/>
      <method id="gtk_vscale_new" ada="Gtk_New_Vscale">
         <parameter name="adjustment" default="null"/>
      </method>
      <method id="gtk_vscale_new_with_range" ada="Gtk_New_Vscale"/>
      <method id="gtk_vscale_get_type" ada="Vscale_Get_Type" />
   </package>
   <package id="GtkHScale" into="GtkScale">
      <parameter name="self" ada="Scale"/>
      <type name="Gtk_Hscale" subtype="true"/>
      <method id="gtk_hscale_new" ada="Gtk_New_Hscale">
         <parameter name="adjustment" default="null"/>
      </method>
      <method id="gtk_hscale_new_with_range" ada="Gtk_New_Hscale"/>
      <method id="gtk_hscale_get_type" ada="Hscale_Get_Type" />
   </package>

   <package id="GtkArrow">
      <doc screenshot="gtk-arrow" testgtk="create_arrow.adb"/>
      <parameter name="self" ada="Arrow"/>
   </package>

   <package id="GtkClipboard">
      <parameter name="self" ada="Clipboard"/>
      <method id="gtk_clipboard_get">
         <parameter name="selection" default="Gdk.Types.Gdk_None"/>
      </method>
      <method id="gtk_clipboard_get_for_display">
         <parameter name="selection" default="Gdk.Types.Gdk_None"/>
      </method>
      <method id="gtk_clipboard_request_rich_text">
         <parameter name="buffer" ctype="GObject*"/>
      </method>
      <method id="gtk_clipboard_wait_is_rich_text_available">
         <parameter name="buffer" ctype="GObject*"/>
      </method>
      <method id="gtk_clipboard_set_can_store">
         <parameter name="targets" type="Gtk.Target_List.Target_Entry_Array"/>
      </method>
      <method id="gtk_clipboard_set_text">
         <parameter name="text" ctype="char*"/>
         <parameter name="len" default="-1" ada=""/>
      </method>

      <method id="gtk_clipboard_set_with_data" bind="false" /> <!-- low-level -->
      <method id="gtk_clipboard_set_with_owner" bind="false" /> <!-- low-level -->
      <method id="gtk_clipboard_wait_for_rich_text" bind="false" /> <!--  Returns an array, not practical -->
      <method id="gtk_clipboard_wait_for_targets" bind="false" /> <!-- bound manually below -->
      <extra>
         <spec>
   function Wait_For_Targets
     (Clipboard : not null access Gtk_Clipboard_Record)
     return Gdk.Types.Gdk_Atom_Array;
   --  Returns a list of targets that are present on the clipboard, or an empty
   --  array if there aren't any targets available.
   --  This function waits for the data to be received using the main
   --  loop, so events, timeouts, etc, may be dispatched during the wait.
         </spec>
         <with_body pkg="Gtkada.C" />
         <body>
    package Atom_Arrays is new Gtkada.C.Unbounded_Arrays
     (Gdk.Types.Gdk_Atom, Gdk.Types.Gdk_None,
      Natural, Gdk.Types.Gdk_Atom_Array);

   ----------------------
   -- Wait_For_Targets --
   ----------------------

   function Wait_For_Targets
     (Clipboard : not null access Gtk_Clipboard_Record)
     return Gdk.Types.Gdk_Atom_Array
   is
      use Atom_Arrays;
      function Internal
        (Clipboard : System.Address;
         Targets   : access Unbounded_Array_Access;
         N_Targets : access Gint) return Gboolean;
      pragma Import (C, Internal, "gtk_clipboard_wait_for_targets");

      Output    : aliased Unbounded_Array_Access;
      N_Targets : aliased Gint;
   begin
      if Internal
        (Get_Object (Clipboard),
         Output'Unchecked_Access,
         N_Targets'Unchecked_Access) = 0
      then
         G_Free (Output);
         Output := null;
      end if;

      declare
         Result : constant Gdk_Atom_Array :=
           To_Array (Output, Integer (N_Targets));
      begin
         if Output /= null then
            G_Free (Output);
         end if;

         return Result;
      end;
   end Wait_For_Targets;
         </body>
      </extra>
   </package>

   <!-- #######################################################
        ## Gtk.Viewport
        #######################################################-->

   <package id="GtkViewport">
      <doc group="Scrolling"/>
      <parameter name="self" ada="Viewport"/>
      <method id="gtk_viewport_new">
         <parameter name="hadjustment" default="null"/>
         <parameter name="vadjustment" default="null"/>
      </method>

      <!-- These are now inherited from the Scrollable interface -->
      <method id="gtk_viewport_get_hadjustment" bind="false"/>
      <method id="gtk_viewport_get_vadjustment" bind="false"/>
      <method id="gtk_viewport_set_hadjustment" bind="false"/>
      <method id="gtk_viewport_set_vadjustment" bind="false"/>
   </package>

   <!-- #######################################################
        ## Gtk.Pixmap
        #######################################################-->

   <package id="GtkPixmap">
      <doc group="Obsolescent widgets"/>
      <parameter name="self" ada="Pixmap"/>
      <parameter name="pixmap" ada="Val"/>
      <method id="gtk_pixmap_set_build_insensitive">
         <doc>Whether the pixmap should be grayed out, as is done for insensitive widgets that do not accept user interaction</doc>
      </method>

      <extra>
         <with_spec pkg="Gtk.Widget" />
         <with_spec pkg="Gtk.Window" />
         <with_spec pkg="Gtkada.Types" />
         <with_body pkg="Interfaces.C.Strings" />
         <with_body pkg="Gdk.Color" />
         <spec>
   function Create_Pixmap
     (Filename : String;
      Window   : access Gtk.Window.Gtk_Window_Record'Class) return Gtk_Pixmap;
      --  Create a pixmap given a window and a filename

   function Create_Pixmap
     (Data     : Gtkada.Types.Chars_Ptr_Array;
      Window   : access Gtk.Window.Gtk_Window_Record'Class) return Gtk_Pixmap;
   --  Create a pixmap given a window and a buffer.
            </spec>
            <body>
   Dummy_Pixmap : constant Gtkada.Types.chars_ptr_array :=
     (New_String ("1 1 1 1"),
      New_String ("c None"),
      New_String (" "));
   --  This is a dummy pixmap we use when a pixmap can't be found.

   function Create_Pixmap
     (Filename : String;
      Window   : access Gtk.Window.Gtk_Window_Record'Class) return Gtk_Pixmap
   is
      Gdkpixmap : Gdk.Pixmap.Gdk_Pixmap;
      Mask      : Gdk.Bitmap.Gdk_Bitmap;
      Pixmap    : Gtk_Pixmap;

      use Gtk.Widget;
      use Gtk.Window;

   begin
      if not Realized_Is_Set (Window) then
         Gtk.Window.Realize (Window);
      end if;

      if Filename = "" then
         Gdk.Pixmap.Create_From_Xpm_D
           (Gdkpixmap, Get_Window (Window), Mask,
            Gdk.Color.Null_Color, Dummy_Pixmap);
      else
         Gdk.Pixmap.Create_From_Xpm
           (Gdkpixmap, Get_Window (Window), Mask,
            Gdk.Color.Null_Color, Filename);
      end if;

      Gtk_New (Pixmap, Gdkpixmap, Mask);
      return Pixmap;
   end Create_Pixmap;

   function Create_Pixmap
     (Data   : Gtkada.Types.Chars_Ptr_Array;
      Window : access Gtk.Window.Gtk_Window_Record'Class) return Gtk_Pixmap
   is
      Gdkpixmap : Gdk.Pixmap.Gdk_Pixmap;
      Mask      : Gdk.Bitmap.Gdk_Bitmap;
      Pixmap    : Gtk_Pixmap;

      use Gtk.Widget;
      use Gtk.Window;

   begin
      if not Realized_Is_Set (Window) then
         Gtk.Window.Realize (Window);
      end if;

      Gdk.Pixmap.Create_From_Xpm_D
        (Gdkpixmap, Get_Window (Window), Mask, Gdk.Color.Null_Color, Data);
      Gtk_New (Pixmap, Gdkpixmap, Mask);

      return Pixmap;
   end Create_Pixmap;
         </body>
      </extra>
   </package>

   <package id="GtkMisc">
      <doc group="Abstract base classes"/>
      <parameter name="self" ada="Misc"/>
      <method id="gtk_misc_set_alignment">
         <doc>
Modify the alignment for the widget.
Xalign and Yalign are both values between 0.0 and 1.0 that specify the
alignment: if Xalign is 0.0, the widget will be left aligned; if it is
0.5, the widget will be centered; if it is 1.0 the widget will be
right aligned. Yalign is from top (0.0) to bottom (1.0).
Both Xalign and Yalign will be constrained to the range 0.0 .. 1.0
Note that if the widget fills its allocated area, these two parameters
won't have any effect.
         </doc>
      </method>
   </package>

   <package id="GtkBin">
      <doc group="Abstract base classes"/>
      <parameter name="self" ada="Bin"/>
   </package>

   <!-- #################################################################
        Gtk.Layout
        ################################################################ -->

   <package id="GtkLayout">
      <doc group="Layout containers" testgtk="create_layout.adb"
           screenshot="gtk-layout">
A Gtk_Layout is a widget that can have an almost infinite size, without
occupying a lot of memory. Its children can be located anywhere within
it, but will only appear on the screen if the visible area of the layout
contains them.
Just like a Gtk_Viewport, its visible area is indicated by two
Gtk_Adjustment widgets, and thus a Gtk_Layout can be put as is in a
Gtk_Scrolled_Window.
As for Gtk_Fixed containers, the children can be located anywhere in the
layout (no automatic organization is done). But, as opposed to Gtk_Fixed
widgets, a Gtk_Layout does not try to resize itself to show all its
children.

Starting from GtkAda 2.0, you have to call Set_Size and specify the maximum
size of the layout, otherwise children added with Put outside the size
defined for the layout will never be visible.
One way to do this is to systematically call Set_Size before calling Put,
and make sure you specify a size big enough for the layout.
      </doc>
      <parameter name="self" ada="Layout"/> <!-- for all methods -->
      <method id="gtk_layout_new">
         <parameter name="hadjustment" default="null"/>
         <parameter name="vadjustment" default="null"/>
      </method>
      <method id="gtk_layout_put">
         <doc>The child will be displayed on the screen only if at least part of it intersects the visible area of the layout. The layout does not resize itself to automatically show the widget. You also need to call Set_Size, if the size you initially defined is smaller than (X, Y), or the child will never be visible even if the layout is scrolled.</doc>
      </method>

      <!-- These are now inherited from the Scrollable interface -->
      <method id="gtk_layout_get_hadjustment" bind="false"/>
      <method id="gtk_layout_get_vadjustment" bind="false"/>
      <method id="gtk_layout_set_hadjustment" bind="false"/>
      <method id="gtk_layout_set_vadjustment" bind="false"/>
   </package>

   <package id="GtkRange">
      <doc testgtk="create_range.adb" screenshot="gtk-range"/>
      <parameter name="self" ada="The_Range"/>
   </package>

   <package id="GtkButtonBox">
      <doc testgtk="create_button_box.adb" screenshot="gtk-button_box"
           group="Layout containers">
A Gtk_Button_Box is a special type of Gtk_Box specially tailored to contain
buttons.

This is only a base class for Gtk_Hbutton_Box and Gtk_Vbutton_Box which
provide a way to arrange their children horizontally (resp. vertically).
You can not instantiate a Gtk_Button_Box directly, and have to use one the
above two instead.
      </doc>
      <parameter name="self" ada="Widget"/>
   </package>

   <package id="GtkHButtonBox">
      <doc group="Layout containers">
A Gtk_Hbutton_Box is a specific Gtk_Button_Box that organizes its
children horizontally.
The beginning of the box (when you add children with Gtk.Box.Pack_Start)
is on the left of the box. Its end (for Gtk.Box.Pack_End) is on the right.
      </doc>
      <parameter name="self" ada="Widget"/>
   </package>

   <package id="GtkVButtonBox">
      <doc group="Layout containers">
A Gtk_Vbutton_Box is a specific Gtk_Button_Box that organizes its
children vertically.
The beginning of the box (when you add children with Gtk.Box.Pack_Start)
is on the top of the box. Its end (for Gtk.Box.Pack_End) is on the bottom.
      </doc>
      <parameter name="self" ada="Widget"/>
   </package>

   <package id="GtkVolumeButton">
      <parameter name="self" ada="Widget"/>
   </package>

   <package id="GtkAboutDialog">
      <doc group="Windows" testgtk="create_about.adb"/>
      <parameter name="self" ada="About"/>
      <enum ctype="GtkLicense"/>
  </package>

  <package id="GtkEntry">
     <doc testgtk="create_entry.adb" group="Numeric/Text Data Entry"
          screenshot="gtk-gentry">
A Gtk_Entry is a single line text editing widget.
The text is automatically scrolled if it is longer than can be displayed
on the screen, so that the cursor position is visible at all times.

See Gtk_Text_View for a multiple-line text editing widget.
     </doc>
     <parameter name="self" ada="The_Entry"/>
     <enum ctype="GtkEntryIconPosition" prefix=""/>

     <method id="gtk_entry_set_invisible_char">
        <parameter name="ch" ada="Char"/>
     </method>
     <method id="gtk_entry_set_has_frame">
        <parameter name="setting" default="True"/>
     </method>
     <method id="gtk_entry_set_width_chars">
        <parameter name="n_chars" ada="Width"/>
     </method>

     <extra>
        <spec>subtype Gtk_GEntry is Gtk_Entry;</spec>
        <spec>
   procedure Insert_Text
      (Editable : access Gtk_Entry_Record;
       New_Text : UTF8_String;
       Position : in out Gint);
   --  Convenience subprogram, identical to Insert_Text above without
   --  the requirement to supply the New_Text_Length argument.
        </spec>
        <body>
   procedure Insert_Text
      (Editable : access Gtk_Entry_Record;
       New_Text : UTF8_String;
       Position : in out Gint) is
   begin
      Insert_Text
        (Editable, New_Text &amp; ASCII.NUL, New_Text'Length, Position);
   end Insert_Text;
        </body>
     </extra>
  </package>

  <package id="GtkDialog">
     <doc group="Windows" testgtk="create_dialog.adb"
          screenshot="gtk-dialog">
          See Gtkada.Dialogs for a higher level dialog interface.
     </doc>
     <parameter name="self" ada="Dialog" />
     <parameter name="response_id" type="Gtk_Response_Type"/>
     <method id="gtk_dialog_get_action_area" return="GtkBox*"/>
     <method id="gtk_dialog_get_content_area" return="GtkBox*"/>
     <method id="gtk_dialog_get_response_for_widget" return="GtkResponseType"/>
     <method id="gtk_dialog_run" return="GtkResponseType"/>
     <method id="gtkada_GtkDialog_get_vbox" bind="true" return="GtkBox*"/>
     <method id="gtk_dialog_add_button">
        <parameter name="button_text" ada="text"/>
     </method>

     <!-- Bound manually below -->
     <method id="gtk_dialog_set_alternative_button_order_from_array" bind="False"/>

     <!-- Following methods have varargs -->
     <method id="gtk_dialog_new_with_buttons" bind="False"/>
     <method id="gtk_dialog_add_buttons" bind="False"/>
     <method id="gtk_dialog_set_alternative_button_order" bind="False"/>

     <method id="ada_gtk_dialog_new_with_buttons">
        <parameter name="parent" default="null"/>
     </method>

     <extra>
        <gir:constructor c:identifier="ada_gtk_dialog_new_with_buttons"
             name="new" version="GtkAda 1.0">
             <gir:doc>Create a new dialog with a specific title, and specific attributes. Parent is the transient parent for the dialog (ie the one that is used for reference for the flag Destroy_With_Parent, or to compute the initial position of the dialog).</gir:doc>
           <gir:return-value>
              <gir:type name="GtkDialog" c:type="GtkDialog*"/>
           </gir:return-value>
           <gir:parameters>
              <gir:parameter name="title">
                 <gir:type name="utf8" c:type="gchar*"/>
              </gir:parameter>
              <gir:parameter name="parent">
                 <gir:type name="Window" c:type="GtkWindow*"/>
              </gir:parameter>
              <gir:parameter name="flags">
                 <gir:type name="DialogFlags" c:type="GtkDialogFlags"/>
              </gir:parameter>
           </gir:parameters>
        </gir:constructor>

        <with_spec pkg="Gdk.Screen" />
        <spec>
   procedure Set_Alternative_Button_Order_From_Array
     (Dialog    : access Gtk_Dialog_Record;
      New_Order : Response_Type_Array);
   --  Sets an alternative button order. If the gtk-alternative-button-order
   --  setting is set to %TRUE, the dialog buttons are reordered according to
   --  the order of the response ids passed to this function.
   --
   --  By default, GTK+ dialogs use the button order advocated by the Gnome
   --  Human Interface Guidelines with the affirmative button at the far right,
   --  and the cancel button left of it. But the builtin GTK+ dialogs and
   --  message dialogs' do provide an alternative button order, which is more
   --  suitable on some platforms, e.g. Windows.
   --
   --  Use this function after adding all the buttons to your dialog.

   function Gtk_Alternative_Dialog_Button_Order
     (Screen : Gdk.Screen.Gdk_Screen := null)  return Boolean;
   --  Returns True if dialogs are expected to use an alternative button order
   --  on the given screen (or current screen if null) . See
   --  Set_Alternative_Button_Order_From_Array for more details about
   --  alternative button order.
   --
   --  If you need to use this function, you should probably connect to the
   --  ::notify:gtk-alternative-button-order signal on the Gtk_Settings object
   --  associated to Screen, in order to be notified if the button order
   --  setting changes.
   --
   --  Returns: Whether the alternative button order should be used
        </spec>
        <body>
   procedure Set_Alternative_Button_Order_From_Array
     (Dialog    : access Gtk_Dialog_Record;
      New_Order : Response_Type_Array)
   is
      procedure Internal
        (Dialog    : System.Address;
         N_Params  : Gint;
         New_Order : System.Address);
      pragma Import
        (C, Internal, "gtk_dialog_set_alternative_button_order_from_array");
   begin
      Internal (Get_Object (Dialog), New_Order'Length,
                New_Order (New_Order'First)'Address);
   end Set_Alternative_Button_Order_From_Array;

   function Gtk_Alternative_Dialog_Button_Order
     (Screen : Gdk.Screen.Gdk_Screen := null) return Boolean
   is
      function Internal (Screen : System.Address) return Gboolean;
      pragma Import (C, Internal, "gtk_alternative_dialog_button_order");
   begin
      return Boolean'Val (Internal (Get_Object (Screen)));
   end Gtk_Alternative_Dialog_Button_Order;
        </body>

        <type ctype="GtkDialogFlags" ada="Gtk_Dialog_Flags">
   type Gtk_Dialog_Flags is mod 8;
   for Gtk_Dialog_Flags'Size use Gint'Size;
   pragma Convention (C, Gtk_Dialog_Flags);
   Modal               : constant Gtk_Dialog_Flags := 2 ** 0;
   Destroy_With_Parent : constant Gtk_Dialog_Flags := 2 ** 1;
   No_Separator        : constant Gtk_Dialog_Flags := 2 ** 2;
   --  Various flags that can be set for the dialog, with the following
   --  implications:
   --     - Modal : the dialog is modal, see Gtk.Window.Set_Modal
   --     - Destroy_With_Parent: The dialog is destroyed if its parent is
   --       destroyed. See Gtk.Window.Set_Destroy_With_Parent
   --     - No_Separator: No separator bar above the buttons.
        </type>

        <type ctype="GtkResponseType" ada="Gtk_Response_Type">
   type Gtk_Response_Type is new Gint;
   --  Type used for Response_Id's.
   --  Positive values are totally user-interpreted.
   --  GtkAda will sometimes return Gtk_Response_None if no Response_Id is
   --  available.
   --
   --  Typical usage is:
   --    if Gtk.Dialog.Run (Dialog) = Gtk_Response_Accept then
   --       blah;
   --    end if;

   Gtk_Response_None : constant Gtk_Response_Type := -1;
   --  GtkAda returns this if a response widget has no Response_Id,
   --  or if the dialog gets programmatically hidden or destroyed.

   Gtk_Response_Reject : constant Gtk_Response_Type := -2;
   Gtk_Response_Accept : constant Gtk_Response_Type := -3;
   --  GtkAda won't return these unless you pass them in
   --  as the response for an action widget. They are
   --  for your convenience.

   Gtk_Response_Delete_Event : constant Gtk_Response_Type := -4;
   --  If the dialog is deleted through the button in the titlebar

   Gtk_Response_OK     : constant Gtk_Response_Type := -5;
   Gtk_Response_Cancel : constant Gtk_Response_Type := -6;
   Gtk_Response_Close  : constant Gtk_Response_Type := -7;
   Gtk_Response_Yes    : constant Gtk_Response_Type := -8;
   Gtk_Response_No     : constant Gtk_Response_Type := -9;
   Gtk_Response_Apply  : constant Gtk_Response_Type := -10;
   Gtk_Response_Help   : constant Gtk_Response_Type := -11;
   --  These are returned from dialogs, and you can also use them
   --  yourself if you like.
        </type>

        <type ctype="GtkResponseType*" ada="Response_Type_Array">
   type Response_Type_Array is array (Natural range &lt;&gt;) of Gtk_Response_Type;
        </type>
     </extra>
  </package>

  <package id="GtkExpander">
     <doc group="Layout containers" screenshot="gtk-expanded"/>
     <parameter name="self" ada="Expander"/>
  </package>

  <package id="GtkDrawingArea">
     <doc group="Drawing" testgtk="libart_demo.adb">
See also the Double_Buffer widget provided in the GtkAda examples for an advanced example that demonstrates how to use double buffering, to avoid flickering in your drawings.</doc>
     <parameter name="self" ada="Drawing_Area"/>
  </package>

  <package id="GtkAdjustment">
     <doc group="Scrolling">
The meaning of the most important fields can be explained on the following figure (imagine this is a scrollbar):

[-------|=================|-------------------]

lower    value        value + page_size       upper
     </doc>
     <parameter name="self" ada="Adjustment"/>
     <method id="gtk_adjustment_new">
        <parameter name="page_size" default="0.0"/>
        <doc>Create a new adjustment. Value is the initial value of the adjustment. It must be in the range (Lower .. Upper) and the adjustment's value will never be outside this range. Step_Increment is the value used to make minor adjustments, such as when the user clicks on the arrows of a scrollbar. Page_Increment is used to make major adjustments, such as when the user clicks in the through on a scrollbar. Page_Size is deprecated, use the default value.</doc>
     </method>
     <method id="gtk_adjustment_clamp_page">
        <doc>Update the Adjustment value to ensure that the range between Lower and Upper is in the current page (i.e. between value and value + page_size). If the range is larger than the page size, then only the start of it will be in the current page. A "value_changed" signal will be emitted if the value is changed.</doc>
     </method>
  </package>

  <package id="GtkImage">
     <doc group="Display widgets" screenshot="gtk-image"/>
     <parameter name="self" ada="Image"/>
     <parameter name="image" ada="Val"/>
     <parameter name="size" type="Gtk.Enums.Gtk_Icon_Size"/>
     <method id="gtk_image_new_from_animation" ada="Gtk_New"/>
     <method id="gtk_image_new_from_file"      ada="Gtk_New"/>
     <method id="gtk_image_new_from_image"     ada="Gtk_New"/>
     <method id="gtk_image_new_from_pixbuf"    ada="Gtk_New"/>
     <method id="gtk_image_new_from_icon_set"  ada="Gtk_New"/>
     <method id="gtk_image_new_from_pixmap"    ada="Gtk_New"/>
     <method id="gtk_image_new_from_stock"     ada="Gtk_New"/>
     <method id="gtk_image_get_animation"      ada="Get"/>
     <method id="gtk_image_set_from_animation" ada="Set"/>
     <method id="gtk_image_get_image"          ada="Get"/>
     <method id="gtk_image_get" bind="False"/> <!-- same as get_image -->
     <method id="gtk_image_set_from_image"     ada="Set"/>
     <method id="gtk_image_set" bind="False"/> <!-- same as set_from_image -->
     <method id="gtk_image_get_pixbuf"         ada="Get"/>
     <method id="gtk_image_set_from_pixbuf"    ada="Set"/>
     <method id="gtk_image_get_icon_set"       ada="Get"/>
     <method id="gtk_image_set_from_icon_set"  ada="Set"/>
     <method id="gtk_image_get_pixmap"         ada="Get"/>
     <method id="gtk_image_set_from_pixmap"    ada="Set"/>
     <method id="gtk_image_get_stock"          ada="Get" bind="False"/>
     <method id="gtk_image_set_from_stock"     ada="Set"/>
     <method id="gtk_image_get_gicon"          ada="Get"/>
     <method id="gtk_image_set_from_gicon"     ada="Set"/>
     <method id="gtk_image_set_from_file"      ada="Set"/>
     <method id="gtk_image_get_icon_name"      ada="Get" bind="False"/>
     <enum ctype="GtkImageType"/>
     <extra>
        <with_spec pkg="GNAT.Strings"/>
        <spec>
   function Get
     (Image : access Gtk_Image_Record;
      Size  : access Gtk.Enums.Gtk_Icon_Size) return String;
   --  Get the stock_id for the image displayed

   procedure Get_Icon_Name
     (Image : access Gtk_Image_Record;
      Name  : out GNAT.Strings.String_Access;
      Size  : out Gtk.Enums.Gtk_Icon_Size);
        </spec>
        <body>
   procedure Get_Icon_Name
     (Image : access Gtk_Image_Record;
      Name  : out GNAT.Strings.String_Access;
      Size  : out Gtk_Icon_Size)
   is
      procedure Internal
        (Image : System.Address;
         Name  : out Interfaces.C.Strings.chars_ptr;
         Size  : out Gtk_Icon_Size);
      pragma Import (C, Internal, "gtk_image_get_icon_name");
      Str : chars_ptr;
   begin
      Internal (Get_Object (Image), Str, Size);
      Name := new String'(Value (Str));
   end Get_Icon_Name;

   function Get
     (Image : access Gtk_Image_Record;
      Size  : access Gtk.Enums.Gtk_Icon_Size) return String
   is
      procedure Internal
        (Image    : System.Address;
         Stock_Id : out Interfaces.C.Strings.chars_ptr;
         Size     : out Gint);
      pragma Import (C, Internal, "gtk_image_get_stock");

      Stock : Interfaces.C.Strings.chars_ptr;
      Sze   : Gint;

   begin
      Internal (Get_Object (Image), Stock, Sze);
      Size.all := Gtk.Enums.Gtk_Icon_Size'Val (Sze);
      return Interfaces.C.Strings.Value (Stock);
   end Get;
        </body>
     </extra>
  </package>

  <package id="GtkCalendar">
     <doc group="Selectors" testgtk="create_calendar.adb"
          screenshot="gtk-calendar"/>
     <parameter name="self" ada="Calendar"/>
     <enum ctype="GtkCalendarDisplayOptions" prefix="GTK_CALENDAR_"/>
  </package>

  <package id="GtkSizeGroup">
     <doc testgtk="create_size_groups.adb"/>
     <parameter name="self" ada="Size_Group" />
     <method id="gtk_size_group_new">
        <parameter name="mode" default="Both"/>
     </method>
     <method id="gtk_size_group_get_widgets" return="WidgetSList"/>
     <enum ctype="GtkSizeGroupMode" ada="Size_Group_Mode" prefix="GTK_SIZE_GROUP_"/>
  </package>

  <package id="GtkAlignment">
     <doc testgtk="create_alignment.adb" screenshot="gtk-alignment"/>
     <parameter name="self" ada="Alignment"/>
     <method id="gtkada_GtkAlignment_get_xalign" bind="True"/>
     <method id="gtkada_GtkAlignment_get_xscale" bind="True"/>
     <method id="gtkada_GtkAlignment_get_yalign" bind="True"/>
     <method id="gtkada_GtkAlignment_get_yscale" bind="True"/>
  </package>

  <package id="GtkStatusbar">
     <doc group="Display widgets" testgtk="create_status.adb"
          screenshot="gtk-status_bar"/>
     <parameter name="self" ada="Statusbar"/>
     <parameter name="context" type="Context_Id"/>
     <parameter name="context_id" ada="context" type="Context_Id"/>
     <parameter name="message_id" ada="Message" type="Message_Id"/>
     <method id="gtk_statusbar_get_context_id" return="Context_Id"/>
     <method id="gtkada_GtkStatusbar_get_messages" return="MessagesList"
             bind="True"/>
     <method id="gtk_statusbar_push" return="Message_Id"/>
     <extra>
        <type>
   type Context_Id is new Guint;
   type Message_Id is new Guint;
        </type>
     </extra>
  </package>

  <package id="GtkTable">
     <doc group="Layout containers"/>
     <parameter name="self" ada="Table"/>
     <method id="gtk_table_new">
        <doc>Create a new table. The width allocated to the table is divided into Columns columns, which all have the same width if Homogeneous is True. If Homogeneous is False, the width will be calculated with the children contained in the table. Same behavior for the rows.</doc>
     </method>
     <method id="gtk_table_attach">
        <doc>Insert a new widget in the table. All the attachments are relative to the separations between columns and rows (for instance, to insert a widget spanning the first two columns in the table, you should put Left_Attach=0 and Right_Attach=2). Same behavior for the rows. Xoptions and Yoptions indicate the behavior of the child when the table is resized (whether the child can shrink or expand). See the description in Gtk.Box for more information on the possible values. Xpadding and Ypadding are the amount of space left around the child.</doc>
        <parameter name="xoptions" default="Expand or Fill"/>
        <parameter name="yoptions" default="Expand or Fill"/>
        <parameter name="xpadding" default="0"/>
        <parameter name="ypadding" default="0"/>
     </method>
     <method id="gtk_table_attach_defaults">
        <doc>Insert a new widget in the table, with default values. No padding is put around the child, and the options are set to Expand and Fill. This call is similar to Attach with default values and is only provided for compatibility.</doc>
     </method>
     <method id="gtk_table_set_col_spacing">
        <doc>Set the spacing in pixels between Column and the next one.</doc>
     </method>
     <method id="gtk_table_set_homogeneous">
        <doc>Indicate the homogeneous status of the table. If Homogeneous is True, the rows and columns of the table will all be allocated the same width or height.</doc>
     </method>
  </package>

  <package id="GtkCheckButton">
     <doc screenshot="gtk-check_button" group="Buttons and Toggles"
        testgtk="create_check_buttons.adb"/>
     <parameter name="self" ada="Check_Button"/>
     <method id="gtk_check_button_new" bind="False"/>
     <method id="gtk_check_button_new_with_label" ada="Gtk_New" >
        <parameter name="label" default='""' allow-none="1"/>
        <doc>Create a check button. if Label is null, then no widget is associated with the button, and any widget can be added to the button (with Gtk.Container.Add).</doc>
     </method>
  </package>

  <package id="GtkToggleButton">
     <doc screenshot="gtk-toggle_button" group="Buttons and Toggles"
          testgtk="create_toggle_buttons.adb">
You should consider using a Gtk_Check_Button instead, since it looks nicer and provides more visual clues that the button can be toggled.
     </doc>
     <parameter name="self" ada="Toggle_Button"/>
     <method id="gtk_toggle_button_new" bind="False"/>
     <method id="gtk_toggle_button_new_with_label" ada="Gtk_New" >
        <doc>Initialize a button. If Label is "", then no label is created inside the button and you will have to provide your own child through a call to Gtk.Container.Add. This is the recommended way to put a pixmap inside a toggle button.</doc>
        <parameter name="label" default='""' allow-none="1"/>
     </method>
     <method id="gtk_toggle_button_set_active">
        <doc>Change the state of the button. When Is_Active is True, the button is drawn as a pressed button</doc>
     </method>
     <method id="gtk_toggle_button_set_inconsistent">
        <parameter name="Setting" default="True"/>
     </method>
  </package>

  <package id="GtkAccelGroup">
     <parameter name="self" ada="Accel_Group"/>
     <method id="gtk_accel_group_new">
        <doc>Creates a new Gtk.Accel_Group.Gtk_Accel_Group.
Remember to call Gtk.Window.Add_Accel_Group to active the group.</doc>
     </method>
     <method id="gtk_accel_group_connect">
        <parameter name="closure" type="C_Gtk_Accel_Group_Activate"/>
     </method>
     <method id="gtk_accel_group_disconnect">
        <parameter name="closure" type="C_Gtk_Accel_Group_Activate"/>
     </method>
     <method id="gtk_accel_group_connect_by_path">
        <parameter name="closure" type="C_Gtk_Accel_Group_Activate"/>
     </method>
     <method id="gtk_accel_group_query" bind="False"/>
        <!-- ???Would be nice -->
     <method id="gtk_accel_group_from_accel_closure">
        <parameter name="closure" type="C_Gtk_Accel_Group_Activate"/>
     </method>
     <function id="gtk_accel_groups_activate">
        <parameter name="accel_key" type="Gdk.Types.Gdk_Key_Type"/>
     </function>
     <function id="gtk_accel_groups_from_object" ada="From_Object"
               return="ObjectSList"/>
     <function id="gtk_accelerator_valid">
        <parameter name="keyval" type="Gdk.Types.Gdk_Key_Type"/>
     </function>
     <function id="gtk_accelerator_parse">
        <parameter name="accelerator_key" ctype="GdkKeyType*"/>
     </function>
     <function id="gtk_accelerator_name">
        <parameter name="accelerator_key" type="Gdk.Types.Gdk_Key_Type"/>
     </function>
     <function id="gtk_accelerator_get_label">
        <parameter name="accelerator_key" type="Gdk.Types.Gdk_Key_Type"/>
     </function>
     <function id="gtk_accelerator_set_default_mod_mask"
               ada="Set_Default_Mod_Mask" />
     <function id="gtk_accelerator_get_default_mod_mask"
               return="GdkModifierType" ada="Get_Default_Mod_Mask"/>
     <enum ctype="GtkAccelFlags" prefix="GTK_"/>
     <record ctype="GtkAccelKey">
       <field name="accel_key" ctype="GdkKeyType"/>
       <field name="accel_flags" ctype="GtkAccelFlags"/>
     </record>
     <extra>
        <type ctype="GtkAccelGroupActive" ada="Gtk_Accel_Group_Activate">
   type Gtk_Accel_Group_Activate is access function
     (Accel_Group   : access Gtk_Accel_Group_Record'Class;
      Acceleratable : Glib.Object.GObject;
      Keyval        : Gdk.Types.Gdk_Key_Type;
      Modifier      : Gdk.Types.Gdk_Modifier_Type) return Boolean;

   type C_Gtk_Accel_Group_Activate is access function
     (Accel_Group   : System.Address;
      Acceleratable : System.Address;
      Keyval        : Gdk.Types.Gdk_Key_Type;
      Modifier      : Gdk.Types.Gdk_Modifier_Type) return Boolean;
   pragma Convention (C, C_Gtk_Accel_Group_Activate);
   --  Same as Gtk_Accel_Group_Activate, but passing directly the C values.
   --  You must use Get_User_Data to convert to the Ada types.
        </type>
     </extra>
  </package>

  <package id="GtkRadioButton">
     <doc screenshot="gtk-radio_button" group="Buttons and Toggles"
          testgtk="create_radio_button.adb"/>
     <parameter name="self" ada="Radio_Button"/>
     <parameter name="radio_group_member" ada="Group"/>
     <method id="gtk_radio_button_new" bind="False"/>
     <method id="gtk_radio_button_new_from_widget" bind="False"/>
     <method id="gtk_radio_button_new_with_label" ada="Gtk_New" >
        <doc>Creates or initializes a new radio button, belonging to Group. If Label is left as the empty string, then the button will not have any child and you are free to put any thing you want in it, including a pixmap. To initialize the group (when creating the first button), leave Group to the Null_List. You can later get the new group that is created with a call to the Get_Group subprogram below.</doc>
        <parameter name="group" default="Widget_SList.Null_List" ctype="WidgetSList"/>
        <parameter name="label" default='""' allow-none="1"/>
     </method>
     <method id="gtk_radio_button_new_with_label_from_widget" ada="Gtk_New" >
        <parameter name="radio_group_member" allow-none="1"/>
        <parameter name="label" default='""' allow-none="1"/>
     </method>
     <method id="gtk_radio_button_new_with_mnemonic">
        <parameter name="group" default="Widget_SList.Null_List" ctype="WidgetSList"/>
     </method>
     <method id="gtk_radio_button_new_with_mnemonic_from_widget" ada="Gtk_New_With_Mnemonic">
        <doc extend="true">To initialize a new group (when creating the first button), you should pass it null or a button that has not been created with Gtk_New, as in the example below.</doc>
        <parameter name="radio_group_member" allow-none="1"/>
     </method>
     <method id="gtk_radio_button_get_group" return="WidgetSList"/>
     <method id="gtk_radio_button_set_group">
        <parameter name="group" ctype="WidgetSList"/>
     </method>
  </package>

  <package id="GtkRadioAction">
     <doc group="Action-based menus" see="Gtk_Action"/>
     <parameter name="self" ada="Action"/>
     <method id="gtk_radio_action_new">
        <parameter name="label" default='""'/>
        <parameter name="tooltip" default='""'/>
        <parameter name="stock_id" default='""'/>
     </method>
     <method id="gtk_radio_action_set_group">
        <parameter name="group" ctype="WidgetSList"/>
        <doc extend="true">A common way to set up a group of radio group is the following:

__PRE__      Group  : GSlist := null;
      Action : Gtk_Radio_Action;
      while ... loop
         Gtk_New (Action, ...);
         Set_Group (Action, Group);
         Group := Get_Group (Action);
      end loop;</doc>
     </method>
     <method id="gtk_radio_action_get_group" return="WidgetSList"/>
  </package>

  <package id="GtkSeparator">
      <doc group="Ornaments" screenshot="gtk-separator"/>
      <parameter name="self" ada="Separator"/>
  </package>
  <package id="GtkVSeparator" into="GtkSeparator">
      <type name="Gtk_Vseparator" subtype="true"/>
      <method id="gtk_vseparator_new" ada="Gtk_New_Vseparator"/>
      <parameter name="self" ada="Separator"/>
      <method id="gtk_vseparator_get_type" ada="Vseparator_Get_Type" />
  </package>
  <package id="GtkHSeparator" into="GtkSeparator">
      <type name="Gtk_Hseparator" subtype="true"/>
      <method id="gtk_hseparator_new" ada="Gtk_New_Hseparator"/>
      <parameter name="self" ada="Separator"/>
      <method id="gtk_hseparator_get_type" ada="Hseparator_Get_Type" />
  </package>

  <package id="GtkSeparatorMenuItem">
     <doc group="Menus and Toolbars"/>
     <parameter name="self" ada="Widget" />
  </package>

  <package id="GtkSeparatorToolItem">
     <doc group="Menus and Toolbars"/>
     <parameter name="self" ada="Item" />
  </package>

  <package id="GtkRuler">
     <doc group="Drawing" testgtk="create_rulers.adb"
          screenshot="gtk-rulers">
 This widget is generally put on the sides of a drawing area to help the user measure distances. It indicates the current position of the mouse cursor within the drawing area, and can be graduated in multiple units.</doc>
     <parameter name="self" ada="Ruler" />
     <method id="gtk_ruler_set_metric">
        <doc>Set or get the units used for a Gtk_Ruler. See Set_Metric</doc>
     </method>
  </package>
  <package id="GtkVRuler" into="GtkRuler">
      <type name="Gtk_Vruler" subtype="true"/>
      <method id="gtk_vruler_new" ada="Gtk_New_Vruler"/>
      <parameter name="self" ada="Ruler"/>
      <method id="gtk_vruler_get_type" ada="Vruler_Get_Type" />
  </package>
  <package id="GtkHRuler" into="GtkRuler">
      <type name="Gtk_Hruler" subtype="true"/>
      <method id="gtk_hruler_new" ada="Gtk_New_Hruler"/>
      <parameter name="self" ada="Ruler"/>
      <method id="gtk_hruler_get_type" ada="Hruler_Get_Type" />
  </package>

  <package id="GtkFixed">
      <doc group="Layout containers" testgtk="create_fixed.adb"
           screenshot="gtk-fixed"/>
      <parameter name="self" ada="Fixed" />
      <method id="gtk_fixed_put">
         <doc>Add Widget to a Fixed container at the given position. X indicates the horizontal position to place the widget at. Y is the vertical position to place the widget at.</doc>
      </method>
      <method id="gtk_fixed_move">
         <doc>Move a child of a GtkFixed container to the given position. X indicates the horizontal position to place the widget at. Y is the vertical position to place the widget at.</doc>
      </method>
      <method id="gtk_fixed_set_has_window">
         <parameter name="has_window" default="False"/>
      </method>
  </package>

  <package id="GtkCellEditable">
     <doc group="Trees and Lists"/>
     <parameter name="self" ada="Cell_Editable"/>
  </package>

  <package id="GtkBuildable">
     <method id="gtk_buildable_custom_tag_start" bind="False"/>
  </package>

  <package id="GtkFileChooser">
     <doc group="Selectors">
This package provides an interface implemented by Gtk.File_Chooser_Widget and Gtk.File_Chooser_Button, and by your own file selection widgets if you wish to expose a standard interface.

Gtk_File_Chooser allows for shortcuts to various places in the filesystem.  In the default implementation these are displayed in the left pane. It may be a bit confusing at first that these shortcuts come from various sources and in various flavours, so lets explain the terminology here:

__PRE__  - Bookmarks
    are created by the user, by dragging folders from the right pane to the
    left pane, or by using the "Add". Bookmarks can be renamed and deleted
    by the user.
  - Shortcuts
    can be provided by the application or by the underlying filesystem
    abstraction (e.g. both the gnome-vfs and the Windows filesystems
    provide "Desktop" shortcuts). Shortcuts cannot be modified by the user.
  - Volumes
    are provided by the underlying filesystem abstraction. They are the
    "roots" of the filesystem.

File Names and Encodings

When the user is finished selecting files in a Gtk_File_Chooser, your program can get the selected names either as filenames or as URIs. For URIs, the normal escaping rules are applied if the URI contains non-ASCII characters. However, filenames are always returned in the character set specified by the G_FILENAME_ENCODING environment variable. Please see the Glib documentation for more details about this variable.

Important: This means that while you can pass the result of Get_Filename to low-level file system primitives , you will need to convert it to UTF-8 before using it in a Gtk_Label for instance. Conversion is done through Glib.Convert.Filename_To_UTF8.

You can add a custom preview widget to a file chooser and then get notification about when the preview needs to be updated. To install a preview widget, use gtk_file_chooser_set_preview_widget(). Then, connect to the GtkFileChooser::update-preview signal to get notified when you need to update the contents of the preview.

Preview widgets

You can add a custom preview widget to a file chooser and then get notification about when the preview needs to be updated. To install a preview widget, use Set_Preview_Widget. Then, connect to the GtkFileChooser::update-preview signal to get notified when you need to
update the contents of the preview.

Your callback should use Get_Preview_Filename to see what needs previewing.  Once you have generated the preview for the corresponding file, you must call Set_Preview_Widget_Active with a boolean flag that indicates whether your callback could successfully generate a preview.

Adding Extra Widgets

You can add extra widgets to a file chooser to provide options that are not present in the default design. For example, you can add a toggle button to give the user the option to open a file in read-only mode. You can use Set_Extra_Widget to insert additional widgets in a file chooser.

If you want to set more than one extra widget in the file chooser, you can a container such as a GtkVBox or a GtkTable and include your widgets in it.  Then, set the container as the whole extra widget.

Key bindings

The following default key bindings are provided, but you can use a gtkrc file to override them if you need (see gtk-rc.ads).

__PRE__
   Signal name    | Key binding
   location-popup | Control-L  (empty path)
                  | /          (path of "/")
                  | ~          (home directory)
   up-folder      | Alt-Up  or backspace
   down-folder    | Alt-Down
   home-folder    | Alt-Home
   desktop-folder | Alt-D
   quick-bookmark | Alt-1 through Alt-0
     </doc>
  </package>

  <package id="GtkCellLayout">
     <doc group="Trees and Lists" testgtk="create_cell_view.adb"/>
     <parameter name="self" ada="Cell_Layout"/>
     <method id="gtk_cell_layout_get_area" bind="False"/>
     <!-- in Gtk.Cell_Area -->

     <method id="gtk_cell_layout_set_attributes" bind="False"/>
     <method id="gtk_cell_layout_get_cells" return="ObjectList"/>
  </package>

  <package id="GtkAssistant">
     <doc group="Windows" testgtk="create_assistant.adb"/>
     <parameter name="self" ada="Assistant"/>
     <enum ctype="GtkAssistantPageType" prefix=""/>
  </package>

  <package id="GtkSpinner">
     <doc group="Ornaments"/>
     <parameter name="self" ada="Spinner"/>
  </package>

  <package id="GtkEntryCompletion">
     <doc group="Numeric/Text Data Entry"/>
     <parameter name="self" ada="Completion"/>
  </package>

  <package id="GtkScrollable">
     <doc group="Interfaces"/>
  </package>

  <package id="GtkProgressBar">
     <doc testgtk="create_progress.adb"
          screenshot="gtk-progress_bar"
          group="Display widgets"/>
     <parameter name="self" ada="Progress_Bar"/>
  </package>

  <package id="GtkColorButton">
     <doc group="Buttons and Toggles"/>
     <parameter name="self" ada="Button"/>

     <method id="gtk_color_button_get_rgba" bind="False"/><!--from interface now-->
     <method id="gtk_color_button_set_rgba" bind="False"/><!--from interface now-->
     <method id="gtk_color_button_get_use_alpha" bind="False"/><!--from interface now-->
     <method id="gtk_color_button_set_use_alpha" bind="False"/><!--from interface now-->
  </package>

  <package id="GtkLinkButton">
     <doc group="Buttons and Toggles"/>
     <parameter name="self" ada="Widget" />
  </package>

  <package id="GtkFileFilter">
     <enum ctype="GtkFileFilterFlags"/>
     <record ctype="GtkFileFilterInfo"/>
  </package>

  <package id="GtkFileChooser">
     <doc group=""/>
     <parameter name="self" ada="Chooser"/>
     <enum ctype="GtkFileChooserAction" prefix="GTK_FILE_CHOOSER_"/>
     <enum ctype="GtkFileChooserConfirmation" prefix="GTK_FILE_CHOOSER_"/>
     <enum ctype="GtkFileChooserError" prefix="GTK_FILE_CHOOSER_"/>

     <!-- we won't bind any of these internal functions which pass GFile
          types -->
     <method id="gtk_file_chooser_get_file" bind="False"/>
     <method id="gtk_file_chooser_get_files" bind="False"/>
     <method id="gtk_file_chooser_get_current_folder_file" bind="False"/>
     <method id="gtk_file_chooser_get_preview_file" bind="False"/>
     <method id="gtk_file_chooser_select_file" bind="False"/>
     <method id="gtk_file_chooser_set_current_folder_file" bind="False"/>
     <method id="gtk_file_chooser_set_file" bind="False"/>
     <method id="gtk_file_chooser_unselect_file" bind="False"/>

     <method id="gtk_file_chooser_get_filenames" return="StringSList"/>
     <method id="gtk_file_chooser_get_uris" return="StringSList"/>
     <method id="gtk_file_chooser_list_shortcut_folder_uris"
             return="StringSList"/>
     <method id="gtk_file_chooser_list_shortcut_folders"
             return="StringSList"/>
     <method id="gtk_file_chooser_list_filters" return="ObjectSList"/>
  </package>

  <package id="GtkFileChooserButton">
     <doc group="Buttons and Toggles"/>
     <parameter name="self" ada="Button"/>
  </package>

  <package id="GtkToolbar">
     <parameter name="self" ada="Toolbar"/>
     <method id="gtk_toolbar_set_show_arrow">
        <parameter name="show_arrow" default="True"/>
     </method>
     <method id="gtk_toolbar_insert">
        <parameter name="pos" default="-1"/>
     </method>
     <method id="gtk_tool_shell_get_orientation" bind="False"/>
     <method id="gtk_tool_shell_get_icon_size" bind="False"/>
     <method id="gtk_tool_shell_get_relief_style" bind="False"/>
     <method id="gtk_tool_shell_get_style" bind="False"/>
  </package>

  <package id="GtkEditable">
     <parameter name="self" ada="Editable"/>
     <method id="::insert-text">
        <parameter name="position" direction="access"/>
     </method>
     <method id="gtk_editable_select_region">
        <parameter name="end_pos" default="-1"/>
     </method>
     <method id="gtk_editable_delete_text">
        <parameter name="end_pos" default="-1"/>
     </method>
     <method id="gtk_editable_get_chars">
        <parameter name="end_pos" default="-1"/>
     </method>
     <extra>
        <spec>
   procedure Insert_Text
     (Editable : Gtk_Editable;
      New_Text : UTF8_String;
      Position : in out Gint);
   --  Convenience subprogram, identical to Insert_Text above without
   --  the requirement to supply the New_Text_Length argument.
        </spec>
        <body>
   procedure Insert_Text
     (Editable : Gtk_Editable;
      New_Text : UTF8_String;
      Position : in out Gint) is
   begin
      Insert_Text
        (Editable, New_Text &amp; ASCII.NUL, New_Text'Length, Position);
   end Insert_Text;
        </body>
     </extra>
     <method id="gtk_editable_get_selection_bounds"
             return_as_param="Has_Selection"/>
  </package>

  <package id="GtkToolItem">
     <parameter name="self" ada="Tool_Item"/>
     <method id="gtk_tool_item_retrieve_proxy_menu_item" return="GtkMenuItem"/>
     <method id="gtk_tool_item_get_proxy_menu_item" return="GtkMenuItem"/>
     <method id="gtk_tool_item_set_proxy_menu_item">
        <parameter name="menu_item" ctype="GtkMenuItem"/>
     </method>
  </package>

   <package id="GtkScrollbar">
      <parameter name="self" ada="Scrollbar"/>
   </package>

   <package id="GtkHScrollbar" into="GtkScrollbar">
      <parameter name="self" ada="Scrollbar"/>
      <type name="Gtk_Hscrollbar" subtype="true"/>
      <method id="gtk_hscrollbar_new" ada="Gtk_New_Hscrollbar"/>
      <method id="gtk_hscrollbar_get_type" ada="Hscrollbar_Get_Type"/>
   </package>

   <package id="GtkVScrollbar" into="GtkScrollbar">
      <parameter name="self" ada="Scrollbar"/>
      <type name="Gtk_Vscrollbar" subtype="true"/>
      <method id="gtk_vscrollbar_new" ada="Gtk_New_Vscrollbar"/>
      <method id="gtk_vscrollbar_get_type" ada="Vscrollbar_Get_Type"/>
   </package>

   <package id="GtkCellRenderer">
      <parameter name="self" ada="Cell"/>
      <enum ctype="GtkCellRendererState"/>
      <enum ctype="GtkCellRendererMode"/>
      <method id="gtk_cell_renderer_get_size">
         <!-- hack to make cell_area an in-out parameter -->
         <parameter name="cell_area" ctype="GdkRectangle**"/>
      </method>
      <list ada="Cell_Renderer_List" ctype="GtkCellRenderer"/>
   </package>

   <package id="GtkStatusIcon">
      <parameter name="self" ada="Status_Icon"/>
      <!-- ??? inclusion of below method is pending on L117-038 -->
      <method id="gtk_status_icon_get_geometry" bind="False"/>

      <method id="gtk_status_icon_position_menu">
        <parameter name="user_data" ada="Icon" type="Glib.Object.GObject"/>
        <parameter name="x" direction="inout" />
        <parameter name="y" direction="inout" />
        <body>
      procedure Internal
         (Menu    : System.Address;
          X       : in out Gint;
          Y       : in out Gint;
          Push_In : out Integer;
          Icon    : System.Address);
      pragma Import (C, Internal, "gtk_status_icon_position_menu");
      --  Custom body because we need to initialize to 0 here (on OSX).
      Tmp_Push_In : aliased Integer := 0;
   begin
      Internal (Get_Object (Menu), X, Y, Tmp_Push_In, Get_Object (Icon));
      Push_In := Tmp_Push_In /= 0;
        </body>
      </method>
   </package>

   <package id="GtkMenuItem">
      <parameter name="self" ada="Menu_Item"/>
      <method id="gtk_menu_item_select" ada="Gtk_Select"/>
      <method id="gtk_menu_item_set_right_justified">
         <parameter name="right_justified" default="True"/>
      </method>
      <extra>
         <spec>
   procedure Gtk_New
      (Menu_Item : out Gtk_Menu_Item;
       Label     : UTF8_String) renames Gtk_New_With_Label;
   procedure Initialize
      (Menu_Item : access Gtk_Menu_Item_Record'Class;
       Label     : UTF8_String) renames Initialize_With_Label;
   --  For backwards compatibility.
         </spec>
      </extra>
   </package>

   <package id="GtkRecentFilter">
     <parameter name="self" ada="Filter"/>
     <enum ctype="GtkRecentFilterFlags" />
     <record ctype="GtkRecentFilterInfo" />
     <slist ada="Gtk_Recent_Filter_List" ctype="GtkRecentFilter"/>
   </package>

   <package id="GtkFileChooserDialog">
      <parameter name="self" ada="Dialog"/>
      <method id="gtk_file_chooser_dialog_new" ada="Gtk_New" bind="False"/> <!-- varargs -->

      <extra>
         <gir:constructor name="new"
                          c:identifier="ada_gtk_file_chooser_dialog_new"
                          version="2.4"
                          introspectable="0">
            <gir:doc xml:whitespace="preserve">Creates a new #GtkFileChooserDialog.  This function is analogous to gtk_dialog_new_with_buttons().</gir:doc>
            <gir:return-value transfer-ownership="none">
               <gir:doc xml:whitespace="preserve">a new #GtkFileChooserDialog</gir:doc>
               <gir:type name="Widget" c:type="GtkWidget*"/>
            </gir:return-value>
            <gir:parameters>
               <gir:parameter name="title" transfer-ownership="none" allow-none="1">
                  <gir:doc xml:whitespace="preserve">Title of the dialog, or %NULL</gir:doc>
                  <gir:type name="utf8" c:type="gchar*"/>
               </gir:parameter>
               <gir:parameter name="parent" transfer-ownership="none" allow-none="1">
                  <gir:doc xml:whitespace="preserve">Transient parent of the dialog, or %NULL</gir:doc>
                  <gir:type name="Window" c:type="GtkWindow*"/>
               </gir:parameter>
               <gir:parameter name="action" transfer-ownership="none">
                  <gir:doc xml:whitespace="preserve">Open or save mode for the dialog</gir:doc>
                  <gir:type name="FileChooserAction" c:type="GtkFileChooserAction"/>
               </gir:parameter>
            </gir:parameters>
         </gir:constructor>
      </extra>
   </package>

   <package id="GtkHandleBox" obsolescent="True">
     <parameter name="self" ada="Handle_Box"/>
   </package>

   <package id="GtkScaleButton">
      <parameter name="self" ada="Button"/>
  </package>

   <package id="GtkRecentManager">
     <doc>
In case the default screen is being used, adding a new recently used file is as
simple as:

__PRE__
     declare
        Manager : constant Gtk_Recent_Manager := Get_Default;
     begin
        Add_Item (Manager, File_URI);
     end;

While looking up a recently used file is as simple as using:

__PRE__
     declare
        Manager : constant Gtk_Recent_Manager := Get_Default;
        Info    : Gtk_Recent_Info;
        Error   : Glib.Error.GError;
     begin
        Lookup_Item (Info, Manager, File_URI, Error);
        if Error /= null then
           --  Use the info object
           Unref (Info);
        else
           Put_Line
             ("Could not find the file: " &amp; Glib.Error.Get_Message (Error));
           Glib.Error.Error_Free (Error);
        end if;
     end;
     </doc>
     <param name="self" ada="Manager" />
     <record ctype="GtkRecentData" />
     <method id="gtk_recent_manager_get_items" return="GtkRecentInfoList"/>
     <list ada="Gtk_Recent_Info_List" ctype="GtkRecentInfo"/>

     <!-- Bound below -->
     <method id="gtk_recent_manager_add_full" bind="False" />

     <extra>
       <with_spec pkg="GNAT.Strings" />
       <with_body pkg="Gtkada.Bindings" />
       <spec>
   function Add_Full
     (Manager      : access Gtk_Recent_Manager_Record;
      Uri          : UTF8_String;
      Display_Name : UTF8_String := "";
      Description  : UTF8_String := "";
      Mime_Type    : UTF8_String;
      App_Name     : UTF8_String;
      App_Exec     : UTF8_String;
      Groups       : GNAT.Strings.String_List;
      Is_Private   : Boolean)
      return Boolean;
   --  Manager      : the Gtk_Recent_Manager on which to operate
   --  Uri          : pointer to resource
   --  Display_Name : a UTF-8 encoded string, containing the name of the
   --                 recently used resource to be displayed, or "".
   --  Description  : a UTF-8 encoded string, containing a short description
   --                 of the resource, or "".
   --  Mime_Type    : the MIME type of the resource.
   --  App_Name     : the name of the application that is registering this
   --                 recently used resource.
   --  App_Exec     : command line used to launch this resource; may contain
   --                 the "%f" and "%u" escape characters which will be
   --                 expanded to the resource file path and URI, respectively,
   --                 when the command line is retrieved.
   --  Groups       : a vector of strings containing groups names.
   --  Is_Private   : whether this resource should be displayed only by the
   --                 applications that have registered it or not.
   --
   --  Adds a new resource, pointed by Uri, into the recently used
   --  resources list, using the metadata specified.
   --
   --  The passed URI will be used to identify this resource inside the
   --  list.
   --
   --  In order to register the new recently used resource, metadata about
   --  the resource must be passed as well as the URI.  This metadata must
   --  contain the MIME type of the resource pointed by the URI; the name of
   --  the application that is registering the item, and a command line to be
   --  used when launching the item.
   --
   --  Optionally, it is possible to specify a UTF-8 string to be used when
   --  viewing the item instead of the last component of the URI; a short
   --  description of the item; whether the item should be considered private -
   --  that is, should be displayed only by the applications that have
   --  registered it.
   --
   --  Returns True if the new item was successfully added to the recently
   --  used resources list, False otherwise.
       </spec>
       <body>
   function Add_Full
     (Manager      : access Gtk_Recent_Manager_Record;
      Uri          : UTF8_String;
      Display_Name : UTF8_String := "";
      Description  : UTF8_String := "";
      Mime_Type    : UTF8_String;
      App_Name     : UTF8_String;
      App_Exec     : UTF8_String;
      Groups       : GNAT.Strings.String_List;
      Is_Private   : Boolean)
      return Boolean
   is
      function Internal
        (Manager     : System.Address;
         Uri         : String;
         Recent_Data : System.Address)
         return Gboolean;
      pragma Import (C, Internal, "gtk_recent_manager_add_full");

      type Gtk_Recent_Data_Record is record
         display_name : chars_ptr;
         description  : chars_ptr;
         mime_type    : chars_ptr;
         app_name     : chars_ptr;
         app_exec     : chars_ptr;
         groups       : System.Address;
         is_private   : Gboolean;
      end record;
      pragma Convention (C, Gtk_Recent_Data_Record);
      --  Internal record that matches struct _GtkRecentData in
      --  gtkrecentmanager.h

      C_Groups : aliased chars_ptr_array := From_String_List (Groups);
      --  Temporary variable to aid translation

      GRD : aliased Gtk_Recent_Data_Record;
      --  Data to feed in to gtk_recent_manager_add_full()

      Result : Gboolean;
   begin
      --  Set up.
      GRD.display_name := String_Or_Null (Display_Name);
      GRD.description  := String_Or_Null (Description);
      GRD.mime_type    := New_String (Mime_Type);
      GRD.app_name     := New_String (App_Name);
      GRD.app_exec     := New_String (App_Exec);
      GRD.is_private   := Boolean'Pos (Is_Private);

      if C_Groups'Length > 0 then
         GRD.groups := C_Groups (C_Groups'First)'Address;
      else
         GRD.groups := System.Null_Address;
      end if;
      --  Invoke function.
      Result := Internal (Get_Object (Manager), Uri &amp; ASCII.NUL, GRD'Address);

      --  Clean up, making sure to avoid double-deallocations where such
      --  may be possible.
      if GRD.display_name /= Null_Ptr then
         Free (GRD.display_name);
      end if;
      if GRD.description /= Null_Ptr then
         Free (GRD.description);
      end if;
      Free (GRD.mime_type);
      Free (GRD.app_name);
      Free (GRD.app_exec);
      for I in C_Groups'Range loop
         if C_Groups (I) /= Null_Ptr then
            Free (C_Groups (I));
         end if;
      end loop;

      --  Return result.
      return Boolean'Val (Result);
   end Add_Full;
       </body>
     </extra>
   </package>

   <package id="GtkRecentInfo">  <!-- into="GtkRecentManager">-->
     <method id="gtk_recent_info_ref" return="void" />

     <!-- ??? Disabled for now, we are creating an unconstrained local var -->
     <method id="gtk_recent_info_get_application_info" return="void" bind="False"/>

     <!-- These functions return the length separately, not needed in Ada-->
     <method id="gtk_recent_info_get_applications" bind="False" />
     <method id="gtk_recent_info_get_groups" bind="False" />

     <extra>
       <type>
   subtype time_t is Long_Integer;
   --  Type to interface with C's time_t type.  To convert this to/from
   --  an Ada type, look at Ada.Calendar.Conversion_Operations and be
   --  sure to pay special attention to the ranges each type is capable
   --  of representing.
       </type>
     </extra>
   </package>

   <package id="GtkRecentChooser">
     <parameter name="self" ada="Chooser" />
     <method id="gtk_recent_chooser_get_items" return="RecentInfoList"/>
     <enum ctype="GtkRecentSortType" />

     <!-- These functions return the length separately, not needed in Ada-->
     <method id="gtk_recent_chooser_get_uris" bind="False" />

     <method id="gtk_recent_chooser_list_filters" return="RecentFilterSList"/>
   </package>

   <package id="GtkWidgetClass" into="GtkWidget" bindtype="false">
     <method id="gtk_widget_class_find_style_property"/>
     <method id="gtk_widget_class_install_style_property" >
       <parameter name="pspec" ctype="GParamSpec"/>
     </method>
     <method id="gtk_widget_class_set_accessible_role" bind="False" /> <!--  needs atk -->
     <method id="gtk_widget_class_set_accessible_type" bind="False" /> <!--  needs atk -->

     <method id="gtk_widget_class_install_style_property_parser" bind="False" />
     <method id="gtk_widget_class_list_style_properties" bind="False" />
   </package>

   <package id="GtkWidget" needs_merge="false">
     <parameter name="self" ada="Widget" />
     <enum ctype="GtkAlign"/>
     <enum ctype="GtkWidgetHelpType" />
     <record ctype="GtkRequisition"/>
     <record ctype="GtkWidgetPath"/>
     <list ada="Widget_List" ctype="Widget"/>
     <slist ada="Widget_SList" ctype="Widget"/>

     <method id="::query-tooltip">
        <parameter name="tooltip" ctype="GObject*"/>
     </method>

     <method id="gtk_widget_new" bind="False" /> <!-- varargs -->
     <method id="gtk_widget_style_get" bind="False" /> <!-- varargs -->
     <method id="gtk_widget_style_get_valist" bind="False"/><!-- varargs -->
     <method id="gtk_widget_list_accel_closures" bind="False"/><!-- We do not expose Closures-->
     <method id="gtk_widget_get_style_context" bind="False"/><!-- in Gtk.Style_Context-->
     <method id="gtk_widget_get_accessible" bind="False"/> <!-- Requires ATK -->
     <method id="gtk_widget_get_clipboard" bind="False"/><!-- in Gtk.Clipboard -->
     <method id="gtk_widget_get_settings" bind="False"/><!-- in Gtk.Settings -->
     <method id="gtk_widget_modify_style" bind="False"/><!-- in Gtk.RC -->
     <method id="gtk_widget_get_modifier_style" bind="False"/><!-- in Gtk.RC -->
     <method id="gtk_widget_class_path" bind="False"/><!-- deprecated -->
     <method id="gtk_widget_path" bind="False"/><!-- deprecated -->
     <method id="gtk_drag_source_set_icon_gicon" bind="False"/><!-- does not exist in quartz backend-->
     <method id="gtk_drag_source_get_target_list" bind="False"/><!-- in Gtk.Dnd -->
     <method id="gtk_drag_source_set_target_list" bind="False"/><!-- in Gtk.Dnd-->
     <method id="gtk_drag_begin" bind="False"/><!-- in Gtk.Dnd -->
     <method id="gtk_drag_dest_find_target" bind="False"/><!-- in Gtk.Dnd-->
     <method id="gtk_drag_dest_get_target_list" bind="False"/><!-- in Gtk.Dnd-->
     <method id="gtk_drag_dest_set_target_list" bind="False"/><!-- in Gtk.Dnd-->
     <method id="gtk_drag_dest_set" bind="False"/><!-- in Gtk.Dnd -->
     <method id="gtk_drag_source_set" bind="False"/><!-- in Gtk.Dnd -->
     <method id="gtk_widget_modify_base" obsolescent="True"/>
     <method id="gtk_widget_modify_fg" obsolescent="True"/>
     <method id="gtk_widget_modify_bg" obsolescent="True"/>
     <method id="gtk_widget_modify_text" obsolescent="True"/>
     <method id="gtk_widget_modify_font" obsolescent="True"/>
     <method id="gtk_widget_insert_action_group" bind="False"/> <!--  needs GAction -->
     <method id="gtk_widget_set_sensitive">
       <parameter name="Sensitive" default="True"/>
     </method>
     <method id="gtk_widget_size_allocate">
        <parameter name="allocation" ctype="GtkAllocation" />
     </method>
     <method id="gtk_widget_set_size_request">
       <parameter name="Width" default="-1" />
       <parameter name="Height" default="-1" />
     </method>
     <method id="gtk_widget_add_accelerator">
       <parameter name="Accel_Key" ctype="GdkKeyType" />
     </method>
     <method id="gtk_widget_remove_accelerator">
       <parameter name="Accel_Key" ctype="GdkKeyType" />
     </method>
     <method id="gtk_widget_add_events">
       <parameter name="Events" ctype="GdkEventMask"/>
     </method>
     <method id="gtk_widget_set_events">
       <parameter name="Events" ctype="GdkEventMask"/>
     </method>
     <method id="gtk_widget_get_events" return="GdkEventMask"/>
     <method id="gtk_widget_get_tooltip_window" return="GtkWidget*" />
     <method id="gtk_widget_set_tooltip_window">
       <parameter name="Custom_Window" ctype="GtkWidget*"/>
     </method>
     <method id="gtk_widget_list_mnemonic_labels" return="WidgetList" />
     <method id="gtk_widget_render_icon">
       <parameter name="Detail" default='""'/>
     </method>
     <method id="gtk_widget_create_pango_layout">
       <parameter name="Text" allow-none="1"/>
     </method>
     <method id="gtk_widget_intersect">
       <parameter name="Intersection" direction="access"/>
     </method>
     <method id="gtk_widget_translate_coordinates" return_as_param="Result"/>
     <method id="gtk_widget_destroy">
       <body>
      procedure Internal (Widget : System.Address);
      pragma Import (C, Internal, "gtk_widget_destroy");

      procedure Unref_Internal (Widget : System.Address);
      pragma Import (C, Unref_Internal, "g_object_unref");
      --  External binding: g_object_unref

      Ptr : constant System.Address := Get_Object (Widget);

      use type System.Address;
   begin
      --  Keep a reference on the object, so that the Ada structure is
      --  never automatically deleted when the C object is.
      --  We can't reset the content of Widget to System.Null_Address before
      --  calling the C function, because we want the user's destroy
      --  callbacks to be called with the appropriate object.
      Ref (Widget);
      Internal (Ptr);

      --  We then can make sure that the object won't be referenced any
      --  more, (The Ada structure won't be free before the ref count goes
      --  down to 0, and we don't want the user to use a deleted object...).
      Set_Object (Widget, System.Null_Address);

      --  Free the reference we had. In most cases, this results in the
      --  object being freed. We can't use directly Unref, since the Ptr
      --  field for Object is Null_Address.
      Unref_Internal (Ptr);
       </body>
     </method>

     <function id="gtk_cairo_transform_to_window" ada="Transform_To_Window" />
     <function id="gtk_cairo_should_draw_window" ada="Should_Draw_Window" />
     <extra>
       <with_spec pkg="Gdk.Rectangle"/>
       <type>
   subtype Gtk_Allocation is Gdk.Rectangle.Gdk_Rectangle;
       </type>
       <spec>
   ------------------------------------
   -- Override default size handling --
   ------------------------------------

   type Gtk_Requisition_Access is access all Gtk_Requisition;
   type Gtk_Allocation_Access is access all Gtk_Allocation;
   pragma Convention (C, Gtk_Requisition_Access);
   pragma Convention (C, Gtk_Allocation_Access);

   function Get_Requisition
     (Value : Glib.Values.GValue) return Gtk_Requisition_Access;
   function Get_Allocation
     (Value : Glib.Values.GValue) return Gtk_Allocation_Access;
   --  Convert values received as callback parameters

   type Size_Allocate_Handler is access procedure
     (Widget : System.Address; Allocation : Gtk_Allocation);
   pragma Convention (C, Size_Allocate_Handler);
   --  Widget is the gtk+ C widget, that needs to be converted to Ada through
   --  a call to:
   --    declare
   --       Stub : Gtk_Widget_Record; --  or the exact type you expect
   --    begin
   --       My_Widget := Gtk_Widget (Glib.Object.Get_User_Data (Widget, Stub);
   --    end;

   procedure Set_Default_Size_Allocate_Handler
     (Klass   : Glib.Object.Ada_GObject_Class;
      Handler : Size_Allocate_Handler);
   pragma Import (C, Set_Default_Size_Allocate_Handler,
                  "ada_WIDGET_CLASS_override_size_allocate");
   --  Override the default size_allocate handler for this class. This handler
   --  is automatically called in several cases (when a widget is dynamically
   --  resized for instance), not through a signal. Thus, if you need to
   --  override the default behavior provided by one of the standard
   --  containers, you can not simply use Gtk.Handlers.Emit_Stop_By_Name, and
   --  you must override the default handler. Note also that this handler
   --  is automatically inherited by children of this class.
   --
   --  This function is not needed unless you are writting your own
   --  widgets, and should be reserved for advanced customization of the
   --  standard widgets.

   type Preferred_Size_Handler is access procedure
      (Widget       : System.Address;
       Minimum_Size : out Glib.Gint;
       Natural_Size : out Glib.Gint);
   pragma Convention (C, Preferred_Size_Handler);

   procedure Set_Default_Get_Preferred_Width_Handler
      (Klass   : Glib.Object.Ada_GObject_Class;
       Handler : Preferred_Size_Handler);
   procedure Set_Default_Get_Preferred_Height_Handler
      (Klass   : Glib.Object.Ada_GObject_Class;
       Handler : Preferred_Size_Handler);
   pragma Import (C, Set_Default_Get_Preferred_Width_Handler,
                  "ada_WIDGET_CLASS_override_get_preferred_width");
   pragma Import (C, Set_Default_Get_Preferred_Height_Handler,
                  "ada_WIDGET_CLASS_override_get_preferred_height");
   --  Override the computation of a widget's preferred sizes.
   --  You will only need to override this computation if you are writting
   --  your own container widgets.

   procedure Inherited_Get_Preferred_Width
      (Klass      : Ada_GObject_Class;
       Widget     : access Gtk_Widget_Record'Class;
       Minimum_Size, Natural_Size : out Glib.Gint);
   procedure Inherited_Get_Preferred_Height
      (Klass      : Ada_GObject_Class;
       Widget     : access Gtk_Widget_Record'Class;
       Minimum_Size, Natural_Size : out Glib.Gint);
   --  Call the default implementation
 
   procedure Inherited_Size_Allocate
      (Klass      : Ada_GObject_Class;
       Widget     : access Gtk_Widget_Record'Class;
       Allocation : Gtk_Allocation);
   --  Call the inherited size_allocate. This is useful if you have overloaded it in
   --  your own class, but still need to call the standard implementation.

   ---------------------------
   -- Override Draw handler --
   ---------------------------

   generic
       with function Draw
          (W  : access Gtk_Widget_Record'Class;
           Cr : Cairo.Cairo_Context) return Boolean;
   function Proxy_Draw
      (W  : System.Address; Cr : Cairo.Cairo_Context) return Gboolean;
   pragma Convention (C, Proxy_Draw);

   type Draw_Handler is access function
     (W  : System.Address;
      Cr : Cairo.Cairo_Context) return Gboolean;
   pragma Convention (C, Draw_Handler);
   --  A function responsible for drawing a widget.

   procedure Set_Default_Draw_Handler
      (Klass : Glib.Object.Ada_GObject_Class; Handler : Draw_Handler);
   --  Override the default drawing function. This in general gives more
   --  control than connection to Signal_Draw, however a widget is responsible
   --  for drawing its children.
   --  Use the generic Proxy_Draw to create a suitable callback.

   function Inherited_Draw
      (Klass  : Ada_GObject_Class;
       Widget : access Gtk_Widget_Record'Class;
       Cr     : Cairo.Cairo_Context) return Boolean;
   --  Call the inherited draw. This is useful if you have overloaded draw in
   --  your own class, but still need to draw the child widgets that do not
   --  have their own window (the others will already get their own "draw"
   --  event.
   --  See http://developer.gnome.org/gtk3/3.0/chap-drawing-model.html
   --  for an explanation of the gtk+ drawing model.
       </spec>
       <with_body pkg="Ada.Unchecked_Conversion" use="False"/>
       <body>
   function Convert is new Ada.Unchecked_Conversion
      (Draw_Handler, System.Address);

   function Proxy_Draw
      (W  : System.Address;
       Cr : Cairo.Cairo_Context) return Gboolean
   is
      Stub : Gtk_Widget_Record;
      W2 : constant Gtk_Widget := Gtk_Widget (Get_User_Data (W, Stub));
   begin
      return Boolean'Pos (Draw (W2, Cr));
   end Proxy_Draw;

   function Inherited_Draw
      (Klass  : Ada_GObject_Class;
       Widget : access Gtk_Widget_Record'Class;
       Cr     : Cairo.Cairo_Context) return Boolean
   is
       function Internal (Klass : Ada_Gobject_Class;
                          Widget : System.Address;
                          Cr : Cairo.Cairo_Context) return Gboolean;
       pragma Import (C, Internal, "ada_inherited_WIDGET_CLASS_draw");
   begin
      return Internal (Klass, Widget.Get_Object, Cr) /= 0;
   end Inherited_Draw;

   procedure Inherited_Get_Preferred_Width
      (Klass      : Ada_GObject_Class;
       Widget     : access Gtk_Widget_Record'Class;
       Minimum_Size, Natural_Size : out Glib.Gint)
   is
       procedure Internal (Klass : Ada_Gobject_Class;
                           Widget : System.Address;
                           Min, Nat : out Glib.Gint);
       pragma Import
          (C, Internal, "ada_inherited_WIDGET_CLASS_get_preferred_width");
   begin
       Internal (Klass, Widget.Get_Object, Minimum_Size, Natural_Size);
   end Inherited_Get_Preferred_Width;

   procedure Inherited_Get_Preferred_Height
      (Klass      : Ada_GObject_Class;
       Widget     : access Gtk_Widget_Record'Class;
       Minimum_Size, Natural_Size : out Glib.Gint)
   is
       procedure Internal (Klass : Ada_Gobject_Class;
                           Widget : System.Address;
                           Min, Nat : out Glib.Gint);
       pragma Import
          (C, Internal, "ada_inherited_WIDGET_CLASS_get_preferred_height");
   begin
       Internal (Klass, Widget.Get_Object, Minimum_Size, Natural_Size);
   end Inherited_Get_Preferred_Height;

   procedure Inherited_Size_Allocate
      (Klass      : Ada_GObject_Class;
       Widget     : access Gtk_Widget_Record'Class;
       Allocation : Gtk_Allocation)
   is
       procedure Internal (Klass : Ada_Gobject_Class;
                           Widget : System.Address;
                           Allocation : Gtk_Allocation);
       pragma Import
          (C, Internal, "ada_inherited_WIDGET_CLASS_size_allocate");
   begin
       Internal (Klass, Widget.Get_Object, Allocation);
   end Inherited_Size_Allocate;

   procedure Set_Default_Draw_Handler
      (Klass : Glib.Object.Ada_GObject_Class; Handler : Draw_Handler)
   is
      procedure Internal (K : Ada_GObject_Class; H : System.Address);
      pragma Import (C, Internal, "ada_WIDGET_CLASS_override_draw");
   begin
      Internal (Klass, Convert (Handler));
   end Set_Default_Draw_Handler;

   function Get_Allocation
     (Value : Glib.Values.GValue) return Gtk_Allocation_Access
   is
      pragma Warnings (Off);
      --  This UC is safe aliasing-wise, so kill warning
      function To_Allocation is new
        Ada.Unchecked_Conversion (System.Address, Gtk_Allocation_Access);
      pragma Warnings (On);
   begin
      return To_Allocation (Glib.Values.Get_Address (Value));
   end Get_Allocation;

   function Get_Requisition
     (Value : Glib.Values.GValue) return Gtk_Requisition_Access
   is
      pragma Warnings (Off);
      --  This UC is safe aliasing-wise, so kill warning
      function To_Requisition is new
        Ada.Unchecked_Conversion (System.Address, Gtk_Requisition_Access);
      pragma Warnings (On);
   begin
      return To_Requisition (Glib.Values.Get_Address (Value));
   end Get_Requisition;
       </body>
     </extra>
   </package>

   <package id="PangoEnums">
     <enum ctype="PangoAlignment" ada="Alignment"/>
     <enum ctype="PangoAttrType" ada="Attr_Type"/>
     <enum ctype="PangoCoverageLevel" ada="Coverage_Level"/>
     <enum ctype="PangoDirection" ada="Direction"/>
     <enum ctype="PangoFontMask" ada="Font_Mask"/>
     <enum ctype="PangoGravity" ada="Gravity"/>
     <enum ctype="PangoGravityHint" ada="GravityHint"/>
     <enum ctype="PangoStretch" ada="Stretch"/>
     <enum ctype="PangoStyle" ada="Style"/>
     <enum ctype="PangoUnderline" ada="Underline"/>
     <enum ctype="PangoVariant" ada="Variant"/>
     <enum ctype="PangoWeight" ada="Weight"/>
     <enum ctype="PangoWrapMode" ada="Wrap_Mode"/>

     <extra>
       <with_spec pkg="Glib"/>
       <spec>
   Pango_Scale : constant := 1024;
   --  All internal units in Pango are expressed in terms of this unit. A
   --  typical pango size must be divided by Pango_Scale to get the equivalent
   --  in pixels.

   function To_Pixels (Pango_Units : Gint) return Gint;
   --  Convert a size in pango units to pixels. This is a rounding of
   --  Pango_Units divided by Pango_Scale

   --  Enum types are bound with the following algorithm:
   --    + the "Pango" prefix of the type name is stripped
   --    + Each word of the type name is separated by '_'
   --    + the full enum name is kept, but capitalized.

   --  All enums types should be sorted by alphabetical order...
       </spec>
       <body>
   function To_Pixels (Pango_Units : Gint) return Gint is
   begin
      if Pango_Units > 0 then
         return (Pango_Units + Pango_Scale / 2) / Pango_Scale;
      else
         return (Pango_Units - Pango_Scale / 2) / Pango_Scale;
      end if;
   end To_Pixels;
       </body>
     </extra>
   </package>

   <package id="GtkEnums">
     <enum ctype="GtkArrowType"/>
     <enum ctype="GtkAttachOptions"/>
     <enum ctype="GtkButtonBoxStyle"/>
     <enum ctype="GtkCornerType"/>
     <enum ctype="GtkDeleteType"/>
     <enum ctype="GtkDirectionType"/>
     <enum ctype="GtkDragResult"/>
     <enum ctype="GtkExpanderStyle"/>
     <enum ctype="GtkIconSize" asbitfield="True"/>
     <enum ctype="GtkJunctionSides"/>
     <enum ctype="GtkJustification"/>
     <enum ctype="GtkMenuDirectionType"/>
     <enum ctype="GtkMovementStep"/>
     <enum ctype="GtkInputHints"/>
     <enum ctype="GtkInputPurpose"/>
     <enum ctype="GtkNumberUpLayout" prefix="GTK_NUMBER_UP_LAYOUT_"/>
     <enum ctype="GtkOrientation"/>
     <enum ctype="GtkPackDirection"/>
     <enum ctype="GtkPackType"/>
     <enum ctype="GtkPageOrientation"/>
     <enum ctype="GtkPageSet"/>
     <enum ctype="GtkLevelBarMode"/>
     <enum ctype="GtkPathPriorityType"/>
     <enum ctype="GtkPathType"/>
     <enum ctype="GtkPolicyType"/>
     <enum ctype="GtkPositionType"/>
     <enum ctype="GtkPrintDuplex"/>
     <enum ctype="GtkPrintPages"/>
     <enum ctype="GtkPrintQuality"/>
     <enum ctype="GtkRegionFlags"/>
     <enum ctype="GtkReliefStyle"/>
     <enum ctype="GtkResizeMode"/>
     <enum ctype="GtkScrollStep"/>
     <enum ctype="GtkScrollType"/>
     <enum ctype="GtkScrollablePolicy"/>
     <enum ctype="GtkSelectionMode"/>
     <enum ctype="GtkSensitivityType"/>
     <enum ctype="GtkShadowType"/>
     <enum ctype="GtkSizeRequestMode" prefix="GTK_SIZE_REQUEST_"/>
     <enum ctype="GtkSortType"/>
     <enum ctype="GtkStateFlags" prefix=""/>
     <enum ctype="GtkStateType"/>
     <enum ctype="GtkTargetFlags" prefix=""/>
     <enum ctype="GtkTextDirection"/>
     <enum ctype="GtkTextWindowType"/>
     <enum ctype="GtkTreeViewGridLines" prefix="GTK_TREE_VIEW_"/>
     <enum ctype="GtkToolbarSpaceStyle"/>
     <enum ctype="GtkToolbarStyle"/>
     <enum ctype="GtkUnit" prefix="GTK_UNIT_"/>
     <enum ctype="GtkWindowPosition"/>
     <enum ctype="GtkWindowType"/>
     <enum ctype="GtkWrapMode"/>

     <extra>
       <with_spec pkg="Glib.Glist"/>
       <with_spec pkg="Glib.GSlist"/>
       <spec>
   function Convert (S : String) return System.Address;
   function Convert (S : System.Address) return String;
   package String_List is new Glib.Glist.Generic_List (UTF8_String);
   package String_SList is new Glib.GSlist.Generic_SList (UTF8_String);
   --  Warning: when you create this list, new memory gets allocated for
   --  all the strings. You should use the function Free_String_List
   --  instead of Glib.Glist.Free to be sure to free this memory.

   procedure Free_String_List (List : in out String_List.Glist);
   procedure Free_String_List (List : in out String_SList.GSlist);
   --  Free the memory occupied by all the strings in the list, as well
   --  as the memory occupied by the list itself.
       </spec>
       <with_body pkg="Ada.Unchecked_Conversion" use="False"/>
       <with_body pkg="Interfaces.C.Strings" use="False"/>
       <body>
   function Convert (S : String) return System.Address is
      function Internal is new
        Ada.Unchecked_Conversion (Interfaces.C.Strings.chars_ptr, System.Address);
   begin
      return Internal (Interfaces.C.Strings.New_String (S));
   end Convert;

   function Convert_Chars_Ptr is new
     Ada.Unchecked_Conversion (System.Address, Interfaces.C.Strings.chars_ptr);

   function Convert (S : System.Address) return String is
   begin
      return Interfaces.C.Strings.Value (Convert_Chars_Ptr (S));
   end Convert;

   procedure Free_String_List (List : in out String_List.Glist) is
      use type String_List.Glist;
      Tmp   : String_List.Glist := List;
      Chars : Interfaces.C.Strings.chars_ptr;
   begin
      while Tmp /= String_List.Null_List loop
         Chars := Convert_Chars_Ptr (String_List.Get_Data_Address (Tmp));
         Interfaces.C.Strings.Free (Chars);
         Tmp := String_List.Next (Tmp);
      end loop;

      String_List.Free (List);
      List := String_List.Null_List;
   end Free_String_List;

   procedure Free_String_List (List : in out String_SList.GSlist) is
      use type String_SList.GSlist;

      Tmp   : String_SList.GSlist := List;
      Chars : Interfaces.C.Strings.chars_ptr;
   begin
      while Tmp /= String_SList.Null_List loop
         Chars := Convert_Chars_Ptr (String_SList.Get_Data_Address (Tmp));
         Interfaces.C.Strings.Free (Chars);
         Tmp := String_SList.Next (Tmp);
      end loop;

      String_SList.Free (List);
      List := String_SList.Null_List;
   end Free_String_List;
       </body>
     </extra>
   </package>

   <package id="GtkContainer">
     <parameter name="self" ada="Container"/>
     <method id="gtk_container_add_with_properties" bind="False"/><!-- varargs -->
     <method id="gtk_container_child_get" bind="False"/> <!-- varargs -->
     <method id="gtk_container_child_get_valist" bind="False"/> <!-- varargs -->
     <method id="gtk_container_child_set" bind="False"/> <!-- varargs -->
     <method id="gtk_container_child_set_valist" bind="False"/> <!-- varargs -->
     <method id="gtk_container_get_children" return="WidgetList"/>
     <method id="gtk_container_set_focus_chain">
       <parameter name="focusable_widgets" ctype="WidgetList"/>
     </method>
     <method id="gtk_container_child_set_property">
       <parameter name="value" direction="in" ctype="GValue"/>
     </method>

     <!-- ??? Binding needs testing -->
     <method id="gtk_container_get_focus_chain" return_as_param="Success" bind="false">
       <parameter name="focusable_widgets" ctype="WidgetList*" direction="out"/>
     </method>
   </package>

   <package id="GtkSpinButton">
     <parameter name="self" ada="Spin_Button"/>
     <enum ctype="GtkSpinType"/>
     <enum ctype="GtkSpinButtonUpdatePolicy"/>
     <method id="gtk_spin_button_new_with_range" ada="Gtk_New"/>
     <method id="gtk_spin_button_new">
       <parameter name="digits" default="0"/>
     </method>
   </package>

   <package id="GtkAction">
     <parameter name="self" ada="Action"/>
     <method id="gtk_action_get_accel_closure" bind="False" /> <!-- Closures not handled-->
     <method id="gtk_action_get_proxies" return="WidgetSList*"/>
   </package>

   <package id="GtkMenu">
     <parameter name="self" ada="Menu"/>
     <method id="gtk_menu_get_active" return="GtkMenuItem"/>
     <method id="gtk_menu_popup">
       <parameter name="parent_menu_shell" ctype="GtkMenuShell" default="null"/>
       <parameter name="parent_menu_item" ctype="GtkMenuItem" default="null"/>
       <parameter name="func" default="null"/>
       <parameter name="button" default="1"/>
       <parameter name="x" direction="inout" />
       <parameter name="y" direction="inout" />
       <parameter name="activate_time" default="0"/>
     </method>
     <method id="gtk_menu_get_for_attach_widget" return="WidgetList*"/>
   </package>

   <package id="GtkMenuBar">
     <parameter name="self" ada="Menu_Bar"/>
   </package>

   <package id="GtkMenuShell">
     <parameter name="self" ada="Menu_Shell"/>
   </package>

   <package id="GtkMenuToolButton">
     <parameter name="self" ada="Button"/>
     <method id="gtk_menu_tool_button_new">
       <parameter name="self" ada="Menu"/>
       <parameter name="icon_widget" default="null"/>
     </method>
     <method id="gtk_menu_tool_button_new_from_stock">
       <parameter name="self" ada="Menu"/>
     </method>
     <method id="gtk_menu_tool_button_get_menu" return="GtkMenu"/>
   </package>

   <package id="GtkImageMenuItem">
     <method id="gtk_image_menu_item_new"/>
     <method id="gtk_image_menu_item_new_with_label" ada="Gtk_New"/>
   </package>

   <package id="GtkCheckMenuItem">
     <parameter name="self" ada="Check_Menu_Item"/>
      <method id="gtk_check_menu_item_new" bind="False"/>
      <method id="gtk_check_menu_item_new_with_label" ada="Gtk_New" >
         <parameter name="label" default='""' allow-none="1"/>
      </method>
   </package>

   <package id="GdkRGBA">
     <method id="gdk_rgba_equal">
       <parameter name="p2" ctype="GdkRGBA*"/>
     </method>
     <method id="gdk_rgba_parse" return_as_param="Success">
       <parameter name="self" direction="out"/>
     </method>
     <extra>
       <with_spec pkg="Glib.Values" />
       <with_spec pkg="Glib.Object" />
       <spec>
   type array_of_Gdk_RGBA is array (Natural range &lt;&gt;) of Gdk_RGBA;

   Null_RGBA  : constant Gdk_RGBA := (0.0, 0.0, 0.0, 0.0);
   Black_RGBA : constant Gdk_RGBA := (0.0, 0.0, 0.0, 1.0);
   White_RGBA : constant Gdk_RGBA := (1.0, 1.0, 1.0, 1.0);

   type Property_RGBA is new Glib.Property;
   procedure Set_Property
     (Object : access Glib.Object.GObject_Record'Class;
      Name   : Property_RGBA;
      Value  : Gdk_RGBA);
   function Get_Property
     (Object : access Glib.Object.GObject_Record'Class;
      Name   : Property_RGBA) return Gdk_RGBA;

   function Gdk_RGBA_Or_Null (Val : System.Address) return System.Address;
   --  Used for the GtkAda binding itself.
   --  Return either a Null_Address or a pointer to Val, depending on
   --  whether Val is the null value for the type.
   --  In all cases, Val is supposed to be an access to the type mentioned in
   --  the name of the subprogram.
   --  In Ada2012, these could be replaced with expression functions instead.

   procedure Set_Value (Value : out Glib.Values.GValue; Val : Gdk_RGBA);
   function  Get_Value (Value : Glib.Values.GValue) return Gdk_RGBA;
   --  Conversion functions for storing a Gdk_RGBA as a GValue.
       </spec>
       <with_body pkg="Glib.Generic_Properties" />
       <body>
   function To_Address
     (Val : Gdk_RGBA; Addr : System.Address) return System.Address;
   package RGBA_Properties is new Generic_Internal_Boxed_Property
     (Gdk_RGBA, Gdk.RGBA.Get_Type, To_Address);

   procedure Set_Property
     (Object : access Glib.Object.GObject_Record'Class;
      Name   : Property_RGBA;
      Value  : Gdk_RGBA) is
   begin
      RGBA_Properties.Set_Property
         (Object, RGBA_Properties.Property (Name), Value);
   end Set_Property;

   function Get_Property
     (Object : access Glib.Object.GObject_Record'Class;
      Name   : Property_RGBA) return Gdk_RGBA is
   begin
      return RGBA_Properties.Get_Property
        (Object, RGBA_Properties.Property (Name));
   end Get_Property;

   function Gdk_RGBA_Or_Null (Val : System.Address) return System.Address is
      function Internal is new Gtkada.Bindings.Generic_To_Address_Or_Null
        (Gdk_RGBA, Null_RGBA);
   begin
      return Internal (Val);
   end Gdk_RGBA_Or_Null;

   function Get_Value (Value : Glib.Values.GValue) return Gdk_RGBA
     renames RGBA_Properties.Get_Value;
   procedure Set_Value (Value : out Glib.Values.GValue; Val : Gdk_RGBA)
     renames RGBA_Properties.Set_Value;

   function To_Address
     (Val : Gdk_RGBA; Addr : System.Address) return System.Address is
   begin
      if Val = Null_RGBA then
         return System.Null_Address;
      else
         return Addr;
      end if;
   end To_Address;
       </body>
     </extra>
   </package>

   <package id="GtkScrolledWindow">
     <parameter name="self" ada="Scrolled_Window"/>
     <method id="gtk_scrolled_window_new">
       <parameter name="hadjustment" default="null"/>
       <parameter name="vadjustment" default="null"/>
     </method>
     <method id="gtk_scrolled_window_get_hscrollbar" return="GtkScrollbar"/>
     <method id="gtk_scrolled_window_get_vscrollbar" return="GtkScrollbar"/>
   </package>

   <package id="GtkWindow">
     <parameter name="self" ada="Window"/>
     <method id="gtk_window_new">
       <parameter name="type" default="Gtk.Enums.Window_Toplevel"/>
     </method>
     <method id="gtk_window_set_opacity" bind="False"/> <!-- would hide Gtk.Widget.Set_Opacity-->
     <method id="gtk_window_get_opacity" bind="False"/> <!-- would hide Gtk.Widget.Get_Opacity-->
     <method id="gtk_window_list_toplevels" return="WidgetList"/>
     <method id="gtk_window_get_icon_list" return="ObjectList"/>
     <method id="gtk_window_set_icon_list">
       <parameter name="list" ctype="ObjectList"/>
     </method>
     <method id="gtk_window_get_default_icon_list" return="ObjectList"/>
     <method id="gtk_window_set_default_icon_list">
       <parameter name="list" ctype="ObjectList"/>
     </method>
     <method id="gtk_window_add_mnemonic">
       <parameter name="keyval" ctype="GdkKeyType"/>
     </method>
     <method id="gtk_window_remove_mnemonic">
       <parameter name="keyval" ctype="GdkKeyType"/>
     </method>
     <method id="gtk_window_mnemonic_activate">
       <parameter name="keyval" ctype="GdkKeyType"/>
     </method>
     <method id="gtk_window_get_resize_grip_area" return_as_param="retrieved"/>
     <method id="gtk_window_set_modal">
       <parameter name="modal" default="True"/>
     </method>

     <method id="gtk_window_get_application" bind="False"/> <!-- Circular dependency -->
     <method id="gtk_window_set_application" bind="False"/> <!-- Circular dependency -->
   </package>

   <package id="GtkWindowGroup" into="GtkWindow">
     <parameter name="self" ada="Window_Group"/>
     <method id="gtk_window_group_get_type" ada="Group_Get_Type"/>
     <method id="gtk_window_group_list_windows" return="WidgetList"/>
   </package>

   <package id="GtkPaperSize">
     <parameter name="self" ada="Widget"/>
     <list ada="Gtk_Paper_Size_Glist" ctype="GtkPaperSize" section="Functions"/>
     <method id="gtk_paper_size_get_paper_sizes" return="GtkPaperSizeList"/>
     <extra>
       <spec>
   --  Common names, from PWG 5101.1-2002 PWG: Standard for Media Standardized
   --  Names
   Gtk_Paper_Name_A3        : constant String := "iso_a3";
   Gtk_Paper_Name_A4        : constant String := "iso_a4";
   Gtk_Paper_Name_A5        : constant String := "iso_a5";
   Gtk_Paper_Name_B5        : constant String := "iso_b5";
   Gtk_Paper_Name_Letter    : constant String := "na_letter";
   Gtk_Paper_Name_Executive : constant String := "na_executive";
   Gtk_Paper_Name_Legal     : constant String := "na_legal";
       </spec>
     </extra>
   </package>

   <package id="GtkRecentAction">
     <parameter name="self" ada="Widget"/>
     <method id="gtk_recent_action_new_for_manager">
       <parameter name="manager" default="Gtk.Recent_Manager.Get_Default"/>
     </method>
   </package>

   <package id="GtkTearoffMenuItem">
     <parameter name="self" ada="Menu_Item"/>
   </package>

   <package id="GtkRecentChooserDialog">
     <parameter name="self" ada="Widget"/>
     <extra>
       <gir:constructor c:identifier="ada_gtk_recent_chooser_dialog_new" name="new">
         <gir:return-value>
           <gir:type name="GtkWidget" c:type="GtkWidget*"/>
         </gir:return-value>
         <gir:parameters>
           <gir:parameter name="title" allow-none="1">
             <gir:type name="utf8" c:type="gchar*"/>
           </gir:parameter>
           <gir:parameter name="parent" allow-none="1">
             <gir:type name="Window" c:type="GtkWindow*"/>
           </gir:parameter>
         </gir:parameters>
       </gir:constructor>
       <gir:constructor c:identifier="ada_gtk_recent_chooser_dialog_new_for_manager" name="new_for_manager">
         <gir:return-value>
           <gir:type name="GtkWidget" c:type="GtkWidget*"/>
         </gir:return-value>
         <gir:parameters>
           <gir:parameter name="title" allow-none="1">
             <gir:type name="utf8" c:type="gchar*"/>
           </gir:parameter>
           <gir:parameter name="parent" allow-none="1">
             <gir:type name="Window" c:type="GtkWindow*"/>
           </gir:parameter>
           <gir:parameter name="manager" allow-none="1">
             <gir:type name="RecentManager" c:type="GtkRecentManager*"/>
           </gir:parameter>
         </gir:parameters>
       </gir:constructor>
     </extra>
   </package>

   <package id="GtkRecentChooserMenu">
   </package>

   <package id="GtkRecentChooserWidget">
     <parameter name="self" ada="Widget"/>
   </package>

   <package id="GtkToggleAction">
     <parameter name="self" ada="Action"/>
   </package>

   <package id="GtkToggleToolButton">
     <parameter name="self" ada="Button"/>
   </package>

   <package id="GtkStyle">
     <parameter name="self" ada="Style"/>
      <method id="gtk_style_get_valist" bind="False"/><!-- va_list -->
      <method id="gtk_style_lookup_color"
              return_as_param="Found"/>

      <method id="gtk_style_render_icon" bind="False"/>  <!-- need icon_source -->
      <method id="gtk_style_lookup_icon_set" bind="False"/>  <!-- need icon_factory -->
   </package>

   <package id="GtkSymbolicColor">
     <method id="gtk_symbolic_color_resolve" bind="False"/> <!-- circular dep with StyleProperties -->
   </package>

   <package id="GtkStyleProvider">
     <method id="gtk_style_provider_get_style" bind="False" /> <!-- circular dep with StyleProperties -->
     <method id="gtk_style_provider_get_style_property"
             return_as_param="Found"/>
     <method id="gtk_style_provider_get_icon_factory" bind="False" /> <!-- in GtkIconFactory -->
     <extra>
       <spec>
         subtype Priority is Glib.Guint;

         Priority_Fallback : constant Priority := 1;
         --  Used when no theme is defined

         Priority_Theme : constant Priority := 200;
         --  Used for style information provided by the theme

         Priority_Settings : constant Priority := 400;
         --  Used for information provided via Gtk_Settings

         Priority_Application : constant Priority := 600;
         --  For application-specific information

         Priority_User : constant Priority := 800;
         --  Used for the style information from ~/.gtk-3.0.css
       </spec>
     </extra>
   </package>

   <package id="GtkStyleProperties">
     <method id="gtk_style_properties_get_property"
             return_as_param="Exists"/>
     <method id="gtk_style_properties_set_valist" bind="False"/> <!-- need valist -->
     <method id="gtk_style_properties_get_valist" bind="False"/> <!-- need valist -->
     <method id="gtk_style_properties_lookup_property" bind="False"/> <!-- need StylePropertyParser -->
     <method id="gtk_style_properties_register_property" bind="False"/> <!-- need StylePropertyParser -->
   </package>

   <package id="GtkStyleContext">
     <method id="gtk_style_context_has_region"
             return_as_param="Is_Defined"/>
     <method id="gtk_style_context_list_classes" return="StringList"/>
     <method id="gtk_style_context_list_regions" return="StringList"/>
     <method id="gtk_style_context_get_valist" bind="False"/> <!-- needs valist -->
     <method id="gtk_style_context_get_style_valist" bind="False"/> <!-- needs valist -->
     <method id="gtk_style_context_lookup_color" return_as_param="Found"/>
     <method id="gtk_style_context_state_is_running"
             return_as_param="Is_Running"/>
     <method id="gtk_style_context_lookup_icon_set" bind="False"/> <!--  in GtkIconSet-->
     <function id="gtk_render_handle"/>
     <function id="gtk_render_check" />
     <function id="gtk_render_option" />
     <function id="gtk_render_arrow" />
     <function id="gtk_render_background" />
     <function id="gtk_render_frame" />
     <function id="gtk_render_expander" />
     <function id="gtk_render_focus" />
     <function id="gtk_render_layout" />
     <function id="gtk_render_line" />
     <function id="gtk_render_slider" />
     <function id="gtk_render_frame_gap" />
     <function id="gtk_render_extension" />
     <function id="gtk_render_activity" />
     <!--  <function id="gtk_render_icon_pixbuf" /> -->
     <function id="gtk_render_icon" />
     <extra>
       <spec>
   function Get_Style_Context
      (Widget : not null access Gtk_Widget_Record'Class)
       return Gtk_Style_Context;
   --  Returns the style context associated to Widget.
   --  must not be freed.
       </spec>
       <body>
   function Get_Style_Context
      (Widget : not null access Gtk_Widget_Record'Class)
       return Gtk_Style_Context
   is
      function Internal (Widget : System.Address) return System.Address;
      pragma Import (C, Internal, "gtk_widget_get_style_context");
      Stub_Gtk_Style_Context : Gtk_Style_Context_Record;
   begin
      return Gtk_Style_Context
         (Get_User_Data (Internal (Get_Object (Widget)), Stub_Gtk_Style_Context));
   end Get_Style_Context;
       </body>
     </extra>
   </package>

   <package id="GtkToolButton">
     <parameter name="self" ada="Button"/>
     <method id="gtk_tool_button_new">
       <parameter name="icon_widget" default="null" />
     </method>
   </package>

   <package id="GtkFontButton">
     <parameter name="self" ada="Font_Button"/>
   </package>

   <package id="GtkTextBuffer">
     <parameter name="self" ada="Buffer"/>

      <!-- the following involve a complex callback type and are not needed -->
     <method id="gtk_text_buffer_register_serialize_format" bind="False"/>
     <method id="gtk_text_buffer_register_deserialize_format" bind="False"/>
     <method id="gtk_text_buffer_serialize" bind="False"/>
     <method id="gtk_text_buffer_deserialize" bind="False"/>
     <method id="gtk_text_buffer_get_serialize_formats" bind="False"/>
     <method id="gtk_text_buffer_get_deserialize_formats" bind="False"/>

     <method id="gtk_text_buffer_new">
        <parameter name="table" default="null"/>
     </method>

     <method id="gtk_text_buffer_create_mark">
        <parameter name="left_gravity" default="True"/>
     </method>

     <method id="gtk_text_buffer_get_text">
        <parameter name="include_hidden_chars" default="False"/>
     </method>

     <method id="gtk_text_buffer_get_slice">
        <parameter name="include_hidden_chars" default="False"/>
     </method>

     <method id="gtk_text_buffer_paste_clipboard">
        <parameter name="override_location" ada="" ctype="gpointer" default="System.Null_Address"/>
        <parameter name="default_editable" default="True"/>
     </method>

     <method id="gtk_text_buffer_get_selection_bounds" return_as_param="Result">
        <parameter name="start" direction="out"/>
        <parameter name="end" direction="out"/>
     </method>

     <method id="gtk_text_buffer_delete">
        <parameter name="start" direction="inout"/>
        <parameter name="end" direction="inout"/>
     </method>

     <method id="gtk_text_buffer_delete_interactive" return_as_param="Result">
        <parameter name="start" direction="inout"/>
        <parameter name="end" direction="inout"/>
     </method>

     <method id="gtk_text_buffer_insert">
        <parameter name="iter" direction="inout"/>
        <parameter name="len" default="-1" ada=""/>
     </method>

     <method id="gtk_text_buffer_insert_interactive">
        <parameter name="iter" direction="inout"/>
        <parameter name="len" default="-1" ada=""/>
     </method>

     <method id="gtk_text_buffer_insert_interactive_at_cursor">
        <parameter name="len" default="-1" ada=""/>
     </method>

     <method id="gtk_text_buffer_set_text">
        <parameter name="len" default="-1" ada=""/>
     </method>

     <method id="gtk_text_buffer_insert_at_cursor">
        <parameter name="len" default="-1" ada=""/>
     </method>

     <method id="gtk_text_buffer_create_tag" bind="False"/><!-- vararg, bound manually below -->
     <method id="gtk_text_buffer_insert_with_tags" bind="False"/><!-- vararg, bound manually below -->

      <!-- body bound manually to add safety check -->
     <method id="gtk_text_buffer_get_iter_at_line_offset">
        <body>
      procedure Internal
         (Buffer      : System.Address;
          Iter        : out Gtk.Text_Iter.Gtk_Text_Iter;
          Line_Number : Gint;
          Char_Offset : Gint);
      pragma Import (C, Internal, "gtk_text_buffer_get_iter_at_line_offset");
      Result   : Boolean;
   begin
      --  Prevent critical crashes from gtk+ if Char_Offset is invalid
      Internal (Get_Object (Buffer), Iter, Line_Number, 0);

      if not Ends_Line (Iter) then
         Forward_To_Line_End (Iter, Result);

         if Char_Offset &lt;= Get_Line_Offset (Iter) then
            Internal (Get_Object (Buffer), Iter, Line_Number, Char_Offset);
         end if;
      end if;
       </body>
     </method>

     <extra>
       <with_spec pkg="Gtkada.Types"/>
       <spec>
   procedure Insert
     (Buffer : access Gtk_Text_Buffer_Record;
      Iter   : in out Gtk.Text_Iter.Gtk_Text_Iter;
      Text   : Gtkada.Types.Chars_Ptr);
   --  More efficient version of Insert, which doesn't require a string copy.

   procedure Insert_At_Cursor
     (Buffer : access Gtk_Text_Buffer_Record;
      Text   : Gtkada.Types.Chars_Ptr;
      Len    : Gint := -1);
   --  Call Buffer_Insert, using the current cursor position
   --  as the insertion point.
   --  Text: UTF-8 format C string to insert.

   function Get_Text
     (Buffer               : access Gtk_Text_Buffer_Record;
      Start                : Gtk.Text_Iter.Gtk_Text_Iter;
      The_End              : Gtk.Text_Iter.Gtk_Text_Iter;
      Include_Hidden_Chars : Boolean := False) return Gtkada.Types.Chars_Ptr;
   --  Same as Get_Text above, but return a pointer to a C string, for
   --  efficiency.
   --  The caller is responsible for freeing (using Gtkada.Types.g_free) the
   --  returned pointer.

   function Selection_Exists
     (Buffer : access Gtk_Text_Buffer_Record) return Boolean;
   --  Return True if some text in the buffer is currently selected.

   procedure Insert_With_Tags
     (Buffer : access Gtk_Text_Buffer_Record;
      Iter   : in out Gtk.Text_Iter.Gtk_Text_Iter;
      Text   : UTF8_String;
      Tag    : Gtk_Text_Tag);
   procedure Insert_With_Tags
     (Buffer : access Gtk_Text_Buffer_Record;
      Iter   : in out Gtk.Text_Iter.Gtk_Text_Iter;
      Text   : Gtkada.Types.Chars_Ptr;
      Tag    : Gtk.Text_Tag.Gtk_Text_Tag);
   --  Same as Insert, but specifies the tag to apply to the range.

   function Get_Buffer
      (Iter : Gtk_Text_Iter) return Gtk.Text_Buffer.Gtk_Text_Buffer;
   --  Returns the Gtk.Text_Buffer.Gtk_Text_Buffer this iterator is associated
   --  with.

   function Get_Buffer
      (Mark : Gtk_Text_Mark)
       return Gtk.Text_Buffer.Gtk_Text_Buffer;
   --  Gets the buffer this mark is located inside, or null if the mark is
   --  deleted.

   function Create_Tag
     (Buffer              : access Gtk_Text_Buffer_Record;
      Tag_Name            : String := "")
      return Gtk.Text_Tag.Gtk_Text_Tag;
   --  Creates a tag and adds it to the tag table for Buffer. Equivalent to
   --  calling gtk.text_tag.gtk_new and then adding the tag to the buffer's tag
   --  table. The returned tag is owned by the buffer's tag table, so the ref
   --  count will be equal to one.
   --
   --  If Tag_Name is NULL, the tag is anonymous, otherwise a tag called
   --  Tag_Name must not already exist in the tag table for this buffer.
       </spec>
       <body>
   ------------
   -- Insert --
   ------------

   procedure Insert
     (Buffer : access Gtk_Text_Buffer_Record;
      Iter   : in out Gtk.Text_Iter.Gtk_Text_Iter;
      Text   : Gtkada.Types.Chars_Ptr)
   is
      procedure Internal
        (Buffer : System.Address;
         Iter   : Gtk.Text_Iter.Gtk_Text_Iter;
         Text   : Gtkada.Types.Chars_Ptr;
         Len    : Gint := -1);
      pragma Import (C, Internal, "gtk_text_buffer_insert");

   begin
      Internal (Get_Object (Buffer), Iter, Text);
   end Insert;

   procedure Insert_At_Cursor
     (Buffer : access Gtk_Text_Buffer_Record;
      Text   : Gtkada.Types.Chars_Ptr;
      Len    : Gint := -1)
   is
      procedure Internal
        (Buffer : System.Address;
         Text   : Gtkada.Types.Chars_Ptr;
         Len    : Gint);
      pragma Import (C, Internal, "gtk_text_buffer_insert_at_cursor");

   begin
      Internal (Get_Object (Buffer), Text, Len);
   end Insert_At_Cursor;

   procedure Insert_With_Tags
     (Buffer : access Gtk_Text_Buffer_Record;
      Iter   : in out Gtk.Text_Iter.Gtk_Text_Iter;
      Text   : UTF8_String;
      Tag    : Gtk_Text_Tag)
   is
      procedure Internal
        (Buffer : System.Address;
         Iter   : in out Gtk.Text_Iter.Gtk_Text_Iter;
         Text   : UTF8_String;
         Len    : Gint;
         Tag    : System.Address);
      pragma Import (C, Internal, "ada_gtk_text_buffer_insert_with_tags");

   begin
      Internal
        (Get_Object (Buffer), Iter, Text, Text'Length, Get_Object (Tag));
   end Insert_With_Tags;

   procedure Insert_With_Tags
     (Buffer : access Gtk_Text_Buffer_Record;
      Iter   : in out Gtk.Text_Iter.Gtk_Text_Iter;
      Text   : Gtkada.Types.Chars_Ptr;
      Tag    : Gtk.Text_Tag.Gtk_Text_Tag)
   is
      procedure Internal
        (Buffer : System.Address;
         Iter   : in out Gtk.Text_Iter.Gtk_Text_Iter;
         Text   : Gtkada.Types.Chars_Ptr;
         Len    : Gint := -1;
         Tag    : System.Address);
      pragma Import (C, Internal, "ada_gtk_text_buffer_insert_with_tags");

   begin
      Internal (Get_Object (Buffer), Iter, Text, Tag => Get_Object (Tag));
   end Insert_With_Tags;

   --------------
   -- Get_Text --
   --------------

   function Get_Text
     (Buffer               : access Gtk_Text_Buffer_Record;
      Start                : Gtk.Text_Iter.Gtk_Text_Iter;
      The_End              : Gtk.Text_Iter.Gtk_Text_Iter;
      Include_Hidden_Chars : Boolean := False) return Gtkada.Types.Chars_Ptr
   is
      function Internal
        (Buffer               : System.Address;
         Start                : Gtk.Text_Iter.Gtk_Text_Iter;
         The_End              : Gtk.Text_Iter.Gtk_Text_Iter;
         Include_Hidden_Chars : Gboolean)
         return Interfaces.C.Strings.chars_ptr;
      pragma Import (C, Internal, "gtk_text_buffer_get_text");

   begin
      return Internal
        (Get_Object (Buffer),
         Start,
         The_End,
         Boolean'Pos (Include_Hidden_Chars));
   end Get_Text;

   function Selection_Exists
     (Buffer : access Gtk_Text_Buffer_Record) return Boolean
   is
      Ignored_A, Ignored_B : Gtk_Text_Iter;
      Has_Selection : Boolean;
   begin
      Get_Selection_Bounds (Buffer, Ignored_A, Ignored_B, Has_Selection);
      return Has_Selection;
   end Selection_Exists;

   ----------------
   -- Get_Buffer --
   ----------------

   function Get_Buffer
      (Iter : Gtk_Text_Iter) return Gtk.Text_Buffer.Gtk_Text_Buffer
   is
      function Internal (Iter : Gtk_Text_Iter) return System.Address;
      pragma Import (C, Internal, "gtk_text_iter_get_buffer");
      Stub_Gtk_Text_Buffer : Gtk.Text_Buffer.Gtk_Text_Buffer_Record;
   begin
      return Gtk.Text_Buffer.Gtk_Text_Buffer (Get_User_Data (Internal (Iter), Stub_Gtk_Text_Buffer));
   end Get_Buffer;

   ----------------
   -- Get_Buffer --
   ----------------

   function Get_Buffer
      (Mark : Gtk_Text_Mark)
       return Gtk.Text_Buffer.Gtk_Text_Buffer
   is
      function Internal (Mark : System.Address) return System.Address;
      pragma Import (C, Internal, "gtk_text_mark_get_buffer");
      Stub_Gtk_Text_Buffer : Gtk.Text_Buffer.Gtk_Text_Buffer_Record;
   begin
      return Gtk.Text_Buffer.Gtk_Text_Buffer (Get_User_Data (Internal (Get_Object (Mark)), Stub_Gtk_Text_Buffer));
   end Get_Buffer;

   ----------------
   -- Create_Tag --
   ----------------

   function Create_Tag
     (Buffer              : access Gtk_Text_Buffer_Record;
      Tag_Name            : String := "")
      return Gtk_Text_Tag
   is
      function Internal
        (Buffer              : System.Address;
         Tag_Name            : Interfaces.C.Strings.chars_ptr)
         return System.Address;
      pragma Import (C, Internal, "ada_gtk_text_buffer_create_tag");
      Stub : Gtk_Text_Tag_Record;
      Str  : Interfaces.C.Strings.chars_ptr := String_Or_Null (Tag_Name);
      Tag  : Gtk_Text_Tag;
   begin
      Tag := Gtk_Text_Tag
        (Get_User_Data (Internal (Get_Object (Buffer), Str), Stub));
      Free (Str);
      return Tag;
   end Create_Tag;
       </body>
     </extra>
   </package>

   <package id="GtkTextMark">
     <parameter name="self" ada="Mark"/>
     <method id="gtk_text_mark_get_buffer" bind="False"/><!-- circular dependency, added manually in Gtk.Text_Buffer -->

     <extra>
       <with_spec pkg="Glib.Values"/>
       <spec>
   -------------------------------
   -- Converting to/from GValue --
   -------------------------------

   procedure Set_Text_Mark
     (Val  : in out Glib.Values.GValue;
      Mark : access Gtk_Text_Mark_Record);
   function Get_Text_Mark (Val : Glib.Values.GValue) return Gtk_Text_Mark;
   --  Set the value of the given GValue to Mark.

       </spec>
       <body>
   -------------------
   -- Set_Text_Mark --
   -------------------

   procedure Set_Text_Mark
     (Val  : in out Glib.Values.GValue;
      Mark : access Gtk_Text_Mark_Record) is
   begin
      Glib.Values.Set_Address (Val, Get_Object (Mark));
   end Set_Text_Mark;

   -------------------
   -- Get_Text_Mark --
   -------------------

   function Get_Text_Mark (Val  : Glib.Values.GValue) return Gtk_Text_Mark is
      Stub : Gtk_Text_Mark_Record;
   begin
      return Gtk_Text_Mark
        (Get_User_Data_Fast (Glib.Values.Get_Address (Val), Stub));
   end Get_Text_Mark;
       </body>
     </extra>
   </package>

   <package id="GtkTextChildAnchor">
     <parameter name="self" ada="Anchor"/>
     <method id="gtk_text_child_anchor_get_widgets" return="WidgetSList"/>
   </package>

   <package id="GtkTextTag">
     <parameter name="self" ada="Tag"/>
     <method id="::event" bind="False" />
     <method id="gtk_text_tag_new">
       <doc extend="true">
Newly created tags must be added to the tags table for the buffer you
intend to use them in, as in:
 "Gtk.Text_Tag_Table.Add (Get_Tag_Table (Buffer), Tag)".
See also Gtk.Text_Buffer.Create_Tag which is a more convenient way of
creating a tag.
       </doc>
     </method>
     <method id="gtk_text_tag_event" bind="false"/> <!-- circular dep with text_iter-->
     <slist ada="Text_Tag_List" ctype="GtkTextTag"/>
   </package>

   <package id="GtkCssProvider">
     <method id="::parsing-error" bind="False" />
     <method id="gtk_css_provider_load_from_data">
       <parameter name="data" ctype="char*"/>
       <parameter name="length" default="-1" ada=""/>
       <parameter name="error" direction="access"/>
     </method>
     <method id="gtk_css_provider_load_from_path">
       <parameter name="error" direction="access"/>
     </method>
     <method id="gtk_css_provider_load_from_file" bind="False"/> <!--  needs GFile -->
   </package>

   <package id="GtkMain">
     <function id="gtk_get_major_version" />
     <function id="gtk_get_minor_version" />
     <function id="gtk_get_micro_version" />
     <function id="gtk_get_binary_age" />
     <function id="gtk_get_interface_age" />
     <function id="gtk_check_version" />
     <function id="gtk_parse_args" bind="False" /> <!-- no access to argc argv -->x
     <function id="gtk_init" bind="False" /> <!--  custom -->
     <function id="gtk_init_check" bind="False" /> <!-- custom -->
     <function id="gtk_init_with_args" bind="False" />
     <function id="gtk_disable_setlocale"/>
     <function id="gtk_get_default_language"/>
     <function id="gtk_events_pending"/>
     <function id="gtk_main_do_event"/>
     <function id="gtk_main"/>
     <function id="gtk_main_level"/>
     <function id="gtk_main_quit"/>
     <function id="gtk_main_iteration" />
     <function id="gtk_main_iteration_do"/>
     <function id="gtk_true" />
     <function id="gtk_false" />
     <function id="gtk_grab_add" bind="False" />  <!--  in GtkWidget -->
     <function id="gtk_grab_get_current" />
     <function id="gtk_grab_remove" bind="False"/>  <!--  in GtkWidget -->
     <function id="gtk_device_grab_add" />
     <function id="gtk_device_grab_remove" />
     <function id="gtk_key_snooper_install" />
     <function id="gtk_key_snooper_remove" />
     <function id="gtk_get_current_event" />
     <function id="gtk_get_current_event_time" />
     <function id="gtk_get_current_event_state"
               return_as_param="Has_Current_Event">
       <parameter name="state" direction="out" />
     </function>
     <function id="gtk_get_current_event_device" />
     <function id="gtk_get_event_widget" />
     <function id="gtk_propagate_event" />

     <extra>
       <spec>
   procedure Init;
   --  Initialize GtkAda's internal structures.
   --  This subprogram should be called before any other one in GtkAda.
   --  If GtkAda could not be initialized (no access to the display, etc.), the
   --  application exits with an error

   function Init_Check return Boolean;
   --  Initialize GtkAda's internal structures.
   --  Return False if there was an error (no access to the display, etc.)
       </spec>
       <body>
   gnat_argc : Interfaces.C.int;
   pragma Import (C, gnat_argc);

   gnat_argv : System.Address;
   pragma Import (C, gnat_argv);

   procedure Init is
      procedure Internal (argc : System.Address; argv : System.Address);
      pragma Import (C, Internal, "gtk_init");

   begin
      Internal (gnat_argc'Address, gnat_argv'Address);
   end Init;

   function Init_Check return Boolean is
      function Internal
        (argc : System.Address; argv : System.Address) return Gboolean;
      pragma Import (C, Internal, "gtk_init_check");
   begin
      return Boolean'Val (Internal (gnat_argc'Address, gnat_argv'Address));
   end Init_Check;
       </body>
     </extra>
   </package>

   <package id="GdkCursor" bindtype="False">
     <enum ctype="GdkCursorType" prefix="GDK_"/>

     <method id="gdk_cursor_new_from_pixbuf" bind="False" />  <!--  in gdk.pixbuf -->
     <method id="gdk_cursor_get_image" bind="False" />  <!--  in gdk.pixbuf -->

     <method id="gdk_cursor_unref" bind="False" />  <!--  obsolete -->
     <method id="gdk_cursor_ref" bind="False" />  <!--  obsolete -->
     <extra>
       <spec>
   procedure Ref (Self : Gdk.Gdk_Cursor);
   pragma Import (C, Ref, "g_object_ref");

   procedure Unref (Self : Gdk.Gdk_Cursor);
   pragma Import (C, Unref, "g_object_unref");
       </spec>
     </extra>
   </package>

   <package id="GtkTextAttributes">
     <parameter name="self" ada="Text_Attr"/>
     <record ctype="GtkTextAppearance"/>

   </package>

   <package id="GtkTextTagTable">
     <parameter name="self" ada="Table"/>
   </package>

   <package id="GtkTextView">
     <parameter name="self" ada="View"/>

     <!-- These are now inherited from the Scrollable interface -->
     <method id="gtk_text_view_get_hadjustment" bind="false"/>
     <method id="gtk_text_view_get_vadjustment" bind="false"/>
     <method id="gtk_text_view_set_hadjustment" bind="false"/>
     <method id="gtk_text_view_set_vadjustment" bind="false"/>

     <method id="gtk_text_view_new_with_buffer" ada="Gtk_New"/>
   </package>

   <package id="GdkWindow" bindtype="False">
     <record ctype="GdkGeometry"/>
     <enum ctype="GdkWindowWindowClass" prefix="GDK_" ada="Gdk_Window_Class"/>
     <enum ctype="GdkWindowEdge" prefix="GDK_"/>
     <enum ctype="GdkWindowType" prefix="GDK_"/>
     <enum ctype="GdkWindowAttributesType" prefix="GDK_"/>
     <enum ctype="GdkWindowHints" prefix="GDK_"/>
     <enum ctype="GdkWindowTypeHint" prefix="GDK_"/>
     <enum ctype="GdkWMDecoration" prefix="GDK_"/>
     <enum ctype="GdkWMFunction" prefix="GDK_"/>
     <enum ctype="GdkGravity" prefix="GDK_"/>
     <enum ctype="GdkFullscreenMode" prefix="GDK_FULLSCREEN_" />
     <list ada="Gdk_Window_List" ctype="GdkWindow"/>
     <method id="::pick-embedded-child" bind="False" />
     <method id="::from-embedder" bind="False" />
     <method id="::to-embedder" bind="False" />
     <method id="::create-surface" bind="False" />
     <method id="gdk_window_add_filter" bind="False" />   <!-- dangerous -->
     <method id="gdk_window_remove_filter" bind="False" />   <!-- dangerous -->
     <method id="gdk_window_get_children" return="GdkWindowList"/>
     <method id="gdk_window_get_decorations" return_as_param="Has_Decorations"/>
     <method id="gdk_window_get_device_position" return_as_param="Window"/>
     <method id="gdk_window_get_origin" return="void"/>
     <method id="gdk_window_get_pointer" return_as_param="Window"/>
     <method id="gdk_window_peek_children" return="GdkWindowList" />
     <method id="gdk_window_at_pointer" return_as_param="Window"/>

<!--     <method id="gdk_window_get_events" bind="False" /> <!- circular dep with GdkEvent -->
<!--     <method id="gdk_window_set_events" bind="False" /> <!- circular dep with GdkEvent -->
<!--     <method id="gdk_window_get_device_events" bind="False" /> <!- circular dep with GdkEvent -->
<!--     <method id="gdk_window_set_device_events" bind="False" /> <!- circular dep with GdkEvent -->
<!--     <method id="gdk_window_get_source_events" bind="False" /> <!- circular dep with GdkEvent -->
<!--     <method id="gdk_window_set_source_events" bind="False" /> <!- circular dep with GdkEvent -->

     <method id="gdk_window_set_icon_list" bind="False"/> <!--  needs PixbufList -->
     <method id="gdk_window_get_drag_protocol" return_as_param="Protocol" bind="False"/> <!--  circular dep with GdkDragContent -->

     <method id="gdk_window_get_user_data" bind="False"/>  <!-- see below -->

     <extra>
       <spec>
   function Get_User_Data (Window : Gdk_Window) return Glib.Object.GObject;
   --  Return the widget to which events are reported when they happen on
   --  Window. This is the widget that was set through the call to
   --  Set_User_data.

   procedure Set_User_Data
     (Window : Gdk_Window;
      Widget : access Glib.Object.GObject_Record'Class);
   --  Sets a special field in the window.
   --  All the events reported by the Xserver (or the Windows server) for
   --  Window will be redirected to Widget through the standard signals
   --  "expose_event", "button_press_event", ...
   --  You almost always need to call this function after creating a new
   --  Gdk_Window yourself, or you won't be able to handle the events.

   procedure Ref (Window : Gdk_Window);
   procedure Unref (Window : Gdk_Window);
   pragma Import (C, Ref, "g_object_ref");
   pragma Import (C, Unref, "g_object_unref");
       </spec>
       <body>
   function Get_User_Data (Window : Gdk_Window) return Glib.Object.GObject is
      procedure Internal (Window : Gdk_Window; Widget : System.Address);
      pragma Import (C, Internal, "gdk_window_get_user_data");
      Data : aliased System.Address;
      Stub : GObject_Record;
   begin
      Internal (Window, Data'Address);
      return Get_User_Data (Data, Stub);
   end Get_User_Data;

   procedure Set_User_Data
     (Window : Gdk_Window;
      Widget : access Glib.Object.GObject_Record'Class)
   is
      procedure Internal (Window : Gdk_Window; Widget : System.Address);
      pragma Import (C, Internal, "gdk_window_set_user_data");
   begin
      Internal (Window, Get_Object (Widget));
   end Set_User_Data;
       </body>
     </extra>
   </package>

   <package id="GtkIconView">
     <parameter name="self" ada="Icon_View"/>
     <enum ctype="GtkIconViewDropPosition" prefix="GTK_ICON_VIEW_"/>
     <method id="gtk_icon_view_get_cursor" return_as_param="Cursor_Is_Set"/>
     <method id="gtk_icon_view_get_dest_item_at_pos" return_as_param="Has_Item"/>
     <method id="gtk_icon_view_get_item_at_pos" return_as_param="Has_Item"/>
     <method id="gtk_icon_view_get_selected_items" return="TreePathList"/>
     <method id="gtk_icon_view_get_tooltip_context" return_as_param="Success"/>
     <method id="gtk_icon_view_get_visible_range" return="void"/>

     <method id="gtk_icon_view_enable_model_drag_source" bind="False"/> <!-- see below -->
     <method id="gtk_icon_view_enable_model_drag_dest" bind="False"/> <!-- see below -->
     <extra>
       <with_spec pkg="Gtk.Target_List"/>
       <with_spec pkg="Gdk.Dnd"/>
       <with_spec pkg="Gdk.Types"/>
       <spec>
   procedure Enable_Model_Drag_Dest
     (Icon_View : access Gtk_Icon_View_Record;
      Targets   : Gtk.Target_List.Target_Entry_Array;
      Actions   : Gdk.Dnd.Drag_Action);
   --  Turns Icon_view into a drop destination for automatic DND.
   --  Targets is the list of targets that the drag will support.

   procedure Enable_Model_Drag_Source
     (Icon_View         : access Gtk_Icon_View_Record;
      Start_Button_Mask : Gdk.Types.Gdk_Modifier_Type;
      Targets           : Gtk.Target_List.Target_Entry_Array;
      Actions           : Gdk.Dnd.Drag_Action);
   --  Turns Icon_view into a drag source for automatic DND.
   --  Start_Button_Mask is the allowed buttons to start drag.
       </spec>
       <body>
   procedure Enable_Model_Drag_Dest
     (Icon_View : access Gtk_Icon_View_Record;
      Targets   : Target_Entry_Array;
      Actions   : Drag_Action)
   is
      procedure Internal
        (Icon_View : System.Address;
         Targets   : System.Address;
         N_Targets : Gint;
         Actions   : Drag_Action);
      pragma Import (C, Internal, "gtk_icon_view_enable_model_drag_dest");
   begin
      Internal (Get_Object (Icon_View),
                Targets (Targets'First)'Address, Targets'Length,
                Actions);
   end Enable_Model_Drag_Dest;

   procedure Enable_Model_Drag_Source
     (Icon_View         : access Gtk_Icon_View_Record;
      Start_Button_Mask : Gdk_Modifier_Type;
      Targets           : Target_Entry_Array;
      Actions           : Drag_Action)
   is
      procedure Internal
        (Icon_View         : System.Address;
         Start_Button_Mask : Gdk_Modifier_Type;
         Targets           : System.Address;
         N_Targets         : Gint;
         Actions           : Drag_Action);
      pragma Import (C, Internal, "gtk_icon_view_enable_model_drag_source");
   begin
      Internal (Get_Object (Icon_View), Start_Button_Mask,
                Targets (Targets'First)'Address, Targets'Length,
                Actions);
   end Enable_Model_Drag_Source;
       </body>
     </extra>
   </package>

   <package id="GdkEvent">
     <enum ctype="GdkEventType" prefix="GDK_" ignore="GDK_DOUBLE_BUTTON_PRESS GDK_TRIPLE_BUTTON_PRESS"/>
     <enum ctype="GdkEventMask" prefix="GDK_"/>
     <enum ctype="GdkVisibilityState" prefix="GDK_"/>
     <enum ctype="GdkScrollDirection" prefix="GDK_"/>
     <enum ctype="GdkNotifyType" prefix="GDK_"/>
     <enum ctype="GdkCrossingMode" prefix="GDK_"/>
     <enum ctype="GdkPropertyState" prefix="GDK_"/>
     <enum ctype="GdkWindowState" prefix="GDK_"/>
     <enum ctype="GdkSettingAction" prefix="GDK_"/>
     <enum ctype="GdkOwnerChange" prefix="GDK_"/>
     <record ctype="GdkEventAny"/>
     <record ctype="GdkEventButton"/>
     <record ctype="GdkEventExpose"/>
     <record ctype="GdkEventVisibility"/>
     <record ctype="GdkEventMotion"/>
     <record ctype="GdkEventScroll"/>
     <record ctype="GdkEventKey"/>
     <record ctype="GdkEventCrossing"/>
     <record ctype="GdkEventFocus"/>
     <record ctype="GdkEventConfigure"/>
     <record ctype="GdkEventProperty"/>
     <record ctype="GdkEventSelection"/>
     <record ctype="GdkEventOwnerChange"/>
     <record ctype="GdkEventProximity"/>
     <record ctype="GdkEventDND"/>
     <record ctype="GdkEventWindowState"/>
     <record ctype="GdkEventSetting"/>
     <record ctype="GdkEventTouch"/>
     <record ctype="GdkEventSequence"/>
     <record ctype="GdkEventGrabBroken"/>

     <record ctype="GdkEvent" ada="Gdk_Event_Record">
       <union value="GDK_NOTHING" field="any"/>
       <union value="GDK_DELETE" field="any"/>
       <union value="GDK_DESTROY" field="any" />
       <union value="GDK_EXPOSE" field="expose" />
       <union value="GDK_MOTION_NOTIFY" field="motion" />
       <union value="GDK_BUTTON_PRESS" field="button" />
       <union value="GDK_2BUTTON_PRESS" field="button" />
       <union value="GDK_3BUTTON_PRESS" field="button" />
       <union value="GDK_BUTTON_RELEASE" field="button" />
       <union value="GDK_KEY_PRESS" field="key" />
       <union value="GDK_KEY_RELEASE" field="key" />
       <union value="GDK_ENTER_NOTIFY" field="crossing" />
       <union value="GDK_LEAVE_NOTIFY" field="crossing" />
       <union value="GDK_FOCUS_CHANGE" field="focus_change" />
       <union value="GDK_CONFIGURE" field="configure" />
       <union value="GDK_MAP" field="any" />
       <union value="GDK_UNMAP" field="any" />
       <union value="GDK_PROPERTY_NOTIFY" field="property" />
       <union value="GDK_SELECTION_CLEAR" field="selection" />
       <union value="GDK_SELECTION_REQUEST" field="selection" />
       <union value="GDK_SELECTION_NOTIFY" field="selection" />
       <union value="GDK_PROXIMITY_IN" field="proximity" />
       <union value="GDK_PROXIMITY_OUT" field="proximity" />
       <union value="GDK_DRAG_ENTER" field="dnd" />
       <union value="GDK_DRAG_LEAVE" field="dnd" />
       <union value="GDK_DRAG_MOTION" field="dnd" />
       <union value="GDK_DRAG_STATUS" field="dnd" />
       <union value="GDK_DROP_START" field="dnd" />
       <union value="GDK_DROP_FINISHED" field="dnd" />
       <union value="GDK_CLIENT_EVENT" field="any" />
       <union value="GDK_VISIBILITY_NOTIFY" field="visibility" />
       <union value="GDK_SCROLL" field="scroll" />
       <union value="GDK_WINDOW_STATE" field="window_state" />
       <union value="GDK_SETTING" field="setting" />
       <union value="GDK_OWNER_CHANGE" field="owner_change" />
       <union value="GDK_GRAB_BROKEN" field="grab_broken" />
       <union value="GDK_DAMAGE" field="expose" />
       <union value="GDK_TOUCH_BEGIN" field="touch" />
       <union value="GDK_TOUCH_UPDATE" field="touch" />
       <union value="GDK_TOUCH_END" field="touch" />
       <union value="GDK_TOUCH_CANCEL" field="touch" />
     </record>

     <method id="gdk_event_get_coords" return="void"/>
     <method id="gdk_event_get_root_coords" return="void"/>
     <method id="gdk_event_get_axis" return="void"/>
     <method id="gdk_event_get_scroll_direction" return="void"/>
     <method id="gdk_event_get_scroll_deltas" return="void"/>

     <!--  These are getters provided by gtk+ itself. They are reused from our
           own misc.c file, because we want GtkAda to raise exceptions instead.
           See <extra> below
     -->
     <method id="gdk_event_get_button" bind="False"/>
     <method id="gdk_event_get_state" bind="False"/>
     <method id="gdk_event_get_click_count" bind="False"/>
     <method id="gdk_event_get_keyval" bind="False"/>
     <method id="gdk_event_get_keycode" bind="False"/>

     <!--  Avoid circular dependencies  Event->Device->Display->Event -->
     <method id="gdk_event_get_device" bind="False"/>
     <method id="gdk_event_get_source_device" bind="False"/>
     <method id="gdk_event_set_device" bind="False"/>
     <method id="gdk_event_set_source_device" bind="False"/>
     <method id="gdk_event_get_screen" bind="False"/>
     <method id="gdk_event_set_screen" bind="False"/>

     <function id="gdk_events_pending" ada="Events_Pending"/>
     <method id="gdk_events_get_angle" ada="Get_Angle"/>
     <method id="gdk_events_get_center" ada="Get_Center"/>
     <method id="gdk_events_get_distance" ada="Get_Distance"/>
     <function id="gdk_set_show_events" ada="Set_Show_Events"/>
     <function id="gdk_get_show_events" ada="Get_Show_Events"/>

     <extra>
       <gir:method name="Get_Button" c:identifier="ada_gdk_event_get_button">
         <gir:doc>Extract the button number from an event</gir:doc>
         <gir:return-value><gir:type name="guint" c:type="guint"/></gir:return-value>
       </gir:method>
       <gir:method name="Get_State" c:identifier="ada_gdk_event_get_state">
         <gir:doc>State of the mouse buttons and keyboard keys just prior to the event</gir:doc>
         <gir:return-value><gir:type name="GdkModifierType" c:type="GdkModifierType"/></gir:return-value>
       </gir:method>
       <gir:method name="Get_Key_Val" c:identifier="ada_gdk_event_get_keyval">
         <gir:doc>Code of the key that was pressed (and that generated the event)</gir:doc>
         <gir:return-value><gir:type name="GdkKeyType" c:type="GdkKeyType"/></gir:return-value>
       </gir:method>
       <gir:method name="Get_Keycode" c:identifier="ada_gdk_event_get_keycode">
         <gir:doc>Hardware key code of the key that was pressed</gir:doc>
         <gir:return-value><gir:type name="guint" c:type="guint"/></gir:return-value>
       </gir:method>
       <gir:method name="Get_Event_Type" c:identifier="ada_gdk_event_get_event_type">
         <gir:doc>The type of the event</gir:doc>
         <gir:return-value><gir:type name="GdkEventType" c:type="GdkEventType"/></gir:return-value>
       </gir:method>
       <gir:method name="Get_Window" c:identifier="ada_gdk_event_get_window">
         <gir:doc>The window to which the event was sent</gir:doc>
         <gir:return-value><gir:type name="GdkWindow*" c:type="GdkWindow*"/></gir:return-value>
       </gir:method>

       <type ctype="GdkEvent*" ada="Gdk_Event">
         type Gdk_Event is access all Gdk_Event_Record;
         pragma No_Strict_Aliasing (Gdk_Event);
       </type>
       <with_spec pkg="Glib.Values" />
       <spec>
         Double_Button_Press : constant Gdk_Event_Type := Gdk_2button_Press;
         Triple_Button_Press : constant Gdk_Event_Type := Gdk_3button_Press;

         function From_Address (C : System.Address) return Gdk_Event;
         --  Convert a C handler to the matching Event structure.

         function To_Address (C : Gdk_Event) return System.Address;
         --  Convert an event to the underlying C handler.

         function Get_Event (Value : Glib.Values.GValue) return Gdk_Event;
         --  Convert a value into a Gdk_Event.

         function To_Event (Event : access Gdk_Event_Button) return Gdk_Event;
         function To_Event (Event : access Gdk_Event_Key) return Gdk_Event;
         --  Cast Event into a Gdk_Event, which can be used to call some of
         --  subprograms in the API. The return value is a pointer to Event,
         --  which should therefore remain valid as long as the pointer is in
         --  use.

   -------------------------------
   -- Some constants used below --
   -------------------------------
   --  This constants have the '-1' since in some cases gtk itself uses
   --  the extrema to return some meaningful value (for instance, the result
   --  of Get_Area can have the values Guint16'Last to mean the whole area).

   Invalid_Gdouble_Value : constant Gdouble := Gdouble'Last - 1.0;
   Invalid_Gint_Value    : constant Gint    := Gint'Last - 1;
   Invalid_Guint_Value   : constant Guint   := Guint'Last - 1;
   Invalid_Guint32_Value : constant Guint32 := Guint32'Last - 1;
   Invalid_Gulong_Value  : constant Gulong  := Gulong'Last - 1;

   pragma Export (C, Invalid_Gdouble_Value, "ada_gdk_invalid_gdouble_value");
   pragma Export (C, Invalid_Gint_Value, "ada_gdk_invalid_gint_value");
   pragma Export (C, Invalid_Guint_Value, "ada_gdk_invalid_guint_value");
   pragma Export (C, Invalid_Guint32_Value, "ada_gdk_invalid_guint32_value");
   pragma Export (C, Invalid_Gulong_Value, "ada_gdk_invalid_gulong_value");
       </spec>
       <body>
   function From_Address (C : System.Address) return Gdk_Event is
      function Convert is new Ada.Unchecked_Conversion
           (Glib.C_Proxy, Gdk_Event);
   begin
      return Convert (Glib.C_Proxy'(Glib.To_Proxy (C)));
   end From_Address;

   function To_Address (C : Gdk_Event) return System.Address is
      function Convert is new Ada.Unchecked_Conversion
           (Gdk_Event, Glib.C_Proxy);
   begin
      return Glib.To_Address (Convert (C));
   end To_Address;

   function Get_Event (Value : Glib.Values.GValue) return Gdk_Event is
      function Convert is new Ada.Unchecked_Conversion
           (Glib.C_Proxy, Gdk_Event);
   begin
      return Convert (Glib.Values.Get_Proxy (Value));
   end Get_Event;

   function To_Event (Event : access Gdk_Event_Button) return Gdk_Event is
      type Gdk_Event_Button_Access is access all Gdk_Event_Button;
      function Convert is new Ada.Unchecked_Conversion
           (Gdk_Event_Button_Access, Gdk_Event);
   begin
      return Convert (Gdk_Event_Button_Access (Event));
   end To_Event;

   function To_Event (Event : access Gdk_Event_Key) return Gdk_Event is
      type Gdk_Event_Key_Access is access all Gdk_Event_Key;
      function Convert is new Ada.Unchecked_Conversion
         (Gdk_Event_Key_Access, Gdk_Event);
   begin
      return Convert (Gdk_Event_Key_Access (Event));
   end To_Event;
       </body>
     </extra>

     <doc group="Gdk, the low-level API"/>
     <parameter name="self" ada="Event"/>
   </package>

   <package id="GtkRadioToolButton">
     <method id="gtk_radio_tool_button_new">
       <parameter name="group" ctype="WidgetSList"/>
     </method>
     <method id="gtk_radio_tool_button_new_from_stock">
       <parameter name="group" ctype="WidgetSList"/>
     </method>
     <method id="gtk_radio_tool_button_set_group">
       <parameter name="group" ctype="WidgetSList"/>
     </method>
     <method id="gtk_radio_tool_button_get_group" return="WidgetSList"/>
     <method id="gtk_radio_tool_button_new_from_widget" bind="False"/> <!-- gir file misses Group parameter-->
     <method id="gtk_radio_tool_button_new_with_stock_from_widget" bind="False"/> <!-- gir file misses Group parameter-->
   </package>

   <package id="GtkSelectionData">
     <parameter name="self" ada="Selection"/>

     <method id="gtk_selection_data_targets_include_rich_text" bind="False"/> <!-- circular dependency on gtk.text_buffer -->
     <method id="gtk_selection_data_get_data_with_length" bind="False"/> <!-- not convenient, has an access gint and returns an array -->
     <method id="gtk_selection_data_set" bind="False"/> <!-- manual binding below -->
     <method id="gtk_selection_data_get_targets" bind="False"/> <!-- manual binding below -->

     <method id="gtk_selection_data_get_data" return="System.Address"/>

     <extra>
        <spec>
   ---------------
   -- Selection --
   ---------------

   function Make_Atom (Num : Gulong) return Gdk.Types.Gdk_Atom;
   pragma Import (C, Make_Atom, "ada_make_atom");
   --  Auxiliary subprogram

   subtype Gdk_Selection is Gdk.Types.Gdk_Atom;
   --  These are predefined atom values for several common selections.
   --  You are of course free to create new ones, but most of the time you
   --  should simply use Selection_Primary unless you foresee the need for
   --  multiple simultaneous selections.
   --  To access the clipboard on windows machines, you might need to create
   --  a new selection with Gdk.Property.Atom_Intern ("CLIPBOARD");

   Selection_Primary   : constant Gdk_Selection := Make_Atom (1);
   Selection_Secondary : constant Gdk_Selection := Make_Atom (2);

   procedure Selection_Data_Set
     (Selection : Gtk_Selection_Data;
      The_Type  : Gdk.Types.Gdk_Atom;
      Format    : Gint;
      Data      : System.Address;
      Length    : Gint);
   --  General form of Selection_Data_Set.
   --  Any data can be transmitted. Length is the number of bytes in Data.

   procedure Selection_Data_Set
     (Selection : Gtk_Selection_Data;
      The_Type  : Gdk.Types.Gdk_Atom;
      Format    : Gint;
      Data      : String);
   --  Set the data for a selection (special case for strings)
   --  This function is generally called when a drag-and-drop operation
   --  ask the source widget for the data to be transmitted. In that case,
   --  a Selection_Data was already transmitted and is given as a handler
   --  parameter for the signal "drag_data_get". The_Type can simply be
   --  extracted from the Selection_Data.

   function Get_Targets
     (Selection : Gtk_Selection_Data) return Gdk.Types.Gdk_Atom_Array;
   --  Gets the contents of Selection_Data as an array of targets.
   --  This can be used to interpret the results of getting
   --  the standard TARGETS target that is always supplied for
   --  any selection.
   --  This is different from Get_Target, which indicate the current format
   --  that the selection contains. Get_Targets only applies when Get_Target
   --  is "TARGETS".

   function Get_Data_As_String (Selection : Gtk_Selection_Data) return String;
   --  Return the data as a string.
   --  This is only a convenience function, since it simply creates a string
   --  from the return of Get_Data.
        </spec>

        <with_body pkg="Gtkada.C" />
        <body>
   package Atom_Arrays is new Gtkada.C.Unbounded_Arrays
     (Gdk.Types.Gdk_Atom, Gdk.Types.Gdk_None,
      Natural, Gdk.Types.Gdk_Atom_Array);

   ------------------------
   -- Selection_Data_Set --
   ------------------------

   procedure Selection_Data_Set
     (Selection : Gtk_Selection_Data;
      The_Type  : Gdk.Types.Gdk_Atom;
      Format    : Gint;
      Data      : System.Address;
      Length    : Gint)
   is
      procedure Internal
        (Selection : System.Address;
         The_Type  : Gdk.Types.Gdk_Atom;
         Format    : Gint;
         Data      : System.Address;
         Length    : Gint);
      pragma Import (C, Internal, "gtk_selection_data_set");

   begin
      Internal (Get_Object (Selection), The_Type, Format, Data, Length);
   end Selection_Data_Set;

   procedure Selection_Data_Set
     (Selection : Gtk_Selection_Data;
      The_Type  : Gdk.Types.Gdk_Atom;
      Format    : Gint;
      Data      : String) is
   begin
      Selection_Data_Set
        (Selection, The_Type, Format, Data'Address, Data'Length);
   end Selection_Data_Set;

   -----------------
   -- Get_Targets --
   -----------------

   function Get_Targets
     (Selection : Gtk_Selection_Data) return Gdk.Types.Gdk_Atom_Array
   is
      use Atom_Arrays;
      function Internal
        (Selection : System.Address;
         Targets   : access Unbounded_Array_Access;
         N_Atoms   : access Gint) return Gboolean;
      pragma Import (C, Internal, "gtk_selection_data_get_targets");

      Output    : aliased Unbounded_Array_Access;
      N         : aliased Gint;
   begin
      if Internal
         (Get_Object (Selection),
          Output'Unchecked_Access,
          N'Unchecked_Access) = 0
      then
         Output := null;
      end if;

      declare
         Result : constant Gdk_Atom_Array := To_Array (Output, Integer (N));
      begin
         G_Free (Output);
         return Result;
      end;
   end Get_Targets;

   ------------------------
   -- Get_Data_As_String --
   ------------------------

   function Get_Data_As_String
     (Selection : Gtk_Selection_Data) return String
   is
      function Internal
        (Selection : System.Address) return Interfaces.C.Strings.chars_ptr;
      pragma Import (C, Internal, "gtk_selection_data_get_data");
   begin
      return Interfaces.C.Strings.Value (Internal (Get_Object (Selection)));
   end Get_Data_As_String;
        </body>
     </extra>
   </package>


   <package id="GtkTargetEntry">
     <parameter name="self" ada="Target_Entry"/>

     <record ctype="GtkTargetEntry">
       <field name="flags" ctype="GtkTargetFlags"/>
     </record>

     <method id="gtk_target_entry_copy" bind="False"/> <!-- requires From_Object -->

     <method id="gtk_target_entry_new">
        <parameter name="Flags" ctype="GtkTargetFlags"/>
     </method>
   </package>

   <package id="GtkTargetList">
     <parameter name="self" ada="List"/>
     <enum ctype="GtkAccelFlags" prefix="GTK_"/>

     <method id="gtk_target_list_add_rich_text_targets" bind="False"/> <!-- circular dependency clipboard, text_buffer -->

     <method id="gtk_target_list_new" bind="False"/> <!-- manual binding below -->
     <method id="gtk_target_list_add_table" bind="False"/> <!-- manual binding below -->

     <method id="gtk_target_list_find"
         return_as_param="Found" />

     <extra>
       <with_spec pkg="Gtk.Target_Entry" />
       <spec>
   type Target_Entry_Array is array (Natural range &lt;&gt;) of Gtk_Target_Entry;

   Any_Target_Entry : Target_Entry_Array (1 .. 0);
   --  To be used for drop sites that accept any kind of data.

   procedure Gtk_New
      (List   : out Gtk_Target_List;
      Targets : Target_Entry_Array);
   --  Creates a new Gtk.Target_List.Gtk_Target_List from an array of
   --  Gtk.Target_Entry.Gtk_Target_Entry.

   procedure Add_Table
      (List    : Gtk_Target_List;
       Targets : Target_Entry_Array);
   --  Prepends a table of Gtk.Target_Entry.Gtk_Target_Entry to a target list.
       </spec>
       <body>
   -------------
   -- Gtk_New --
   -------------

   procedure Gtk_New
      (List   : out Gtk_Target_List;
       Targets : Target_Entry_Array)
   is
      function Internal
         (Targets  : System.Address;
          Ntargets : Guint) return System.Address;
      pragma Import (C, Internal, "gtk_target_list_new");
   begin
      List.Set_Object (Internal (Targets'Address, Targets'Length));
   end Gtk_New;

   ---------------
   -- Add_Table --
   ---------------

   procedure Add_Table
      (List    : Gtk_Target_List;
       Targets : Target_Entry_Array)
   is
      procedure Internal
         (List     : System.Address;
          Targets  : System.Address;
          Ntargets : Guint);
      pragma Import (C, Internal, "gtk_target_list_add_table");
   begin
      Internal (Get_Object (List), Targets'Address, Targets'Length);
   end Add_Table;
       </body>
     </extra>
   </package>

   <package id="GtkTooltip"/>

   <package id="GtkRadioMenuItem">
     <parameter name="self" ada="Radio_Menu_Item" />

     <!-- Merge two Gtk_New together -->
     <method id="gtk_radio_menu_item_new" bind="False"/>
     <method id="gtk_radio_menu_item_new_with_label" ada="Gtk_New" >
       <parameter name="label" default='""' allow-none="0"/>
       <parameter name="group" ctype="WidgetSList"/>
      </method>
     <method id="gtk_radio_menu_item_new_with_mnemonic" >
       <parameter name="group" ctype="WidgetSList"/>
      </method>
     <method id="gtk_radio_menu_item_set_group">
       <parameter name="group" ctype="WidgetSList"/>
     </method>
     <method id="gtk_radio_menu_item_get_group" return="WidgetSList"/>
     <method id="gtk_radio_menu_item_new_from_widget" bind="False"/> <!-- gir file misses Group parameter-->
     <method id="gtk_radio_menu_item_new_with_label_from_widget" bind="False"/> <!-- gir file misses Group parameter-->
     <method id="gtk_radio_menu_item_new_with_mnemonic_from_widget" bind="False"/> <!-- gir file misses Group parameter-->
     <extra>
       <spec>
   function Selected_Button (In_Group : Widget_SList.GSlist) return Natural;
   --  Return the button number of the selected button in the group.
   --  Note: This function is not part of Gtk+ itself, but is provided as a
   --  convenient function
       </spec>
       <body>
   function Selected_Button
     (In_Group : Widget_SList.GSlist) return Natural
   is
      use Widget_SList;
      J   : Natural := 0;
      Tmp : Widget_SList.GSlist := In_Group;
   begin
      while Tmp /= Widget_SList.Null_List loop
         exit when Get_Active (Gtk_Radio_Menu_Item (Get_Data (Tmp)));
         Tmp := Next (Tmp);
         J := J + 1;
      end loop;

      return J;
   end Selected_Button;
       </body>
     </extra>
   </package>

   <package id="GtkPrintContext">
     <parameter name="self" ada="Context"/>
   </package>

   <package id="PangoFontMetrics">
   </package>

   <package id="PangoFontset">
     <doc>an object containing a set of pango.Font objects</doc>
   </package>

   <package id="PangoLanguage">
     <enum ctype="PangoScript"/>
     <extra>
       <type ctype="Pango_Script_Array" ada="Pango_Script_Array">
         type Pango_Script_Array is array (Natural range &lt;&gt;) of Pango_Script;
       </type>
     </extra>

     <method id="pango_language_get_scripts" return="Pango_Script_Array">
       <parameter name="num_scripts" ada=""/>
       <body>
      type script_array_bounded is array (Natural) of Pango_Script;
      type script_array_access is access script_array_bounded;

      function Internal
         (Self     : System.Address;
          Size     : access Gint) return script_array_access;
      pragma Import (C, Internal, "pango_language_get_scripts");

      Scripts : script_array_access;
      Size : aliased Gint;
   begin
      Scripts := Internal (Self.Get_Object, Size'Access);

      declare
         Result : Pango_Script_Array (1 .. Integer (Size));
      begin
         for R in 0 .. Integer (Size) - 1 loop
             Result (R + 1) := Scripts (R);
         end loop;
         return Result;
      end;
       </body>
     </method>
   </package>

   <package id="PangoFontMap">
     <doc>An object that represents the set of fonts available for a particular
     rendering system</doc>

     <extra>
       <with_spec pkg="Pango.Font_Family"/>
     </extra>

     <method id="pango_font_map_list_families" return="Pango_Font_Family_Array">
       <parameter name="families" ada=""/>
       <parameter name="n_families" ada=""/>
       <body>
      type font_family_array_bounded is array (Natural) of System.Address;

      procedure Internal
         (Self     : System.Address;
          Families : System.Address;
          Size     : access Gint);
      pragma Import (C, Internal, "pango_font_map_list_families");

      procedure g_free (s : access font_family_array_bounded);
      pragma Import (C, g_free, "g_free");

      Families : aliased access font_family_array_bounded;
      Size : aliased Gint;
      Tmplt : Pango_Font_Family_Record;
   begin
      Internal (Self.Get_Object, Families'Address, Size'Access);

      declare
         Result : Pango_Font_Family_Array (1 .. Integer (Size));
      begin
         for R in 0 .. Integer (Size) - 1 loop
             Result (R + 1) := Pango_Font_Family
                (Get_User_Data (Families (R), Tmplt));
         end loop;
         g_free (Families);

         return Result;
      end;
       </body>
     </method>
   </package>

   <package id="PangoFontFamily">
     <extra>
       <with_spec pkg="Pango.Font_Face"/>

       <!--  Needed for PangoFontMap -->
       <type ctype="Pango_Font_Family_Array" ada="Pango_Font_Family_Array">
         type Pango_Font_Family_Array is array (Natural range &lt;&gt;) of Pango_Font_Family;
       </type>
     </extra>
     <method id="pango_font_family_list_faces" return="Pango_Font_Face_Array">
       <parameter name="faces" ada=""/>
       <parameter name="n_faces" ada=""/>
       <body>
      type font_face_array_bounded is array (Natural) of System.Address;

      procedure Internal
         (Self        : System.Address;
          Faces       : System.Address;
          Acc_N_Faces : access Gint);
      pragma Import (C, Internal, "pango_font_family_list_faces");

      procedure g_free (s : access font_face_array_bounded);
      pragma Import (C, g_free, "g_free");

      Faces : aliased access font_face_array_bounded;
      Size : aliased Gint;
      Tmplt : Pango_Font_Face_Record;
   begin
      Internal (Self.Get_Object, Faces'Address, Size'Access);

      declare
         Result : Pango_Font_Face_Array (1 .. Integer (Size));
      begin
         for R in 0 .. Integer (Size) - 1 loop
             Result (R + 1) := Pango_Font_Face
                (Get_User_Data (Faces (R), Tmplt));
         end loop;
         g_free (Faces);

         return Result;
      end;
       </body>
     </method>
   </package>

   <package id="PangoFontFace">
     <extra>
       <!--  Needed for PangoFontFamily -->
       <type ctype="Pango_Font_Face_Array" ada="Pango_Font_Face_Array">
         type Pango_Font_Face_Array is array (Natural range &lt;&gt;) of Pango_Font_Face;
       </type>
     </extra>
     <method id="pango_font_face_list_sizes" return="gint**">
       <parameter name="sizes" ada=""/>
       <parameter name="n_sizes" ada=""/>
       <body>
      type gint_array_bounded is array (Natural) of Gint;

      procedure Internal
         (Self        : System.Address;
          Sizes       : System.Address;
          Acc_N_Sizes : access Gint);
      pragma Import (C, Internal, "pango_font_face_list_sizes");

      procedure g_free (s : access gint_array_bounded);
      pragma Import (C, g_free, "g_free");

      Sizes : aliased access gint_array_bounded;
      Size : aliased Gint;
   begin
      Internal (Self.Get_Object, Sizes'Address, Size'Access);

      declare
         Result : Gint_Array (1 .. Integer (Size));
      begin
         for R in 0 .. Integer (Size) - 1 loop
             Result (R + 1) := Sizes (R);
         end loop;
         g_free (Sizes);

         return Result;
      end;
       </body>
     </method>
   </package>

   <package id="PangoLayout">
     <parameter name="self" ada="Layout"/>
     <enum ctype="PangoEllipsizeMode" prefix="PANGO_"/>
     <method id="pango_layout_xy_to_index" return_as_param="Exact">
       <parameter name="index" ada="Byte_Index" direction="out"/>
       <parameter name="trailing" direction="out"/>
     </method>

     <!-- Do not bind these, since they require a list of Pango_Layout_Line,
     which is incorrectly bound (error in From_Object) -->
     <method id="pango_layout_get_lines" return="PangoLayoutLineSList" bind="false"/>
     <method id="pango_layout_get_lines_readonly" bind="false"
             return="PangoLayoutLineSList"/>

     <method id="pango_layout_get_log_attrs" bind="false"/> <!--  what is a pango_log -->
     <method id="pango_layout_get_log_attrs_readonly" bind="false"/> <!--  what
     is a pango_log -->

     <method id="pango_layout_get_iter" classwide="true"/>

     <method id="pango_layout_set_attributes">
       <parameter name="attrs" direction="in" ctype="PangoAttrList"/>
     </method>

     <method id="pango_layout_set_text">
       <parameter name="length" default="-1" ada=""/>
     </method>
     <method id="pango_layout_set_markup">
       <parameter name="length" default="-1" ada=""/>
     </method>
     <extra>
       <with_spec pkg="Gtkada.Types" />
       <spec>
   function Get_Text (Layout : access Pango_Layout_Record)
      return Gtkada.Types.Chars_Ptr;
   --  Same a Get_Text, but return directly the C string, which is more
   --  efficient. The returned value should not be freed or modified.
       </spec>
       <body>
   function Get_Text (Layout : access Pango_Layout_Record)
      return Gtkada.Types.Chars_Ptr
   is
      function Internal (Layout : System.Address)
         return Interfaces.C.Strings.chars_ptr;
      pragma Import (C, Internal, "pango_layout_get_text");
   begin
      return Internal (Get_Object (Layout));
   end Get_Text;
       </body>
     </extra>
   </package>

   <package id="PangoLayoutLine" into="PangoLayout">
     <record ctype="PangoLayoutLine" private="true"/>

     <method id="pango_layout_line_get_type" ada="Get_Type_Layout_Line" />

     <method id="pango_layout_line_get_extents" bind="false"/> <!--  forces bad pragma import on pango_layout_get_extents -->
     <method id="pango_layout_line_get_pixel_extents" bind="false"/>
     <method id="pango_layout_line_ref" bind="false"/> <!--  Not needed in Ada -->
     <method id="pango_layout_line_unref" bind="false"/> <!--  Not needed in Ada -->

     <!--  Do not bind these for now, there is an error in the generator that
     tries to use Get_Object on a PangoLayoutLine because it doesn't know
     private records are implemented as C_Proxy -->
     <method id="pango_layout_line_get_x_ranges" bind="false"/>
     <method id="pango_layout_line_index_to_x" bind="false"/>
     <method id="pango_layout_line_x_to_index" bind="false"/>

   </package>

   <package id="PangoLayoutIter" into="PangoLayout">
     <method id="pango_layout_iter_get_type" ada="Get_Type_Layout_Iter" />

     <method id="pango_layout_iter_get_run" bind="false"/> <!--  what is a pango_run -->
     <method id="pango_layout_iter_get_run_readonly" bind="false"/> <!--  what is a pango_run -->
   </package>

   <package id="GtkPrintOperation">
     <enum ctype="GtkPrintStatus" prefix="GTK_PRINT_"/>
     <enum ctype="GtkPrintOperationResult" prefix="GTK_PRINT_OPERATION_"/>
     <enum ctype="GtkPrintOperationAction" prefix="GTK_PRINT_OPERATION_"/>
     <enum ctype="GtkPrintError" prefix="GTK_PRINT_"/>
   </package>

   <package id="GtkPrintOperationPreview">
     <parameter name="self" ada="Preview"/>
   </package>

   <package id="GtkAccelLabel">
     <parameter name="self" ada="Accel_Label"/>
   </package>

   <package id="GtkAccelMap">
     <method id="gtk_accel_map_load_scanner" bind="False"/> <!-- no binding for GScanner -->
     <method id="gtk_accel_map_add_entry">
       <parameter name="accel_key" ctype="GdkKeyType"/>
     </method>
     <method id="gtk_accel_map_change_entry">
       <parameter name="accel_key" ctype="GdkKeyType"/>
     </method>
     <method id="gtk_accel_map_lookup_entry" return_as_param="Found"/>
   </package>

   <package id="GtkActionGroup">
     <parameter name="self" ada="Action_Group"/>

     <list ada="Action_List" ctype="GtkAction"/>

     <method id="gtk_action_group_list_actions" return="GtkActionList"/>
     <method id="gtk_action_group_add_radio_actions" bind="False"/> <!-- see below -->
     <method id="gtk_action_group_add_radio_actions_full" bind="False"/> <!-- see below -->
     <method id="gtk_action_group_add_actions" bind="False"/> <!-- see below -->
     <method id="gtk_action_group_add_actions_full" bind="False"/> <!-- see below -->
     <method id="gtk_action_group_add_toggle_actions" bind="False"/> <!-- see below -->
     <method id="gtk_action_group_add_toggle_actions_full" bind="False"/> <!-- see below -->

     <extra>
       <with_spec pkg="Interfaces.C.Strings"/>
       <spec>
   type Action_Callback is access procedure
     (Action : System.Address; User_Data : System.Address);
   pragma Convention (C, Action_Callback);
   --  Profile of callbacks when an action is activated. You must convert
   --  Action to a Gtk_Action through:
   --      Act : constant Gtk_Action := Convert (Action);

   type Action_Entry is record
      Name         : Interfaces.C.Strings.chars_ptr;
      Stock_Id     : Interfaces.C.Strings.chars_ptr;
      Label        : Interfaces.C.Strings.chars_ptr;
      Accelerator  : Interfaces.C.Strings.chars_ptr;
      Tooltip      : Interfaces.C.Strings.chars_ptr;
      Callback     : Action_Callback;
   end record;
   pragma Convention (C, Action_Entry);

   type Radio_Action_Entry is record
      Name         : Interfaces.C.Strings.chars_ptr;
      Stock_Id     : Interfaces.C.Strings.chars_ptr;
      Label        : Interfaces.C.Strings.chars_ptr;
      Accelerator  : Interfaces.C.Strings.chars_ptr;
      Tooltip      : Interfaces.C.Strings.chars_ptr;
      Value        : Glib.Gint;
   end record;
   pragma Convention (C, Radio_Action_Entry);

   type Toggle_Action_Entry is record
      Name         : Interfaces.C.Strings.chars_ptr;
      Stock_Id     : Interfaces.C.Strings.chars_ptr;
      Label        : Interfaces.C.Strings.chars_ptr;
      Accelerator  : Interfaces.C.Strings.chars_ptr;
      Tooltip      : Interfaces.C.Strings.chars_ptr;
      Callback     : Action_Callback;
      Is_Active    : Glib.Gboolean;
   end record;
   pragma Convention (C, Toggle_Action_Entry);
   --  An opaque structure describing an action entry

   type Action_Entry_Array is array (Natural range &lt;&gt;) of Action_Entry;
   type Radio_Action_Entry_Array
     is array (Natural range &lt;&gt;) of Radio_Action_Entry;
   type Toggle_Action_Entry_Array
     is array (Natural range &lt;&gt;) of Toggle_Action_Entry;

   type Radio_Action_Callback is access procedure
     (Group     : access Gtk.Action.Gtk_Action_Record'Class;
      Current   : access Gtk.Action.Gtk_Action_Record'Class;
      User_Data : System.Address);
   --   Called when an element of the Gtk_Radio_Action group is selected

   function Create
     (Name        : String;
      Label       : String := "";
      Stock_Id    : String := "";
      Accelerator : String := "";
      Tooltip     : String := "";
      Callback    : Action_Callback := null) return Action_Entry;
   --  Create a new Action_Entry. The returned value must be freed by the
   --  caller.

   function Create
     (Name        : String;
      Label       : String := "";
      Stock_Id    : String := "";
      Accelerator : String := "";
      Tooltip     : String := "";
      Callback    : Action_Callback := null;
      Is_Active   : Boolean := True) return Toggle_Action_Entry;
   --  Create a new Action_Entry. The returned value must be freed by the
   --  caller. Is_Active is the initial state of the button.

   function Create
     (Name        : String;
      Label       : String;
      Stock_Id    : String := "";
      Accelerator : String := "";
      Tooltip     : String := "";
      Value       : Glib.Gint) return Radio_Action_Entry;
   --  Create a new Radio_Action_Entry. Value is the value set on the radio
   --  action (see Gtk.Radio_Action.Get_Current_Value)

   procedure Free (Action  : in out Action_Entry);
   procedure Free (Actions : in out Action_Entry_Array);
   procedure Free (Action  : in out Radio_Action_Entry);
   procedure Free (Actions : in out Radio_Action_Entry_Array);
   procedure Free (Action  : in out Toggle_Action_Entry);
   procedure Free (Actions : in out Toggle_Action_Entry_Array);
   --  Free Action and Actions

   procedure Add_Actions
     (Action_Group : access Gtk_Action_Group_Record;
      Entries      : Action_Entry_Array;
      User_Data    : System.Address := System.Null_Address;
      Destroy      : Glib.G_Destroy_Notify_Address := null);
   --  This is a convenience function to create a number of actions and add
   --  them to the action group.
   --  Destroy is called when User_Data is no longer needed.
   --
   --  The "activate" signals of the actions are connected to the callbacks in
   --  Entries, and their accel paths are set to
   --  &lt;Actions&gt;/group-name/action-name.

   procedure Add_Radio_Actions
     (Action_Group : access Gtk_Action_Group_Record;
      Entries      : Radio_Action_Entry_Array;
      Value        : Glib.Gint;
      On_Change    : Radio_Action_Callback;
      User_Data    : System.Address := System.Null_Address;
      Destroy      : Glib.G_Destroy_Notify_Address := null);
   --  This is a convenience routine to create a group of radio actions and
   --  add them to the action group.
   --
   --  The "changed" signal of the first radio action is connected to the
   --  On_Change callback and the accel paths of the actions are set to
   --    &lt;Actions&gt;/group-name/action-name
   --
   --  Value is the value of the action to activate initially, or -1 if no
   --  action should be activated.
   --  Destroy is called when User_Data is no longer necessary.

   procedure Add_Toggle_Actions
     (Action_Group : access Gtk_Action_Group_Record;
      Entries      : Toggle_Action_Entry_Array;
      User_Data    : System.Address := System.Null_Address;
      Destroy      : Glib.G_Destroy_Notify_Address := null);
   --  This is a convenience function to create a number of toggle actions and
   --  add them to the action group.
   --  The "activate" signals of the actions are connected to the callbacks and
   --  their accel paths are set to &lt;Actions&gt;/group-name/action-name.
   --  Destroy is called when User_Data is no longer necessary.
       </spec>
       <with_body pkg="Ada.Unchecked_Deallocation" use="False" />
       <body>
   procedure Local_Radio_Action_Callback
     (Group, Current, User_Data : System.Address);
   pragma Convention (C, Local_Radio_Action_Callback);
   --  Local proxy for Radio_Action_Callback

   procedure Local_Radio_Action_Destroy
     (Data : in out System.Address);
   pragma Convention (C, Local_Radio_Action_Destroy);
   --  Local proxy for the Destroy notify for Radio_Action

   type Local_Radio_Action_User_Data is record
      Callback  : Radio_Action_Callback;
      User_Data : System.Address;
      Destroy   : G_Destroy_Notify_Address;
   end record;
   type Local_Radio_Action_User_Data_Access is
     access Local_Radio_Action_User_Data;

   function Convert is new Ada.Unchecked_Conversion
     (System.Address, Local_Radio_Action_User_Data_Access);
   function Convert is new Ada.Unchecked_Conversion
     (Local_Radio_Action_User_Data_Access, System.Address);
   procedure Unchecked_Free is new Ada.Unchecked_Deallocation
     (Local_Radio_Action_User_Data, Local_Radio_Action_User_Data_Access);

   procedure Local_Radio_Action_Callback
     (Group, Current, User_Data : System.Address)
   is
      Data : constant Local_Radio_Action_User_Data_Access :=
        Convert (User_Data);
      Stub : Gtk_Action_Record;
      G : constant Gtk_Action := Gtk_Action (Get_User_Data (Group, Stub));
      C : constant Gtk_Action := Gtk_Action (Get_User_Data (Current, Stub));
   begin
      Data.Callback (G, C, Data.User_Data);
   end Local_Radio_Action_Callback;

   procedure Local_Radio_Action_Destroy
     (Data : in out System.Address)
   is
      D : Local_Radio_Action_User_Data_Access := Convert (Data);
   begin
      D.Destroy (D.User_Data);
      Unchecked_Free (D);
   end Local_Radio_Action_Destroy;

   function Create
     (Name        : String;
      Label       : String := "";
      Stock_Id    : String := "";
      Accelerator : String := "";
      Tooltip     : String := "";
      Callback    : Action_Callback := null) return Action_Entry is
   begin
      return (Name        => String_Or_Null (Name),
              Label       => String_Or_Null (Label),
              Stock_Id    => String_Or_Null (Stock_Id),
              Accelerator => String_Or_Null (Accelerator),
              Tooltip     => String_Or_Null (Tooltip),
              Callback    => Callback);
   end Create;

   function Create
     (Name        : String;
      Label       : String := "";
      Stock_Id    : String := "";
      Accelerator : String := "";
      Tooltip     : String := "";
      Callback    : Action_Callback := null;
      Is_Active   : Boolean := True) return Toggle_Action_Entry is
   begin
      return (Name        => String_Or_Null (Name),
              Label       => String_Or_Null (Label),
              Stock_Id    => String_Or_Null (Stock_Id),
              Accelerator => String_Or_Null (Accelerator),
              Tooltip     => String_Or_Null (Tooltip),
              Callback    => Callback,
              Is_Active   => Boolean'Pos (Is_Active));
   end Create;

   function Create
     (Name        : String;
      Label       : String;
      Stock_Id    : String := "";
      Accelerator : String := "";
      Tooltip     : String := "";
      Value       : Glib.Gint) return Radio_Action_Entry is
   begin
      return (Name        => String_Or_Null (Name),
              Label       => String_Or_Null (Label),
              Stock_Id    => String_Or_Null (Stock_Id),
              Accelerator => String_Or_Null (Accelerator),
              Tooltip     => String_Or_Null (Tooltip),
              Value       => Value);
   end Create;

   procedure Free (Action  : in out Action_Entry) is
   begin
      Free (Action.Name);
      Free (Action.Label);
      Free (Action.Stock_Id);
      Free (Action.Accelerator);
      Free (Action.Tooltip);
   end Free;

   procedure Free (Actions : in out Action_Entry_Array) is
   begin
      for A in Actions'Range loop
         Free (Actions (A));
      end loop;
   end Free;

   procedure Free (Action  : in out Radio_Action_Entry) is
   begin
      Free (Action.Name);
      Free (Action.Label);
      Free (Action.Stock_Id);
      Free (Action.Accelerator);
      Free (Action.Tooltip);
   end Free;

   procedure Free (Actions : in out Radio_Action_Entry_Array) is
   begin
      for A in Actions'Range loop
         Free (Actions (A));
      end loop;
   end Free;

   procedure Free (Action  : in out Toggle_Action_Entry) is
   begin
      Free (Action.Name);
      Free (Action.Label);
      Free (Action.Stock_Id);
      Free (Action.Accelerator);
      Free (Action.Tooltip);
   end Free;

   procedure Free (Actions : in out Toggle_Action_Entry_Array) is
   begin
      for A in Actions'Range loop
         Free (Actions (A));
      end loop;
   end Free;

   procedure Add_Actions
     (Action_Group : access Gtk_Action_Group_Record;
      Entries      : Action_Entry_Array;
      User_Data    : System.Address := System.Null_Address;
      Destroy      : Glib.G_Destroy_Notify_Address := null)
   is
      procedure Internal
        (Action_Group : System.Address;
         Entries      : System.Address;
         N_Entries    : Guint;
         User_Data    : System.Address;
         Destroy      : G_Destroy_Notify_Address);
      pragma Import (C, Internal, "gtk_action_group_add_actions_full");
   begin
      Internal (Get_Object (Action_Group),
                Entries (Entries'First)'Address,
                Entries'Length,
                User_Data, Destroy);
   end Add_Actions;

   procedure Add_Radio_Actions
     (Action_Group : access Gtk_Action_Group_Record;
      Entries      : Radio_Action_Entry_Array;
      Value        : Glib.Gint;
      On_Change    : Radio_Action_Callback;
      User_Data    : System.Address := System.Null_Address;
      Destroy      : Glib.G_Destroy_Notify_Address := null)
   is
      procedure Internal
        (Action_Group : System.Address;
         Entries      : System.Address;
         N_Entries    : Guint;
         Value        : Gint;
         On_Change    : System.Address;
         User_Data    : System.Address;
         Destroy      : System.Address);
      pragma Import (C, Internal, "gtk_action_group_add_radio_actions_full");
      Data : constant Local_Radio_Action_User_Data_Access :=
        new Local_Radio_Action_User_Data'
          (Callback  => On_Change,
           User_Data => User_Data,
           Destroy   => Destroy);
   begin
      Internal (Get_Object (Action_Group),
                Entries (Entries'First)'Address, Entries'Length,
                Value,
                Local_Radio_Action_Callback'Address,
                Convert (Data),
                Local_Radio_Action_Destroy'Address);
   end Add_Radio_Actions;

   procedure Add_Toggle_Actions
     (Action_Group : access Gtk_Action_Group_Record;
      Entries      : Toggle_Action_Entry_Array;
      User_Data    : System.Address := System.Null_Address;
      Destroy      : G_Destroy_Notify_Address := null)
   is
      procedure Internal
        (Action_Group : System.Address;
         Entries      : System.Address;
         N_Entries    : Guint;
         User_Data    : System.Address;
         Destroy      : G_Destroy_Notify_Address);
      pragma Import (C, Internal, "gtk_action_group_add_toggle_actions_full");
   begin
      Internal (Get_Object (Action_Group),
                Entries (Entries'First)'Address, Entries'Length, User_Data,
                Destroy);
   end Add_Toggle_Actions;
       </body>
     </extra>
   </package>

   <package id="GtkMessageDialog">
     <parameter name="self" ada="Dialog"/>
     <enum ctype="GtkMessageType" prefix="GTK_"/>
     <enum ctype="GtkButtonsType" prefix="GTK_"/>
     <method id="gtk_message_dialog_new">
       <parameter name="message_format" ada="message" default='""'/>
       <parameter name="varargs" ada="" ctype="gpointer" default="System.Null_Address"/>   <!--  remove varargs argument -->
     </method>
     <method id="gtk_message_dialog_new_with_markup">
       <parameter name="message_format" ada="message" default='""'/>
       <parameter name="varargs" ada="" ctype="gpointer" default="System.Null_Address"/>   <!--  remove varargs argument -->
     </method>
     <method id="gtk_message_dialog_format_secondary_markup">
       <parameter name="message_format" ada="message" default='""'/>
       <parameter name="varargs" ada="" ctype="gpointer" default="System.Null_Address"/>   <!--  remove varargs argument -->
     </method>
   </package>

   <package id="GtkPrintSettings">
     <method id="gtk_print_settings_set_page_ranges">
       <parameter name="page_ranges" type="Gtk_Page_Range_Array"/>
       <parameter name="num_ranges" ada="" default="-1" />
       <body>
      procedure Internal
        (Settings    : System.Address;
         Page_Ranges : System.Address;
         Num_Ranges  : Gint);
      pragma Import (C, Internal, "gtk_print_settings_set_page_ranges");
   begin
      Internal
        (Get_Object (Self),
         Page_Ranges (Page_Ranges'First)'Address,
         Page_Ranges'Length);
       </body>
     </method>
     <method id="gtk_print_settings_get_page_ranges" return="Gtk_Page_Range_Array">
       <parameter name="num_ranges" ada="" default="-1" />
       <body>
      type Internal_Page_Range_Array is
        array (Natural) of Gtk_Page_Range_Record;
      pragma Convention (C, Internal_Page_Range_Array);

      type Internal_Page_Range_Array_Access is
        access Internal_Page_Range_Array;
      pragma Convention (C, Internal_Page_Range_Array_Access);

      procedure Free (Item : in out Internal_Page_Range_Array_Access);
      pragma Import (C, Free, "g_free");

      function Internal
        (Settings   : System.Address;
         Num_Ranges : access Gint)
         return Internal_Page_Range_Array_Access;
      pragma Import (C, Internal, "gtk_print_settings_get_page_ranges");

      Len    : aliased Gint;
      Result : Internal_Page_Range_Array_Access;
   begin
      Result := Internal (Get_Object (Self), Len'Access);
      declare
         Ranges : constant Gtk_Page_Range_Array :=
           Gtk_Page_Range_Array (Result (0 .. Natural (Len)));
      begin
         Free (Result);
         return Ranges;
      end;
       </body>
     </method>
     <extra>
       <type ctype="GtkPageRange" ada="Gtk_Page_Range_Record">
   type Gtk_Page_Range_Record is record
      Range_Start : Gint;
      Range_End   : Gint;
   end record;
   pragma Convention (C, Gtk_Page_Range_Record);
   type Gtk_Page_Range_Array is array (Integer range &lt;&gt;) of Gtk_Page_Range_Record;
   pragma Convention (C, Gtk_Page_Range_Array);
   --  Page range specification(s).
       </type>
     </extra>
   </package>

   <package id="GtkBuilder">
     <parameter name="self" ada="Builder"/>
     <parameter name="error" direction="out" />
     <method id="gtk_builder_add_from_string">
       <parameter name="length" default="-1" ada=""/>
     </method>
     <method id="gtk_builder_get_objects" return="ObjectSList" />
     <method id="gtk_builder_value_from_string" return_as_param="Success" />
   </package>

   <package id="GtkUIManager">
     <enum ctype="GtkUIManagerItemType" prefix="GTK_UI_"
           ada="Manager_Item_Type"/>
     <method id="gtk_ui_manager_add_ui" ada="Add_UI">
       <parameter name="type" default="Manager_Auto"/>
       <parameter name="top" default="False"/>
     </method>
     <method id="gtk_ui_manager_remove_ui" ada="Remove_UI"/>
     <method id="gtk_ui_manager_add_ui_from_file" ada="Add_UI_From_File">
       <parameter name="error" direction="out"/>
     </method>
     <method id="gtk_ui_manager_add_ui_from_resource" ada="Add_UI_From_Resource">
       <parameter name="error" direction="out"/>
     </method>
     <method id="gtk_ui_manager_add_ui_from_string" ada="Add_UI_From_String">
       <parameter name="error" direction="out"/>
       <parameter name="length" ada="" default="-1"/>
     </method>
     <method id="gtk_ui_manager_get_action_groups" return="ObjectList"/>
     <method id="gtk_ui_manager_get_toplevels" return="WidgetSList"/>
   </package>

   <package id="GtkIconSet">
     <doc>
   An icon set represents a single icon in various sizes and widget states.
   It can provide a Gdk_Pixbuf for a given size and state on request, and
   automatically caches some of the rendered Gdk_Pixbuf objects.

   Normally you would use Gtk.Widget.Render_Icon instead of using icon sets
   directly. The one case where you'd use an icon set is to create
   application-specific icon sets to place in an icon factory.
     </doc>

     <extra>
       <spec>
   function Lookup_Icon_Set
     (Style  : access Gtk.Style.Gtk_Style_Record'Class; Stock_Id : String)
      return Gtk_Icon_Set;
   --  Retrieve an icon set by its name. The icon might exist in various sizes,
   --  that can be manipulated through the result set
       </spec>
       <body>
   function Lookup_Icon_Set
     (Style    : access Gtk.Style.Gtk_Style_Record'Class;
      Stock_Id : String)
      return Gtk_Icon_Set
   is
      function Internal
        (Style    : System.Address;
         Stock_Id : String)
         return System.Address;
      pragma Import (C, Internal, "gtk_style_lookup_icon_set");
      --  External binding: gtk_style_lookup_icon_set
   begin
      return From_Object (Internal (Get_Object (Style), Stock_Id &amp; ASCII.NUL));
   end Lookup_Icon_Set;
       </body>
     </extra>
     <method id="gtk_style_context_lookup_icon_set" bind="False"/> <!--  in GtkIconSet-->

     <method id="gtk_icon_set_get_sizes" return="Gint_Array">
       <parameter name="n_sizes" ada=""/>
       <parameter name="sizes" ada=""/>
       <body>
      type gint_array_bounded is array (Natural) of Gint;

      procedure Internal
         (Self        : System.Address;
          Sizes       : System.Address;
          Acc_N_Sizes : access Gint);
      pragma Import (C, Internal, "gtk_icon_set_get_sizes");

      procedure g_free (s : access gint_array_bounded);
      pragma Import (C, g_free, "g_free");

      Sizes : aliased access gint_array_bounded;
      Size : aliased Gint;
   begin
      Internal (Self.Get_Object, Sizes'Address, Size'Access);

      declare
         Result : Gint_Array (1 .. Integer (Size));
      begin
         for R in 0 .. Integer (Size) - 1 loop
             Result (R + 1) := Sizes (R);
         end loop;
         g_free (Sizes);

         return Result;
      end;
       </body>
     </method>
   </package>

   <package id="GtkIconSource">
     <doc>
An icon source contains a Gdk_Pixbuf (or image filename) that serves as
the base image for one or more of the icons in an icon set, along with a
specification for which icons in the icon set will be based on that
pixbuf or image file. An icon set contains a set of icons that represent
"the same" logical concept in different states, different global text
directions, and different sizes.

So for example a web browser's "Back to Previous Page" icon might point
in a different direction in Hebrew and in English; it might look
different when insensitive; and it might change size depending on
toolbar mode (small/large icons). So a single icon set would contain all
those variants of the icon. An icon set contains a list of icon sources
from which it can derive specific icon variants in the set.

In the simplest case, an icon set contains one source pixbuf from which
it derives all variants.

If you want to use a different base pixbuf for different icon variants,
you create multiple icon sources, mark which variants they'll be used to
create, and add them to the icon set with Add_Source (see below).

By default, the icon source has all parameters wildcarded. That is, the
icon source will be used as the base icon for any desired text
direction, widget state, or icon size.
     </doc>
   </package>

   <package id="GtkIconFactory">

     <function id="gtk_icon_size_lookup" return_as_param="Result" />
     <function id="gtk_icon_size_lookup_for_settings" return_as_param="Result" />
     <function id="gtk_icon_size_register" />
     <function id="gtk_icon_size_register_alias" />

     <extra>
       <with_spec pkg="Gtk.Style_Provider"/>
       <with_spec pkg="Gtk.Widget"/>
       <spec>
   function Get_Icon_Factory
      (Self : Gtk.Style_Provider.Gtk_Style_Provider;
       Path : Gtk.Widget.Gtk_Widget_Path)
       return Gtk_Icon_Factory;
   --  Returns the Gtk.Icon_Factory.Gtk_Icon_Factory defined to be in use for
   --  Path, or null if none is defined.
   --  Since: gtk+ 3.0
       </spec>
       <body>
   function Get_Icon_Factory
      (Self : Gtk_Style_Provider;
       Path : Gtk.Widget.Gtk_Widget_Path)
       return Gtk.Icon_Factory.Gtk_Icon_Factory
   is
      function Internal
         (Self : Gtk_Style_Provider;
          Path : Gtk.Widget.Gtk_Widget_Path) return System.Address;
      pragma Import (C, Internal, "gtk_style_provider_get_icon_factory");
      Stub_Gtk_Icon_Factory : Gtk.Icon_Factory.Gtk_Icon_Factory_Record;
   begin
      return Gtk.Icon_Factory.Gtk_Icon_Factory (Get_User_Data (Internal (Self, Path), Stub_Gtk_Icon_Factory));
   end Get_Icon_Factory;
       </body>
     </extra>
   </package>

   <package id="GtkIconTheme">
     <parameter name="self" ada="Icon_Theme" />
     <enum ctype="GtkIconLookupFlags" prefix="GTK_"/>
     <method id="gtk_icon_theme_lookup_by_gicon" classwide="true" />
     <method id="gtk_icon_theme_lookup_icon" classwide="true" />
     <method id="gtk_icon_theme_choose_icon" classwide="true" />
     <method id="gtk_icon_theme_set_search_path">
       <parameter name="n_elements" ada="" default="Path'Length"/>
     </method>
     <method id="gtk_icon_theme_get_search_path" return="GNAT.Strings.String_List">
       <parameter name="path" ada=""/>
       <parameter name="n_elements" ada=""/>
       <body>
      procedure Internal
        (Icon_Theme : System.Address;
         Path       : out chars_ptr_array_access;
         N_Elements : out Gint);
      pragma Import (C, Internal, "gtk_icon_theme_get_search_path");

      P : chars_ptr_array_access;
      N : Gint;
   begin
      Internal (Get_Object (Icon_Theme), P, N);
      declare
         Result : constant GNAT.Strings.String_List :=
           To_String_List (P.all, N);
      begin
         Free (P.all);
         return Result;
      end;
       </body>
     </method>
     <method id="gtk_icon_theme_get_icon_sizes">
       <body>
      use Gint_Arrays;
      function Internal
        (Icon_Theme : System.Address;
         Icon_Name  : String) return Unbounded_Array_Access;
      pragma Import (C, Internal, "gtk_icon_theme_get_icon_sizes");

      Res    : constant Unbounded_Array_Access := Internal
        (Get_Object (Icon_Theme), Icon_Name &amp; ASCII.NUL);
      Result : constant Gint_Array := To_Gint_Array_Zero_Terminated (Res);
   begin
      G_Free (Res);
      return Result;
       </body>
     </method>
     <method id="gtk_icon_theme_list_icons" return="StringList"/>
     <method id="gtk_icon_theme_list_contexts" return="StringList"/>
     <extra>
       <with_body pkg="Gtkada.Bindings"/>
     </extra>
   </package>

   <package id="GtkIconInfo" into="GtkIconTheme">
     <parameter name="self" ada="Icon_Info" />
     <method id="gtk_icon_info_get_type" ada="Icon_Info_Get_Type"/>
     <method id="gtk_icon_info_load_icon_async" bind="False"/> <!-- requires GAsync -->
     <method id="gtk_icon_info_load_symbolic_async" bind="False"/> <!-- requires GAsync -->
     <method id="gtk_icon_info_load_icon_finish" bind="False"/> <!-- requires GAsync -->
     <method id="gtk_icon_info_load_symbolic_finish" bind="False"/> <!-- requires GAsync -->
     <method id="gtk_icon_info_load_symbolic_for_context_async" bind="False"/> <!-- requires GAsync -->
     <method id="gtk_icon_info_load_symbolic_for_context_finish" bind="False"/> <!-- requires GAsync -->
     <method id="gtk_icon_info_get_embedded_rect" return_as_param="Has_Embedded_Rectangle"/>
     <method id="gtk_icon_info_get_attach_points" return="Gdk.Types.Gdk_Points_Array">
       <parameter name="n_points" ada=""/>
       <parameter name="points" ada=""/>
       <body>
      use Points_Arrays;
      function Internal
        (Icon_Info : System.Address;
         Result    : access Unbounded_Array_Access;
         N_Points  : access Gint) return Gboolean;
      pragma Import (C, Internal, "gtk_icon_info_get_attach_points");

      R : aliased Unbounded_Array_Access;
      N : aliased Gint;
   begin
      if Internal (Icon_Info.Get_Object, R'Unchecked_Access,
                   N'Unchecked_Access) = 0
      then
         R := null;
      end if;

      declare
         Result : constant Gdk_Points_Array := To_Array (R, Integer (N));
      begin
         G_Free (R);
         return Result;
      end;
       </body>
     </method>
     <extra>
       <with_body pkg="Gtkada.C"/>
       <body>
   package Points_Arrays is new Gtkada.C.Unbounded_Arrays
     (Gdk.Types.Gdk_Point, (0, 0), Positive, Gdk.Types.Gdk_Points_Array);
       </body>
     </extra>
   </package>

   <package id="GtkSettings">
     <method id="gtk_settings_install_property_parser" bind="False"/> <!-- not needed in Ada -->
     <method id="gtk_settings_set_property_value" bind="False"/> <!-- see below -->
     <extra>
       <spec>
   procedure Set_Property_Value
     (Settings : not null access Gtk_Settings_Record;
      Name     : String;
      Value    : GValue;
      Origin   : String);
       </spec>
       <body>
   procedure Set_Property_Value
     (Settings : not null access Gtk_Settings_Record;
      Name     : String;
      Value    : GValue;
      Origin   : String)
   is
      type Property_Value is record
         Origin : Interfaces.C.Strings.chars_ptr;
         Value  : GValue;
      end record;
      pragma Convention (C, Property_Value);

      procedure Internal
        (Settings : System.Address;
         Name     : String;
         Svalue   : System.Address);
      pragma Import (C, Internal, "gtk_settings_set_property_value");

      Val : aliased Property_Value :=
        (Origin => New_String (Origin),
         Value  => Value);
   begin
      Internal (Get_Object (Settings), Name &amp; ASCII.NUL, Val'Address);
      Free (Val.Origin);
   end Set_Property_Value;
       </body>
     </extra>
   </package>

   <package id="GtkBorder" into="GtkStyle">
     <record ctype="GtkBorder"/>
     <method id="gtk_border_copy" bind="False" />  <!-- not needed in Ada -->
     <method id="gtk_border_free" bind="False" />  <!-- not needed in Ada -->
     <method id="gtk_border_get_type" ada="Border_Get_Type"/>
   </package>

   <package id="GtkStockItem" ada="Gtk.Stock">
     <record ctype="GtkStockItem" private="True"/>
     <constant prefix_regexp="GTK_STOCK_.*" prefix="GTK_"/>
     <function id="gtk_stock_add" ada="Add">
       <parameter name="items" type="Gtk_Stock_Item_Array"/>
       <parameter name="n_items" ada="" default="Items'Length"/>
     </function>
     <function id="gtk_stock_add_static" ada="Add_Static">
       <parameter name="items" type="Gtk_Stock_Item_Array"/>
       <parameter name="n_items" ada="" default="Items'Length"/>
     </function>
     <function id="gtk_stock_lookup" ada="Lookup" return_as_param="Success"/>
     <method id="gtk_stock_item_free" bind="False" /> <!-- see below -->
     <extra>
       <type ada="Gtk_Stock_Item_Array" ctype="GtkStockItemArray">
   type Gtk_Stock_Item_Array is array (Natural range &lt;&gt;) of Gtk_Stock_Item;
       </type>
       <spec>
   procedure Gtk_New
     (Item               : out Gtk_Stock_Item;
      Stock_Id           : String;
      Label              : UTF8_String;
      Modifier           : Gdk.Types.Gdk_Modifier_Type;
      Keyval             : Gdk.Types.Gdk_Key_Type;
      Translation_Domain : String);
   --  Create a new stock item.

   procedure Free (Item : in out Gtk_Stock_Item);
   --  Free memory allocated in Item.

   procedure Add (Item : Gtk_Stock_Item);
   --  Register Item.
   --  If an item already exists with the same stock ID as one of the items,
   --  the old item gets replaced. The stock item is copied, so GtkAda does
   --  not hold any pointer into item and item can be freed. Use
   --  Add_Static if item is persistent and GtkAda need not copy the array.
       </spec>
       <with_body pkg="Interfaces.C.Strings" />
       <body>
   procedure Gtk_New
     (Item               : out Gtk_Stock_Item;
      Stock_Id           : String;
      Label              : UTF8_String;
      Modifier           : Gdk.Types.Gdk_Modifier_Type;
      Keyval             : Gdk.Types.Gdk_Key_Type;
      Translation_Domain : String) is
   begin
      Item.Stock_Id           := Interfaces.C.Strings.New_String (Stock_Id);
      Item.Label              := Interfaces.C.Strings.New_String (Label);
      Item.Modifier           := Modifier;
      Item.Keyval             := Guint (Keyval);
      Item.Translation_Domain := Interfaces.C.Strings.New_String (Translation_Domain);
   end Gtk_New;

   procedure Free (Item : in out Gtk_Stock_Item) is
   begin
      Interfaces.C.Strings.Free (Item.Stock_Id);
      Interfaces.C.Strings.Free (Item.Label);
      Interfaces.C.Strings.Free (Item.Translation_Domain);
   end Free;

   ---------
   -- Add --
   ---------

   procedure Add (Item : Gtk_Stock_Item) is
      procedure Internal (Item : Gtk_Stock_Item; N_Items : Guint := 1);
      pragma Import (C, Internal, "gtk_stock_add");

   begin
      Internal (Item);
   end Add;
       </body>
     </extra>
   </package>

   <package id="GtkTextIter">
     <parameter name="self" ada="Iter"/>
     <record ctype="GtkTextIter" private="True"/>
     <enum ctype="GtkTextSearchFlags" prefix="GTK_TEXT_SEARCH_"/>

     <method id="gtk_text_iter_get_buffer" bind="False"/> <!-- circular dependency -->
     <method id="gtk_text_iter_get_child_anchor" bind="False"/> <!-- circular dependency -->
     <method id="gtk_text_iter_copy" bind="False"/> <!-- manual binding below -->
     <method id="gtk_text_iter_get_marks" return="ObjectSList" />
     <method id="gtk_text_iter_get_tags" return="TextTagList" />
     <method id="gtk_text_iter_get_toggled_tags" return="TextTagList" />

     <method id="gtk_text_iter_forward_char" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_chars" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_char" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_chars" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_word_end" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_word_ends" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_visible_word_end" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_visible_word_ends" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_word_start" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_word_starts" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_visible_word_start" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_visible_word_starts" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_sentence_end" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_sentence_ends" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_sentence_start" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_sentence_starts" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>

     <method id="gtk_text_iter_set_offset">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_set_line">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_set_line_offset">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_set_line_index">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_set_visible_line_offset">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_set_visible_line_index">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>

     <method id="gtk_text_iter_forward_line" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_lines" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_visible_line" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_visible_lines" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_to_line_end" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>

     <method id="gtk_text_iter_backward_line" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_lines" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_visible_line" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_visible_lines" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>

     <method id="gtk_text_iter_forward_to_end">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>

     <method id="gtk_text_iter_forward_to_tag_toggle" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
       <parameter name="tag" default="null"/>
     </method>
     <method id="gtk_text_iter_backward_to_tag_toggle" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
       <parameter name="tag" default="null"/>
     </method>

     <method id="gtk_text_iter_forward_cursor_position" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_cursor_positions" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_cursor_position" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_cursor_positions" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_visible_cursor_position" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_forward_visible_cursor_positions" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_visible_cursor_position" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_visible_cursor_positions" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>

     <method id="gtk_text_iter_forward_search" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
       <parameter name="limit" default="Null_Text_Iter"/>
     </method>
     <method id="gtk_text_iter_backward_search" return_as_param="Result">
       <parameter name="self" ada="Iter" direction="inout"/>
       <parameter name="limit" default="Null_Text_Iter"/>
     </method>
     <method id="gtk_text_iter_forward_find_char" return_as_param="Result"
             bind="false"> <!--  Need func with callback and return_as_param -->
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <method id="gtk_text_iter_backward_find_char" return_as_param="Result"
             bind="false"> <!--  Need func with callback and return_as_param -->
       <parameter name="self" ada="Iter" direction="inout"/>
     </method>
     <extra>
        <with_spec pkg="Glib.Values"/>
        <with_spec pkg="Interfaces.C.Strings"/>
        <with_body pkg="Ada.Unchecked_Conversion" use="False"/>
        <with_body pkg="System.Address_To_Access_Conversions" use="False"/>
        <type>
   Null_Text_Iter : constant Gtk_Text_Iter;
        </type>
        <spec private="True">
   Null_Text_Iter : constant Gtk_Text_Iter :=
     (System.Null_Address, System.Null_Address, 0, 0, 0, 0, 0, 0,
      System.Null_Address, System.Null_Address, 0, 0, 0,
      System.Null_Address);
        </spec>
        <spec>
   procedure Copy (Source : Gtk_Text_Iter; Dest : out Gtk_Text_Iter);
   pragma Inline (Copy);
   --  Create a copy of Source.

   function Get_Char (Iter : Gtk_Text_Iter) return Character;
   --  Return the character immediately following Iter. If Iter is at the
   --  end of the buffer, then return ASCII.NUL.
   --  Note that this function assumes that the text is encoded in ASCII
   --  format. If this is not the case, use the Get_Char function that
   --  returns a Gunichar instead.

   function Iter_Or_Null (Iter : System.Address) return System.Address;
   --  Internal function for GtkAda

   -------------------------------
   -- Converting to/from GValue --
   -------------------------------

   procedure Set_Text_Iter
     (Val  : in out Glib.Values.GValue;
      Iter : Gtk_Text_Iter);
   pragma Import (C, Set_Text_Iter, "g_value_set_pointer");
   --  Set the value of the given GValue to Iter.
   --  Note that Iter is stored by reference, which means no copy of Iter
   --  is made. Iter should remain allocated as long as Val is being used.

   procedure Get_Text_Iter
     (Val  : Glib.Values.GValue;
      Iter : out Gtk_Text_Iter);
   --  Extract the iterator from the given GValue.
   --  Note that the iterator returned is a copy of the iterator referenced
   --  by the give GValue. Modifying the iterator returned does not modify
   --  the iterator referenced by the GValue.

   function Get_Slice
     (Start   : Gtk_Text_Iter;
      The_End : Gtk_Text_Iter) return Interfaces.C.Strings.chars_ptr;
   --  Same as Get_Slice above, but returns the raw C string.
   --  The caller is responsible for freeing the string returned.

        </spec>
        <body>

   type Gtk_Text_Iter_Access is access Gtk_Text_Iter;
   function Convert is new Ada.Unchecked_Conversion
     (System.Address, Gtk_Text_Iter_Access);
   use type System.Address;

   ------------------
   -- Iter_Or_Null --
   ------------------

   function Iter_Or_Null (Iter : System.Address) return System.Address is
   begin
      if Convert (Iter).all = Null_Text_Iter then--  null iter
         return System.Null_Address;
      else
         return Iter;
      end if;
   end Iter_Or_Null;

   ----------
   -- Copy --
   ----------

   procedure Copy (Source : Gtk_Text_Iter; Dest : out Gtk_Text_Iter) is
   begin
      Dest := Source;
   end Copy;

   --------------
   -- Get_Char --
   --------------

   function Get_Char (Iter : Gtk_Text_Iter) return Character is
      Result         : constant Gunichar := Get_Char (Iter);
      Eight_LSB_Mask : constant := 2#1111_1111#;

   begin
      --  This function relies on the Get_Char function provided by gtk+,
      --  which returns a gunichar value. Only the 8 least significant bits
      --  are then kept to deduce the associated character.

      return Character'Val (Result and Eight_LSB_Mask);
   end Get_Char;

   -------------------
   -- Get_Text_Iter --
   -------------------

   package Iter_Access_Address_Conversions is
     new System.Address_To_Access_Conversions (Gtk_Text_Iter);

   procedure Get_Text_Iter
     (Val  : Glib.Values.GValue;
      Iter : out Gtk_Text_Iter) is
   begin
      Copy
        (Source => Iter_Access_Address_Conversions.To_Pointer
                     (Glib.Values.Get_Address (Val)).all,
         Dest   => Iter);
   end Get_Text_Iter;

   ---------------
   -- Get_Slice --
   ---------------

   function Get_Slice
     (Start   : Gtk_Text_Iter;
      The_End : Gtk_Text_Iter) return Interfaces.C.Strings.chars_ptr
   is
      function Internal
        (Start   : Gtk_Text_Iter;
         The_End : Gtk_Text_Iter) return Interfaces.C.Strings.chars_ptr;
      pragma Import (C, Internal, "gtk_text_iter_get_slice");

   begin
      return Internal (Start, The_End);
   end Get_Slice;
        </body>
     </extra>
   </package>

   <package id="GIcon" ada="Glib.G_Icon">
     <method id="g_icon_hash">
       <parameter name="icon" type="G_Icon"/>
     </method>
   </package>

   <package id="GtkToolPalette">
     <enum ctype="GtkDestDefaults"/>
     <enum ctype="GtkToolPaletteDragTargets"/>
     <method id="gtk_tool_palette_get_hadjustment" bind="False"/> <!-- obsolete, use interface-->
     <method id="gtk_tool_palette_get_vadjustment" bind="False"/> <!-- obsolete, use interface-->
   </package>

   <package id="PangoFont">
     <parameter name="self" ada="Font" />

     <method id="pango_font_get_type" ada="Font_Get_Type"/>
     <method id="pango_font_find_shaper" bind="False"/> <!--  internal implementation of gtk -->
     <method id="pango_font_describe" classwide="True"/>
     <method id="pango_font_describe_with_absolute_size" classwide="True"/>
     <method id="pango_font_descriptions_free" bind="False"/> <!-- in Ada, need iteration -->
     <method id="pango_font_get_coverage" bind="False"/> <!-- circular dependency -->
     <method id="pango_font_get_font_map" bind="False"/> <!-- circular dependency -->
     <method id="pango_font_get_metrics">
       <parameter name="language" default="Pango.Language.Null_Pango_Language"/>
     </method>
   </package>

   <package id="PangoMatrix">
     <record ctype="PangoMatrix"/>
     <method id="pango_matrix_rotate">
       <parameter name="self" direction="inout"/>
     </method>
     <method id="pango_matrix_scale">
       <parameter name="self" direction="inout"/>
     </method>
     <method id="pango_matrix_translate">
       <parameter name="self" direction="inout"/>
     </method>
   </package>

   <package id="PangoCoverage">
     <method id="pango_coverage_new" ada="Pango_New"/>
     <method id="pango_coverage_from_bytes" bind="False"/>  <!-- not used for Ada -->
     <method id="pango_coverage_to_bytes" bind="False"/>  <!-- not used for Ada -->
   </package>

   <package id="PangoTabArray" ada="Pango.Tabs">
     <enum ctype="PangoTabAlign"/>
     <method id="pango_tab_array_get_tabs" bind="False"/> <!-- Require manual binding -->
   </package>

   <package id="PangoAttribute" ada="Pango.Attributes">
     <record ctype="PangoAttribute" private="True"/>
     <method id="pango_attribute_init" bind="False"/> <!--  low-level -->
     <function id="pango_attr_underline_new"/>
     <function id="pango_attr_background_new"/>
     <function id="pango_attr_foreground_new"/>
     <function id="pango_attr_family_new"/>
     <function id="pango_attr_strikethrough_new"/>
     <function id="pango_attr_variant_new"/>
     <function id="pango_attr_weight_new"/>
     <function id="pango_attr_stretch_new"/>
     <function id="pango_attr_scale_new"/>
     <function id="pango_attr_rise_new"/>
     <function id="pango_attr_gravity_new"/>
   </package>

   <package id="PangoAttrList" into="PangoAttribute">
     <method id="pango_attr_list_get_iterator" bind="False"/>  <!-- Not needed ? -->
   </package>

   <package id="PangoContext">
     <method id="pango_context_get_font_map" bind="False" /> <!-- circular dep -->
     <method id="pango_context_set_font_map" bind="False" /> <!-- circular dep -->
     <extra>
       <with_spec pkg="Pango.Font_Family"/>
     </extra>
     <method id="pango_context_list_families" return="Pango_Font_Family_Array">
       <parameter name="families" ada=""/>
       <parameter name="n_families" ada=""/>
       <body>
      type font_family_array_bounded is array (Natural) of System.Address;

      procedure Internal
         (Self     : System.Address;
          Families : System.Address;
          Size     : access Gint);
      pragma Import (C, Internal, "pango_context_list_families");

      procedure g_free (s : access font_family_array_bounded);
      pragma Import (C, g_free, "g_free");

      Families : aliased access font_family_array_bounded;
      Size : aliased Gint;
      Tmplt : Pango_Font_Family_Record;
   begin
      Internal (Get_Object (Self), Families'Address, Size'Access);

      declare
         Result : Pango_Font_Family_Array (1 .. Integer (Size));
      begin
         for R in 0 .. Integer (Size) - 1 loop
             Result (R + 1) := Pango_Font_Family
                (Get_User_Data (Families (R), Tmplt));
         end loop;
         g_free (Families);

         return Result;
      end;
       </body>
     </method>
   </package>

   <package id="PangoFontDescription" into="PangoFont">
     <method id="pango_font_description_free" bind="False" /> <!--  manual binding below -->
     <extra>
       <with_spec pkg="Glib.Generic_Properties"/>
       <spec>
   function To_Font_Description
     (Family_Name : String := "";
      Style       : Pango.Enums.Style := Pango.Enums.Pango_Style_Normal;
      Variant     : Pango.Enums.Variant := Pango.Enums.Pango_Variant_Normal;
      Weight      : Pango.Enums.Weight := Pango.Enums.Pango_Weight_Normal;
      Stretch     : Pango.Enums.Stretch := Pango.Enums.Pango_Stretch_Normal;
      Size        : Gint := 0) return Pango_Font_Description;
   --  Create a new font decription from the given parameters.

   function To_Address
     (F : Pango_Font_Description; Add : System.Address) return System.Address;
   package Desc_Properties is new Generic_Internal_Boxed_Property
     (Pango_Font_Description, Get_Type, To_Address);
   type Property_Font_Description is new Desc_Properties.Property;

   procedure Free (Desc : in out Pango_Font_Description);
   --  Deallocate the given font description.
       </spec>
       <body>
   subtype String7 is String (1 .. 7);
   Style_Map : constant array (Enums.Style) of String7 :=
     (Enums.Pango_Style_Normal  =&gt; "       ",
      Enums.Pango_Style_Oblique =&gt; "Oblique",
      Enums.Pango_Style_Italic  =&gt; "Italic ");

   subtype String10 is String (1 .. 10);
   Variant_Map : constant array (Enums.Variant) of String10 :=
     (Enums.Pango_Variant_Normal     =&gt; "          ",
      Enums.Pango_Variant_Small_Caps =&gt; "Small-Caps");

   subtype String15 is String (1 .. 15);
   Stretch_Map : constant array (Enums.Stretch) of String15 :=
     (Enums.Pango_Stretch_Ultra_Condensed =&gt; "Ultra-Condensed",
      Enums.Pango_Stretch_Extra_Condensed =&gt; "Extra-Condensed",
      Enums.Pango_Stretch_Condensed       =&gt; "Condensed      ",
      Enums.Pango_Stretch_Semi_Condensed  =&gt; "Semi-Condensed ",
      Enums.Pango_Stretch_Normal          =&gt; "               ",
      Enums.Pango_Stretch_Semi_Expanded   =&gt; "Semi-Expanded  ",
      Enums.Pango_Stretch_Expanded        =&gt; "Expanded       ",
      Enums.Pango_Stretch_Extra_Expanded  =&gt; "Extra-Expanded ",
      Enums.Pango_Stretch_Ultra_Expanded  =&gt; "Ultra-Expanded ");

   --  Some of the values are not directly supported by pango.
   --  ??? See fonts.c in pango

   Weight_Map : constant array (Enums.Weight) of String10 :=
     (Enums.Pango_Weight_Ultralight  =&gt; "Light     ",
      Enums.Pango_Weight_Thin        =&gt; "Thin      ",
      Enums.Pango_Weight_Light       =&gt; "Light     ",
      Enums.Pango_Weight_Normal      =&gt; "          ",
      Enums.Pango_Weight_Book        =&gt; "Book      ",
      Enums.Pango_Weight_Medium      =&gt; "Medium    ",
      Enums.Pango_Weight_Semibold    =&gt; "Semi-Bold ",
      Enums.Pango_Weight_Bold        =&gt; "Bold      ",
      Enums.Pango_Weight_Ultrabold   =&gt; "Bold      ",
      Enums.Pango_Weight_Ultraheavy  =&gt; "Ultraheavy",
      Enums.Pango_Weight_Heavy       =&gt; "Heavy     ");

   function To_Font_Description
     (Family_Name : String := "";
      Style       : Enums.Style := Enums.Pango_Style_Normal;
      Variant     : Enums.Variant := Enums.Pango_Variant_Normal;
      Weight      : Enums.Weight := Enums.Pango_Weight_Normal;
      Stretch     : Enums.Stretch := Enums.Pango_Stretch_Normal;
      Size        : Gint := 0) return Pango_Font_Description
   is
   begin
      return From_String (Family_Name &amp; " " &amp;
                     Style_Map (Style) &amp; " " &amp;
                     Variant_Map (Variant) &amp;
                     Weight_Map (Weight) &amp; " " &amp;
                     Stretch_Map (Stretch) &amp; Gint'Image (Size));
   end To_Font_Description;

   function To_Address
      (F : Pango_Font_Description; Add : System.Address)
      return System.Address
   is
      pragma Unreferenced (Add);
   begin
      return F.all'Address;
   end To_Address;

   ----------
   -- Free --
   ----------

   procedure Free (Desc : in out Pango_Font_Description) is
      procedure Internal (Desc : Pango_Font_Description);
      pragma Import (C, Internal, "pango_font_description_free");

   begin
      Internal (Desc);
      Desc := null;
   end Free;
       </body>
     </extra>
   </package>

   <package id="GtkCellView">
     <parameter name="self" ada="Cell_View"/>
   </package>

   <package id="GtkTreeView">
     <parameter name="self" ada="Tree_View"/>
     <enum ctype="GtkTreeViewDropPosition" />
     <method id="gtk_tree_view_get_columns" return="GtkTreeViewColumnList"/>

     <method id="gtk_tree_view_new_with_model" ada="Gtk_New" />
     <method id="gtk_tree_view_insert_column">
       <parameter name="position" default="-1"/>
     </method>
     <method id="gtk_tree_view_get_path_at_pos" return_as_param="Row_Found"/>
     <method id="gtk_tree_view_get_visible_range" return_as_param="Success"/>
     <method id="gtk_tree_view_get_tooltip_context" return_as_param="Success"/>
     <method id="gtk_tree_view_set_expander_column">
        <parameter name="column" allow-none="1"/>
     </method>

     <method id="gtk_tree_view_get_hadjustment" bind="False" /> <!-- from scrollable -->
     <method id="gtk_tree_view_get_vadjustment" bind="False" /> <!-- from scrollable -->
     <method id="gtk_tree_view_set_hadjustment" bind="False" /> <!-- from scrollable -->
     <method id="gtk_tree_view_set_vadjustment" bind="False" /> <!-- from scrollable -->

     <method id="gtk_tree_view_enable_model_drag_source">
       <parameter name="targets" ctype="Gtk.Target_List.Target_Entry_Array"/>
       <parameter name="n_targets" ada="" default="Targets'Length" />
     </method>
     <method id="gtk_tree_view_enable_model_drag_dest">
       <parameter name="targets" ctype="Gtk.Target_List.Target_Entry_Array"/>
       <parameter name="n_targets" ada="" default="Targets'Length" />
     </method>

     <extra>
       <spec>
   procedure Gtk_New
      (Tree_View : out Gtk_Tree_View;
       Model     : access Gtk.Tree_Model.Gtk_Root_Tree_Model_Record'Class);
   --  A convenience function so that one can directly pass a model, without
   --  converting to a Gtk_Tree_Model via the "+" operator.
       </spec>
       <body>
   procedure Gtk_New
      (Tree_View : out Gtk_Tree_View;
       Model     : access Gtk.Tree_Model.Gtk_Root_Tree_Model_Record'Class)
   is
   begin
      Gtk_New (Tree_View, To_Interface (Model));
   end Gtk_New;
       </body>
     </extra>
   </package>

   <package id="GtkTreeViewColumn">
     <parameter name="self" ada="Tree_Column"/>
     <enum ctype="GtkTreeViewColumnSizing"/>
     <list ctype="GtkTreeViewColumn" ada="Column_List" />
     <method id="gtk_tree_view_column_cell_get_position" return_as_param="Success"/>

     <method id="gtk_tree_view_column_add_attribute" bind="False" /> <!-- overridden -->
     <method id="gtk_tree_view_column_clear" bind="False" /> <!-- from cell_layout -->
     <method id="gtk_tree_view_column_clear_attributes" bind="False" /> <!-- from cell_layout -->
     <method id="gtk_tree_view_column_pack_start" bind="False" /> <!-- from cell_layout -->
     <method id="gtk_tree_view_column_pack_end" bind="False" /> <!-- from cell_layout -->
     <method id="gtk_tree_view_column_set_cell_data_func" bind="False" /> <!-- from cell_layout -->
   </package>

   <package id="GtkTreeSortable">
     <parameter name="self" ada="Sortable"/>
     <method id="gtk_tree_sortable_get_sort_column_id" return="void"/>
     <extra>
       <spec>
   Default_Sort_Column_Id  : constant Gint := -1;
   Unsorted_Sort_Column_Id : constant Gint := -2;
   --  Two special values for the sort column
       </spec>
     </extra>
   </package>

   <package id="GtkTreeDragSource">
     <function id="gtk_tree_set_row_drag_data" ada="Set_Row_Drag_Data"/>
     <function id="gtk_tree_get_row_drag_data" ada="Get_Row_Drag_Data" return_as_param="succes"/>
   </package>

   <package id="GtkTreeModel">
     <parameter name="self" ada="Tree_Model"/>
     <enum ctype="GtkTreeModelFlags" ada="Tree_Model_Flags" />
     <method id="gtk_tree_model_get" bind="False"/> <!-- varargs -->
     <method id="gtk_tree_model_get_valist" bind="False"/> <!-- varargs -->
     <method id="gtk_tree_model_get_iter" return="Gtk_Tree_Iter">
       <parameter name="iter" ada=""/>
       <body>
      function Internal
        (Tree_Model : Gtk_Tree_Model;
         Iter : System.Address; Path : System.Address) return Gint;
      pragma Import (C, Internal, "gtk_tree_model_get_iter");
      Iter : aliased Gtk_Tree_Iter;
   begin
      if Internal (+Tree_Model, Iter'Address, Get_Object (Path)) /= 0 then
         return Iter;
      else
         return Null_Iter;
      end if;
       </body>
     </method>
     <method id="gtk_tree_model_get_iter_from_string" return="Gtk_Tree_Iter">
       <parameter name="iter" ada=""/>
       <body>
      function Internal
        (Tree_Model : Gtk_Tree_Model;
         Iter : System.Address; Str : String) return Gint;
      pragma Import (C, Internal, "gtk_tree_model_get_iter_from_string");
      Iter : aliased Gtk_Tree_Iter;
   begin
      if Internal
        (+Tree_Model, Iter'Address, Path_String &amp; ASCII.NUL) /= 0
      then
         return Iter;
      else
         return Null_Iter;
      end if;
       </body>
     </method>
     <method id="gtk_tree_model_get_iter_first" return="Gtk_Tree_Iter">
       <parameter name="iter" ada=""/>
       <body>
      function Internal
         (Tree_Model : Gtk_Tree_Model; Iter : System.Address) return Gint;
      pragma Import (C, Internal, "gtk_tree_model_get_iter_first");
      Iter : aliased Gtk_Tree_Iter;
   begin
      if Internal (+Tree_Model, Iter'Address) /= 0 then
         return Iter;
      else
         return Null_Iter;
      end if;
       </body>
     </method>
     <method id="gtk_tree_model_iter_next" ada="Next" return="void">
       <parameter name="iter" direction="inout"/>
       <body>
      function Internal
         (Tree_Model : Gtk_Tree_Model; Iter : System.Address) return Gint;
      pragma Import (C, Internal, "gtk_tree_model_iter_next");
      Local_Iter : aliased Gtk_Tree_Iter := Iter;
   begin
      if Internal (+Tree_Model, Local_Iter'Address) = 0 then
         Iter := Null_Iter;
      else
         Iter := Local_Iter;
      end if;
       </body>
     </method>
     <method id="gtk_tree_model_iter_previous" ada="Previous" return="void">
       <parameter name="iter" direction="inout"/>
       <body>
      function Internal
         (Tree_Model : Gtk_Tree_Model; Iter : System.Address) return Gint;
      pragma Import (C, Internal, "gtk_tree_model_iter_previous");
      Local_Iter : aliased Gtk_Tree_Iter := Iter;
   begin
      if Internal (+Tree_Model, Local_Iter'Address) = 0 then
         Iter := Null_Iter;
      else
         Iter := Local_Iter;
      end if;
       </body>
     </method>
     <method id="gtk_tree_model_iter_children" ada="Children" return="Gtk_Tree_Iter">
       <parameter name="iter" ada=""/>
       <body>
      function Internal
        (Tree_Model : Gtk_Tree_Model;
         Iter       : System.Address;
         Parent     : System.Address) return Gint;
      pragma Import (C, Internal, "gtk_tree_model_iter_children");
      It : aliased Gtk_Tree_Iter;
   begin
      if Internal (+Tree_Model, It'Address, Iter_Or_Null (Parent'Address)) /= 0 then
         return It;
      else
         return Null_Iter;
      end if;
       </body>
     </method>
     <method id="gtk_tree_model_iter_has_child" ada="Has_Child"/>
     <method id="gtk_tree_model_iter_n_children" ada="N_Children">
       <parameter name="iter" default="Gtk.Tree_Model.Null_Iter"/>
       <body>
      function Internal
          (Tree_Model : Gtk_Tree_Model; Iter : System.Address) return Gint;
      pragma Import (C, Internal, "gtk_tree_model_iter_n_children");
   begin
      return Internal (+Tree_Model, Iter_Or_Null (Iter'Address));
       </body>
     </method>
     <method id="gtk_tree_model_iter_nth_child" ada="Nth_Child" return="Gtk_Tree_Iter">
       <parameter name="iter" ada=""/>
       <body>
      function Internal
        (Tree_Model : Gtk_Tree_Model;
         Iter, Parent : System.Address; N : Gint) return Gint;
      pragma Import (C, Internal, "gtk_tree_model_iter_nth_child");
      Iter : aliased Gtk_Tree_Iter;
   begin
      if Internal (+Tree_Model, Iter'Address, Iter_Or_Null (Parent'Address), N) /= 0 then
         return Iter;
      else
         return Null_Iter;
      end if;
       </body>
     </method>
     <method id="gtk_tree_model_iter_parent" ada="Parent" return="Gtk_Tree_Iter">
       <parameter name="iter" ada=""/>
       <body>
      function Internal
        (Tree_Model : Gtk_Tree_Model;
         Iter       : System.Address;
         Child      : Gtk_Tree_Iter) return Gint;
      pragma Import (C, Internal, "gtk_tree_model_iter_parent");
      Iter : aliased Gtk_Tree_Iter;
   begin
      if Internal (+Tree_Model, Iter'Address, Child) /= 0 then
         return Iter;
      else
         return Null_Iter;
      end if;
       </body>
     </method>
     <method id="gtk_tree_model_rows_reordered">
       <parameter name="new_order" type="Gint_Array"/>
     </method>
     <extra>
       <spec>
   type Gtk_Root_Tree_Model_Record is new Glib.Object.GObject_Record
      with null record;
   type Gtk_Root_Tree_Model is
      access all Gtk_Root_Tree_Model_Record'Class;
   --  A common base type for all objects that implement GtkTreeModel. This
   --  is used to conveniently provide a number of primitive operations.

   function Get_Int
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Gint;
   function Get_Boolean
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Boolean;
   function Get_Object
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Glib.Object.GObject;
   function Get_C_Proxy
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Glib.C_Proxy;
   function Get_String
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return UTF8_String;
   function Get_Address
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return System.Address;
   --  Get the value of one cell of the model

   function Get_Int
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Gint;
   function Get_Boolean
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Boolean;
   function Get_Object
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Glib.Object.GObject;
   function Get_C_Proxy
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Glib.C_Proxy;
   function Get_String
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return UTF8_String;
   function Get_Address
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return System.Address;

   package Implements_Gtk_Tree_Model is new Glib.Types.Implements
     (Gtk_Tree_Model, Gtk_Root_Tree_Model_Record, Gtk_Root_Tree_Model);
   function To_Interface
     (Widget : access Gtk_Root_Tree_Model_Record'Class)
     return Gtk_Tree_Model renames Implements_Gtk_Tree_Model.To_Interface;
   function "-"
     (Interf : Gtk_Tree_Model) return Gtk_Root_Tree_Model
     renames Implements_Gtk_Tree_Model.To_Object;
   --  Convert from the gtk+ interface to an actual object. The return type
   --  depends on the exact model, and will likely be an instance of
   --  Gtk_Tree_Store'Class or Gtk_List_Store'Class depending on how you
   --  created it.
       </spec>
       <body>
   function Get_Int
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Gint is
   begin
     return Get_Int (To_Interface (Tree_Model), Iter, Column);
   end Get_Int;

  function Get_Int
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Gint
   is
      procedure Internal
        (Tree_Model : Gtk_Tree_Model;
         Iter       : Gtk_Tree_Iter;
         Column     : Gint;
         Value      : out Gint);
      pragma Import (C, Internal, "ada_gtk_tree_model_get");
      A : Gint;
   begin
      if Iter = Null_Iter then
         raise Program_Error with "Get_Int with null_iter";
      end if;
      Internal (Tree_Model, Iter, Column, A);
      return A;
   end Get_Int;

  function Get_Boolean
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Boolean is
   begin
      return Get_Boolean (To_Interface (Tree_Model), Iter, Column);
   end Get_Boolean;

  function Get_Boolean
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Boolean is
   begin
      return Get_Int (Tree_Model, Iter, Column) /= 0;
   end Get_Boolean;

   function Get_Object
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Glib.Object.GObject
   is
   begin
      return Get_Object (To_Interface (Tree_Model), Iter, Column);
   end Get_Object;

   function Get_Object
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Glib.Object.GObject
   is
      Stub : Glib.Object.GObject_Record;
   begin
      return Get_User_Data
         (Get_Address (Tree_Model, Iter, Column), Stub);
   end Get_Object;

   function Get_C_Proxy
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Glib.C_Proxy is
   begin
      return Get_C_Proxy (To_Interface (Tree_Model), Iter, Column);
   end Get_C_Proxy;

   function Get_C_Proxy
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return Glib.C_Proxy
   is
      procedure Internal
        (Tree_Model : Gtk_Tree_Model;
         Iter       : Gtk_Tree_Iter;
         Column     : Gint;
         Value      : out Glib.C_Proxy);
      pragma Import (C, Internal, "ada_gtk_tree_model_get");
      A : Glib.C_Proxy;
   begin
      if Iter = Null_Iter then
         raise Program_Error with "Get_C_Proxy with null_iter";
      end if;
      Internal (Tree_Model, Iter, Column, A);
      return A;
   end Get_C_Proxy;

   function Get_String
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return UTF8_String
   is
   begin
      return Get_String (To_Interface (Tree_Model), Iter, Column);
   end Get_String;

   function Get_String
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return UTF8_String
   is
      procedure Internal
        (Tree_Model : Gtk_Tree_Model;
         Iter       : Gtk_Tree_Iter;
         Column     : Gint;
         Value      : out Interfaces.C.Strings.chars_ptr);
      pragma Import (C, Internal, "ada_gtk_tree_model_get");
      A : Interfaces.C.Strings.chars_ptr;
   begin
      if Iter = Null_Iter then
         raise Program_Error with "Get_String with null_iter";
      end if;
      Internal (Tree_Model, Iter, Column, A);
      if A = Interfaces.C.Strings.Null_Ptr then
         return "";
      else
         declare
            S : constant String := Interfaces.C.Strings.Value (A);
         begin
            Interfaces.C.Strings.Free (A);
            return S;
         end;
      end if;
   end Get_String;

   function Get_Address
     (Tree_Model : access Gtk_Root_Tree_Model_Record;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return System.Address
   is
   begin
      return Get_Address (To_Interface (Tree_Model), Iter, Column);
   end Get_Address;

   function Get_Address
     (Tree_Model : Gtk_Tree_Model;
      Iter       : Gtk_Tree_Iter;
      Column     : Gint) return System.Address
   is
      procedure Internal
        (Tree_Model : Gtk_Tree_Model;
         Iter       : Gtk_Tree_Iter;
         Column     : Gint;
         Value      : out System.Address);
      pragma Import (C, Internal, "ada_gtk_tree_model_get");
      A : System.Address;
   begin
      if Iter = Null_Iter then
         raise Program_Error with "Get_Address with null_iter";
      end if;
      Internal (Tree_Model, Iter, Column, A);
      return A;
   end Get_Address;
       </body>
     </extra>
   </package>

   <package id="GtkTreeIter" into="GtkTreeModel">
     <record ctype="GtkTreeIter" private="True"/>
     <method id="gtk_tree_iter_get_type" ada="Iter_Get_Type" />
     <method id="gtk_tree_iter_copy" ada="Iter_Copy" />
     <extra>
       <type>
   Null_Iter : constant Gtk_Tree_Iter;
       </type>
       <spec>
   function "=" (Left : Gtk_Tree_Iter; Right : Gtk_Tree_Iter) return Boolean;

   procedure Set_Tree_Iter
     (Val  : in out Glib.Values.GValue;
      Iter : Gtk_Tree_Iter);
   pragma Import (C, Set_Tree_Iter, "g_value_set_pointer");
   --  Set the value of the given GValue to Iter.
   --  Note that Iter is stored by reference, which means no copy of Iter
   --  is made. Iter should remain allocated as long as Val is being used.

   procedure Get_Tree_Iter
     (Val  : Glib.Values.GValue;
      Iter : out Gtk_Tree_Iter);
   --  Extract the iterator from the given GValue.
   --  Note that the iterator returned is a copy of the iterator referenced
   --  by the give GValue. Modifying the iterator returned does not modify
   --  the iterator referenced by the GValue.

   function Get_Tree_Iter (Val : Glib.Values.GValue) return Gtk_Tree_Iter;
   --  Extract the iterator from the given GValue.

   function To_Address (Iter : Gtk_Tree_Iter) return System.Address;
   pragma Convention (C, To_Address);
   --  Return address of the specified iterator.
   --  Note: To_Address needs a pass-by-reference semantic to work properly
   --  On some ABIs (e.g. IA64), Gtk_Tree_Iter is passed by copy, since it's
   --  a "small enough" record.

   function Iter_Or_Null (Iter : System.Address) return System.Address;
   --  Internal function for GtkAda
       </spec>
       <spec private="True">
   Null_Iter : constant Gtk_Tree_Iter :=
     (0, System.Null_Address, System.Null_Address, System.Null_Address);
       </spec>
       <body>
   function "=" (Left : Gtk_Tree_Iter; Right : Gtk_Tree_Iter) return Boolean is
      use type System.Address;
   begin
      if Left.Stamp = Right.Stamp then
         if Left.Stamp = 0 then
            --  Stamp = 0 means the iterator is null iterator, we need not to
            --  compare other fields in this case.
            return True;
         else
            return Left.User_Data = Right.User_Data
                     and then Left.User_Data2 = Right.User_Data2
                     and then Left.User_Data3 = Right.User_Data3;
         end if;
      else
         return False;
      end if;
   end "=";

   type Gtk_Tree_Iter_Access is access Gtk_Tree_Iter;
   function Convert is new Ada.Unchecked_Conversion
      (System.Address, Gtk_Tree_Iter_Access);
   use type System.Address;

   function Iter_Or_Null (Iter : System.Address) return System.Address is
   begin
      if Convert (Iter).Stamp = 0 then   --  null iter
         return System.Null_Address;
      else
         return Iter;
      end if;
   end Iter_Or_Null;

   procedure Get_Tree_Iter
     (Val  : Glib.Values.GValue;
      Iter : out Gtk_Tree_Iter) is
   begin
      Iter := Convert (Glib.Values.Get_Address (Val)).all;
   end Get_Tree_Iter;

   function Get_Tree_Iter (Val : Glib.Values.GValue) return Gtk_Tree_Iter is
      Result : Gtk_Tree_Iter;
   begin
      Get_Tree_Iter (Val, Result);
      return Result;
   end Get_Tree_Iter;

   function To_Address (Iter : Gtk_Tree_Iter) return System.Address is
   begin
      return Iter'Address;
   end To_Address;
       </body>
     </extra>
   </package>

   <package id="GtkTreeRowReference">
     <parameter name="self" ada="Reference"/>
   </package>

   <package id="GtkTreePath" into="GtkTreeModel">
     <parameter name="self" ada="Path" />
     <list ctype="GtkTreePath" ada="Gtk_Tree_Path_List" section="Lists"/>
     <method id="gtk_tree_path_new_from_string" ada="Gtk_New">
       <parameter name="self" ada="Self" />
     </method>
     <method id="gtk_tree_path_get_type" ada="Path_Get_Type" />
     <method id="gtk_tree_path_free" ada="Path_Free" />
     <method id="gtk_tree_path_get_indices_with_depth" bind="False"/> <!-- duplicates Get_Indices, in Ada -->
     <method id="gtk_tree_path_get_indices" return="Glib.Gint_Array">
       <body>
      Depth : constant Integer := Integer (Get_Depth (Path));

      subtype Result_Array is Gint_Array (0 .. Depth - 1);
      type Result_Array_Access is access all Result_Array;
      pragma Convention (C, Result_Array_Access);

      function Internal (Path : System.Address) return Result_Array_Access;
      pragma Import (C, Internal, "gtk_tree_path_get_indices");

      --  Do not free the result of gtk_tree_path_get_indices since this is
      --  not a copy, but the currently used data.
      Result : constant Result_Array_Access := Internal (Get_Object (Path));

   begin
      if Result = null then
         return (0 .. -1 => 0);
      else
         return Result.all;
      end if;
       </body>
     </method>
     <extra>
       <spec>
   function Get_Tree_Path (Val : Glib.Values.GValue) return Gtk_Tree_Path;
   --  Extract the path from the given GValue.

       </spec>
       <with_body pkg="Glib.Values"/>
       <body>
   function Get_Tree_Path (Val : Glib.Values.GValue) return Gtk_Tree_Path is
   begin
      return From_Object (Glib.Values.Get_Address (Val));
   end Get_Tree_Path;
       </body>
     </extra>
   </package>

   <package id="GtkTreeModelSort" parent="Gtk.Tree_Model.Gtk_Root_Tree_Model">
     <method id="gtk_tree_model_sort_new_with_model" ada="Gtk_New_With_Model"/>
   </package>

   <package id="GtkTreeModelFilter" parent="Gtk.Tree_Model.Gtk_Root_Tree_Model">
     <method id="gtk_tree_model_filter_new" ada="Gtk_New">
       <parameter name="root" default="Null_Gtk_Tree_Path" />
     </method>
     <method id="gtk_tree_model_filter_convert_child_iter_to_iter" return="void" />
     <method id="gtk_tree_model_filter_set_modify_func"> <!-- function with callback and custom parameter -->
       <parameter name="types" type="Glib.GType_Array"/>
       <parameter name="n_columns" ada="" default="Types'Length" />
     </method>
   </package>

   <package id="GtkTreeSelection">
     <parameter name="self" ada="Selection" />
     <method id="gtk_tree_selection_get_selected" return="void">
        <body>
      function Internal
        (Selection : System.Address;
         Model     : access Gtk_Tree_Model;
         Iter      : access Gtk_Tree_Iter) return Gboolean;
      pragma Import (C, Internal, "gtk_tree_selection_get_selected");
      M  : aliased Gtk_Tree_Model := Null_Gtk_Tree_Model;
      It : aliased Gtk_Tree_Iter;
   begin
      if Internal (Get_Object (Selection), M'Access, It'Access) = 0 then
         Iter  := Null_Iter;
      else
         Iter  := It;
      end if;
      Model := M;
        </body>
     </method>
     <method id="gtk_tree_selection_get_selected_rows" bind="False"/><!-- see below -->
     <method id="gtk_tree_selection_get_tree_view" return="Gtk_Widget"/> <!-- avoid circular dep -->
     <extra>
       <spec>
   procedure Get_Selected_Rows
     (Selection : access Gtk_Tree_Selection_Record;
      Model     : out Gtk.Tree_Model.Gtk_Tree_Model;
      Path_List : out Gtk.Tree_Model.Gtk_Tree_Path_List.Glist);
   --  Creates a list of path of all selected rows. Additionally, if you are
   --  planning on modifying the model after calling this function, you may
   --  want to convert the returned list into a list of Gtk_Tree_Row_Reference.
   --
   --  You must free the resulting list by calling Path_Free on each item, and
   --  then freeing the list itself.
       </spec>
       <body>
   procedure Get_Selected_Rows
     (Selection : access Gtk_Tree_Selection_Record;
      Model     : out Gtk_Tree_Model;
      Path_List : out Gtk_Tree_Path_List.Glist)
   is
      use type System.Address;
      function Internal
        (Selection : System.Address;
         Model     : access Gtk_Tree_Model) return System.Address;
      pragma Import (C, Internal, "gtk_tree_selection_get_selected_rows");
      M        : aliased Gtk_Tree_Model;
      Selected : System.Address;  --  list of paths
   begin
      Selected := Internal (Get_Object (Selection), M'Access);
      Model := M;
      if Selected = System.Null_Address then
         Path_List := Gtk_Tree_Path_List.Null_List;
      else
         Gtk_Tree_Path_List.Set_Object (Path_List, Selected);
      end if;
   end Get_Selected_Rows;
       </body>
     </extra>
   </package>

   <package id="GtkListStore" parent="Gtk.Tree_Model.Gtk_Root_Tree_Model">
     <parameter name="self" ada="List_Store" />
     <method id="gtk_list_store_newv" ada="Gtk_New">
       <parameter name="types" type="GType_Array"/>
       <parameter name="n_columns" ada="" default="Types'Length"/>
     </method>
     <method id="gtk_list_store_set_column_types">
       <parameter name="types" type="GType_Array"/>
       <parameter name="n_columns" ada="" default="Types'Length"/>
     </method>
     <method id="gtk_list_store_insert_with_valuesv" bind="False"/> <!-- valist -->
     <method id="gtk_list_store_set_value">
       <parameter name="value" ctype="GValue" />
     </method>
     <method id="gtk_list_store_set_valist" bind="False"/> <!-- valist -->
     <method id="gtk_list_store_set_valuesv" bind="False"/> <!-- valist -->
     <method id="gtk_list_store_remove" return="void">
       <parameter name="iter" direction="inout"/>
       <body>%(auto)s
Iter := Gtk.Tree_Model.Null_Iter;
       </body>
     </method>
     <extra>
       <with_spec pkg="Gdk.Pixbuf" />
       <spec>
   procedure Set
     (Tree_Store : access Gtk_List_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : UTF8_String);
   procedure Set
     (Tree_Store : access Gtk_List_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Boolean);
   procedure Set
     (Tree_Store : access Gtk_List_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Gint);
   procedure Set
     (Tree_Store : access Gtk_List_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Gdk.Pixbuf.Gdk_Pixbuf);
       </spec>
       <body>
   procedure Set
     (Tree_Store : access Gtk_List_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : UTF8_String)
   is
      procedure Internal
        (Tree_Store : System.Address;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint;
         Value      : UTF8_String);
      pragma Import (C, Internal, "ada_gtk_list_store_set_ptr");
   begin
      Internal (Get_Object (Tree_Store), Iter, Column, Value &amp; ASCII.NUL);
   end Set;

   procedure Set
     (Tree_Store : access Gtk_List_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Gint)
   is
      procedure Internal
        (Tree_Store : System.Address;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint;
         Value      : Gint);
      pragma Import (C, Internal, "ada_gtk_list_store_set_int");
   begin
      Internal (Get_Object (Tree_Store), Iter, Column, Value);
   end Set;

   procedure Set
     (Tree_Store : access Gtk_List_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Boolean)
   is
      procedure Internal
        (Tree_Store : System.Address;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint;
         Value      : Gboolean);
      pragma Import (C, Internal, "ada_gtk_list_store_set_int");
   begin
      Internal (Get_Object (Tree_Store), Iter, Column, Boolean'Pos (Value));
   end Set;

   procedure Set
     (Tree_Store : access Gtk_List_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Gdk.Pixbuf.Gdk_Pixbuf)
   is
      procedure Internal
        (Tree_Store : System.Address;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint;
         Value      : System.Address);
      pragma Import (C, Internal, "ada_gtk_list_store_set_ptr");
   begin
      Internal (Get_Object (Tree_Store), Iter, Column, Get_Object (Value));
   end Set;
       </body>
     </extra>
   </package>

   <package id="GtkTreeStore" parent="Gtk.Tree_Model.Gtk_Root_Tree_Model">
     <parameter name="self" ada="Tree_Store" />
     <method id="gtk_tree_store_newv" ada="Gtk_New">
       <parameter name="types" type="GType_Array"/>
       <parameter name="n_columns" ada="" default="Types'Length"/>
     </method>
     <method id="gtk_tree_store_set_column_types">
       <parameter name="types" type="GType_Array"/>
       <parameter name="n_columns" ada="" default="Types'Length"/>
     </method>
     <method id="gtk_tree_store_remove" return="void">
       <parameter name="iter" direction="inout"/>
       <body>%(auto)s
Iter := Gtk.Tree_Model.Null_Iter;
       </body>
     </method>
     <method id="gtk_tree_store_reorder">
       <parameter name="new_order" type="Gint_Array"/>
     </method>
     <method id="gtk_tree_store_set_value">
       <parameter name="value" ctype="GValue" />
     </method>
     <method id="gtk_tree_store_insert_with_valuesv" bind="False"/> <!-- valist -->
     <method id="gtk_tree_store_set_valist" bind="False"/> <!-- valist -->
     <method id="gtk_tree_store_set_valuesv" bind="False"/> <!-- valist -->
     <extra>
       <spec>
   generic
      type Data_Type is private;
   package Generic_Set is
      type Data_Type_Access is access all Data_Type;

      procedure Set
        (Tree_Store : access Gtk_Tree_Store_Record'Class;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint;
         Value      : Data_Type_Access);
      --  Generic procedure used to store access objects in the model.
      --  For GObject and all of its descendents (including all widgets),
      --  you should use the Set procedure below that takes a GObject as
      --  parameter.
      --
      --  Please see the example at the end for more information on how to
      --  create your own Set procedures adapted to your model. Also consider
      --  using Set_Value for complex cases

      function Get
        (Tree_Store : access Gtk_Tree_Store_Record'Class;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint) return Data_Type_Access;
      --  Generic procedure used to get access objects back from the model.
      --  For GObject and all of its descendents (including all widgets),
      --  you should use the Get_Object function defined in Gtk-Tree_Model
      --  that returns a GObject.

   end Generic_Set;

   procedure Set
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : UTF8_String);
   procedure Set
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Boolean);
   procedure Set
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Gint);
   procedure Set
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Glib.C_Proxy);
   procedure Set
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Address    : System.Address);
   procedure Set
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Glib.Object.GObject);

   function Freeze_Sort
     (Tree : access Gtk.Tree_Store.Gtk_Tree_Store_Record'Class)
      return Gint;
   --  Freeze the sorting in the tree view, and returns the current
   --  sort_column_id, which should be used when thawing. (See Thaw_Sort)

   procedure Thaw_Sort
     (Tree      : access Gtk.Tree_Store.Gtk_Tree_Store_Record'Class;
      Column_Id : Gint);
   --  Thaw a frozen tree_view. Column_Id should be the value returned by
   --  the corresponding call to Freeze_Sort.
       </spec>
       <body>
   function Freeze_Sort
     (Tree : access Gtk.Tree_Store.Gtk_Tree_Store_Record'Class)
      return Gint
   is
      function Internal (Tree : System.Address) return Gint;
      pragma Import (C, Internal, "ada_gtk_tree_view_freeze_sort");
   begin
      return Internal (Get_Object (Tree));
   end Freeze_Sort;

   procedure Thaw_Sort
     (Tree : access Gtk.Tree_Store.Gtk_Tree_Store_Record'Class;
      Column_Id : Gint)
   is
      procedure Internal (Tree : System.Address; Id : Gint);
      pragma Import (C, Internal, "ada_gtk_tree_view_thaw_sort");
   begin
      Internal (Get_Object (Tree), Column_Id);
   end Thaw_Sort;

package body Generic_Set is

      pragma Warnings (Off);
      --  Disable warnings on strict aliasing, since there's no aliasing
      --  issue here.

      function To_Address is new
        Ada.Unchecked_Conversion (Data_Type_Access, System.Address);

      function To_Access is new
        Ada.Unchecked_Conversion (System.Address, Data_Type_Access);

      pragma Warnings (On);

      procedure Set
        (Tree_Store : access Gtk_Tree_Store_Record'Class;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint;
         Value      : Data_Type_Access) is
      begin
         Set (Tree_Store, Iter, Column, To_Address (Value));
      end Set;

      function Get
        (Tree_Store : access Gtk_Tree_Store_Record'Class;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint) return Data_Type_Access is
      begin
         return To_Access (Get_Address (+Tree_Store, Iter, Column));
      end Get;
   end Generic_Set;

   procedure Set
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Address    : System.Address)
   is
      procedure Internal
        (Tree_Store : System.Address;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint;
         Value      : System.Address);
      pragma Import (C, Internal, "ada_gtk_tree_store_set_ptr");
   begin
      Internal (Get_Object (Tree_Store), Iter, Column, Address);
   end Set;

   procedure Set
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : UTF8_String)
   is
      procedure Internal
        (Tree_Store : System.Address;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint;
         Value      : UTF8_String);
      pragma Import (C, Internal, "ada_gtk_tree_store_set_ptr");
   begin
      Internal (Get_Object (Tree_Store), Iter, Column, Value &amp; ASCII.NUL);
   end Set;

   procedure Set
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Gint)
   is
      procedure Internal
        (Tree_Store : System.Address;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint;
         Value      : Gint);
      pragma Import (C, Internal, "ada_gtk_tree_store_set_int");
   begin
      Internal (Get_Object (Tree_Store), Iter, Column, Value);
   end Set;

   procedure Set
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Boolean)
   is
      procedure Internal
        (Tree_Store : System.Address;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint;
         Value      : Gboolean);
      pragma Import (C, Internal, "ada_gtk_tree_store_set_int");
   begin
      Internal (Get_Object (Tree_Store), Iter, Column, Boolean'Pos (Value));
   end Set;

   procedure Set
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Glib.C_Proxy)
   is
      procedure Internal
        (Tree_Store : System.Address;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint;
         Value      : Glib.C_Proxy);
      pragma Import (C, Internal, "ada_gtk_tree_store_set_ptr");
   begin
      Internal (Get_Object (Tree_Store), Iter, Column, Value);
   end Set;

   procedure Set
     (Tree_Store : access Gtk_Tree_Store_Record;
      Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
      Column     : Gint;
      Value      : Glib.Object.GObject)
   is
      procedure Internal
        (Tree_Store : System.Address;
         Iter       : Gtk.Tree_Model.Gtk_Tree_Iter;
         Column     : Gint;
         Value      : System.Address);
      pragma Import (C, Internal, "ada_gtk_tree_store_set_ptr");
   begin
      if Value = null then
         Internal (Get_Object (Tree_Store), Iter, Column, System.Null_Address);
      else
         Internal (Get_Object (Tree_Store), Iter, Column, Get_Object (Value));
      end if;
   end Set;
       </body>
     </extra>
   </package>

   <package id="GtkGrid">
     <method id="gtk_grid_attach">
       <parameter name="width" default='1'/>
       <parameter name="height" default='1'/>
     </method>
     <method id="gtk_grid_attach_next_to">
       <parameter name="width" default='1'/>
       <parameter name="height" default='1'/>
     </method>
   </package>

   <package id="GtkCssSection">
     <enum ctype="GtkCssSectionType"/>

     <method id="gtk_css_section_get_file" bind="False"/>  <!--  needs GFile -->
   </package>

   <package id="GdkFrameClock">
     <enum ctype="GdkFrameClockPhase"/>
   </package>

   <package id="GtkMenuButton">
   </package>

   <package id="GtkActionable">
   </package>

   <package id="GtkThemingEngine">
     <method id="gtk_theming_engine_get_style_valist" bind="False"/> <!-- valist -->
     <method id="gtk_theming_engine_get_valist" bind="False"/> <!-- valist -->

     <method id="gtk_theming_engine_register_property" bind="False"/> <!-- obsolete and requires GtkStylePropertyParser -->
   </package>

   <package id="GtkBindingSet">
     <method id="gtk_binding_set_new" ada="Gtk_New"/>
     <record ctype="GtkBindingSet">
       <field name="widget_path_pspecs" ctype="gpointer"/>  <!-- unused in C -->
       <field name="widget_class_pspecs" ctype="gpointer"/>  <!-- unused in C -->
       <field name="class_branch_pspecs" ctype="gpointer"/>  <!-- unused in C -->
       <field name="current" ctype="gpointer"/>  <!-- implementation detail in C -->
     </record>
   </package>

   <package id="GtkBindingEntry" into="GtkBindingSet">
   </package>

   <package id="GIO" ada="Glib.IO"/>

   <package id="GVariant" ada="Glib.Variant">
     <enum ctype="GVariantClass" prefix="G_VARIANT_"/>
     <method id="g_variant_new_from_bytes" bind="False"/>  <!--  requires GByte -->
     <method id="g_variant_get_data_as_bytes" bind="False"/>  <!--  requires GByte -->
     <method id="g_variant_new_parsed_va" bind="False" /> <!-- va_list -->
     <method id="g_variant_new_va" bind="False" /> <!-- va_list -->
     <method id="g_variant_get_va" bind="False" /> <!-- va_list -->
     <method id="g_variant_new_array" bind="False"/> <!-- c arrays -->
     <method id="g_variant_new_fixed_array" bind="False"/> <!-- c arrays -->
     <method id="g_variant_new_from_data" bind="False"/> <!-- c arrays -->
     <method id="g_variant_new_maybe" bind="False"/> <!-- c arrays -->
     <method id="g_variant_new_tuple" bind="False"/> <!-- c arrays -->
     <method id="g_variant_get_fixed_array" bind="False"/> <!-- c arrays -->
     <method id="g_variant_compare" bind="False"/> <!-- c arrays -->
     <method id="g_variant_equal" bind="False"/> <!-- c arrays -->
     <method id="g_variant_get_data" bind="False"/> <!-- c arrays -->
     <method id="g_variant_dup_bytestring" bind="False"/> <!-- c arrays -->
     <method id="g_variant_get_bytestring" bind="False"/> <!-- c arrays -->
   </package>

   <package id="GVariantIter" into="GVariant" ada="Glib.Variant">
     <method id="g_variant_iter_copy" bind="False"/> <!-- results in duplicate import -->
     <method id="g_variant_iter_free" bind="False"/> <!-- results in duplicate import -->
     <method id="g_variant_iter_n_children" bind="False"/> <!-- duplicate import -->
   </package>

   <package id="GVariantType" into="GVariant" ada="Glib.Variant">
     <method id="g_variant_type_checked_" bind="False"/> <!--  implementation detail -->
     <method id="g_variant_type_new_from_bytes" bind="False"/>  <!--  requires GByte -->
     <method id="g_variant_type_new_tuple" bind="False"/> <!-- c arrays -->
     <method id="g_variant_type_new_maybe" bind="False"/> <!-- c arrays -->
     <method id="g_variant_type_new_array" bind="False"/> <!-- c arrays -->
     <method id="g_variant_type_equal" bind="False"/> <!-- c arrays -->
     <method id="g_variant_type_hash" bind="False"/> <!-- duplicate import -->
     <method id="g_variant_type_string_scan" bind="False"/> <!-- c arrays -->
   </package>

   <package id="GBytes" ada="Glib.Bytes" />

   <package id="GString" ada="Glib.String">
     <record ctype="GString"/>
     <method id="g_string_append_vprintf" bind="False"/> <!-- valist -->
     <method id="g_string_vprintf" bind="False"/> <!-- valist -->
     <method id="g_string_free_to_bytes" bind="False"/> <!-- requires GByte -->
   </package>

   <package id="GMenu" ada="Glib.Menu">
      <method id="g_menu_get_type" ada="Get_Type_Menu" />
   </package>

   <package id="GMenuItem" into="GMenu" ada="Glib.Menu">
      <method id="g_menu_item_get_type" ada="Get_Type_Menu_Item" />
   </package>

   <package id="GMenuModel" ada="Glib.Menu_Model">
      <method id="g_menu_model_get_type" ada="Get_Type_Menu_Model" />
   </package>

   <package id="GMenuAttributeIter" into="GMenuModel" ada="Glib.Menu_Model">
      <method id="g_menu_attribute_iter_get_type" ada="Get_Type_Menu_Attribute_Iter" />
      <method id="g_menu_attribute_iter_get_next" bind="False"/> <!-- parameter out String -->
   </package>

   <package id="GMenuLinkIter" into="GMenuModel" ada="Glib.Menu_Model">
      <method id="g_menu_link_iter_get_type" ada="Get_Type_Menu_Link_Iter" />
      <method id="g_menu_link_iter_get_next" bind="False"/> <!-- parameter out String -->
   </package>

   <package id="GApplication" ada="Glib.Application">
     <enum ctype="GApplicationFlags"/>
     <method id="g_application_get_dbus_connection" bind="False"/> <!-- requires DBus -->
     <method id="g_application_open" bind="False" /> <!-- requires GFile -->
     <method id="::open" bind="False"/>  <!--  requires GFile -->
   </package>

   <package id="GApplicationCommandLine" into="GApplication" ada="Glib.Application">
     <method id="g_application_command_line_create_file_for_arg" bind="False" /> <!-- requires GFile -->
     <method id="g_application_command_line_get_stdin" bind="False" /> <!-- requires GInputStream -->
     <method id="g_application_command_line_get_type" ada="Get_Type_Command_Line" />
     <method id="g_application_command_line_get_arguments">
       <parameter name="argc" ada="" default="null"/>
       <return-value transfer-ownership="full"/>
     </method>
     <extra>
       <spec>
   function Run
      (Self : not null access Gapplication_Record) return Gint;
   --  Same as above, but automatically sets argc argv from actual values.
       </spec>
       <body>
   gnat_argc : Interfaces.C.int;
   pragma Import (C, gnat_argc);

   gnat_argv : System.Address;
   pragma Import (C, gnat_argv);

   function Run
      (Self : not null access Gapplication_Record) return Gint
   is
      function Internal
         (Self : System.Address;
          Argc : Gint;
          Argv : System.Address) return Gint;
      pragma Import (C, Internal, "g_application_run");
   begin
      return Internal (Self.Get_Object, Gint (gnat_argc), gnat_argv);
   end Run;
       </body>
     </extra>
   </package>

   <package id="GOptionContext" ada="Glib.Option">
     <record ctype="GOptionGroup"/>
     <record ctype="GOptionEntry">
       <field name="flags" ctype="GOptionFlags"/>
     </record>
     <enum ctype="GOptionError"/>
     <enum ctype="GOptionArg"/>
     <enum ctype="GOptionFlags"/>
     <method id="g_option_context_new" ada="G_New"/>
     <method id="g_option_group_new" ada="G_New"/>
     <method id="g_option_context_parse" bind="False"/> <!-- Invalid binding generated -->
     <method id="g_option_context_add_main_entries">
       <parameter name="entries" type="GOption_Entry_Array"/>
     </method>
     <extra>
       <type ctype="array_of_GOptionEntry" ada="GOption_Entry_Array">
         type GOption_Entry_Array is array (Natural range &lt;&gt;) of GOption_Entry;
       </type>
       <with_spec pkg="Glib.Application"/>
       <with_spec pkg="Glib.Error"/>
       <with_spec pkg="Interfaces.C.Strings"/>
       <with_spec pkg="Gtkada.Bindings"/>
       <spec>
   Null_GOption_Entry : constant GOption_Entry;

   type Parse_Filter is access function (Param : String) return Boolean;
   --  Returns True if the parameter is to be passed from Command_Line to
   --  Goption_Context

   procedure Parse
     (Self         : Goption_Context;
      Command_Line : not null access Glib.Application.Gapplication_Command_Line_Record'Class;
      Filter       : Parse_Filter := null;
      Success      : out Boolean;
      Error        : out Glib.Error.GError);
   --  Parses the arguments given via Command_Line, removing from the arguments
   --  list all parsed switches.
       </spec>
       <spec private="True">
   Null_GOption_Entry : constant GOption_Entry :=
                          (ICS.Null_Ptr, Gchar(ASCII.NUL),
                           0, G_Option_Arg_None, System.Null_Address,
                           ICS.Null_Ptr, ICS.Null_Ptr);
       </spec>
       <body>
   -----------
   -- Parse --
   -----------

   procedure Parse
     (Self         : Goption_Context;
      Command_Line : not null access Glib.Application.Gapplication_Command_Line_Record'Class;
      Filter       : Parse_Filter := null;
      Success      : out Boolean;
      Error        : out Glib.Error.GError)
   is
      function Get_Args
         (Self : System.Address;
          Argc : access Glib.Gint) return chars_ptr_array_access;
      pragma Import (C, Get_Args, "g_application_command_line_get_arguments");

      function Internal
         (Self  : System.Address;
          Argc  : access Glib.Gint;
          Argv  : System.Address;
          Error : System.Address) return Glib.Gboolean;
      pragma Import (C, Internal, "g_option_context_parse");

      Argc : aliased Glib.Gint;
      Argv : chars_ptr_array_access;
      Err  : Glib.Error.GError;
      Ret  : Glib.Gboolean;

   begin
      Argv := Get_Args (Command_Line.Get_Object, Argc'Access);

      if Filter = null then
         Ret := Internal
           (Get_Object (Self),
            Argc'Access,
            Argv'Address,
            Err'Address);
      else
         declare
            Args : aliased ICS.chars_ptr_array := To_Chars_Ptr (Argv);
            Args_Access : System.Address;
            Idx  : aliased Glib.Gint := 1;
         begin
            --  Copy command name argument
            Args (0) := Argv (0);
            Idx := 1;

            for J in 1 .. Argc - 1 loop
               if Filter (ICS.Value (Argv (Interfaces.C.size_t (J)))) then
                  Args (Interfaces.C.size_t (Idx)) :=
                    Argv (Interfaces.C.size_t (J));
                  Idx := Idx + 1;
               end if;
            end loop;

            Args_Access := Args'Address;
            Ret := Internal
              (Get_Object (Self), Idx'Access, Args_Access'Address, Err'Address);
         end;
      end if;

      Error := Err;
      Success := Ret /= 0;
   end Parse;
       </body>
     </extra>
   </package>

   <package id="GAction" ada="Glib.Action">
   </package>

   <package id="GSimpleAction" ada="Glib.Simple_Action">
   </package>

   <package id="GActionGroup" ada="Glib.Action_Group">
   </package>

   <package id="GSimpleActionGroup" ada="Glib.Simple_Action_Group">
     <method id="g_simple_action_group_add_entries">
       <parameter name="entries" type="Glib.Action_Map.GAction_Entry_Array"/>
       <parameter name="n_entries" ada="" default="Entries'Length"/>
       <parameter name="user_data" default="System.Null_Address"/>
     </method>
   </package>

   <package id="GActionMap" ada="Glib.Action_Map">
     <record ctype="GActionEntry" private="true" />
     <method id="g_action_map_add_action_entries">
       <parameter name="n_entries" ada="" default="Entries'Length"/>
       <parameter name="user_data" default="System.Null_Address"/>
     </method>
     <extra>
       <type ctype="array_of_ActionEntry" ada="GAction_Entry_Array">
         type GAction_Entry_Array is array (Natural range &lt;&gt;) of GAction_Entry;
       </type>
       <with_spec pkg="Glib.Variant"/>
       <with_spec pkg="Glib.Simple_Action"/>
       <spec>
         type Activate_Callback is access procedure
            (Action    : access Glib.Simple_Action.Gsimple_Action;
             Parameter : Glib.Variant.Gvariant;
             Data      : System.Address);
         pragma Convention (C, Activate_Callback);

         type Change_State_Callback is access procedure
            (Action    : access Glib.Simple_Action.Gsimple_Action;
             Parameter : Glib.Variant.Gvariant;
             Data      : System.Address);
         pragma Convention (C, Change_State_Callback);

         function Build
            (Name           : String;
             Activate       : Activate_Callback := null;
             Parameter_Type : String := "";
             State          : String := "";
             Change_State   : Change_State_Callback := null)
            return GAction_Entry;
         --  Return a newly allocation action entry.
         --  This will be freed by the the action_map when needed.
         --
         --  Name is the name of the action.
         --  Activate is the callback to connect to the "activate" signal of
         --  the action.
         --  Parameter_Type is the type of the parameter that must be passed
         --  to the activate function for this action, given as a single
         --  Gvariant (or the empty string for no parameter).
         --  State is the initial state of this action, given in Gvariant
         --  text format. The state is parsed with no extra type information
         --  so type tags must be added to the string if they are necessary.
         --  Change_State is the callback for the "change-state" signal.
       </spec>
       <with_body pkg="Ada.Unchecked_Conversion" use="false" />
       <body>
         function Convert is new Ada.Unchecked_Conversion
            (Activate_Callback, System.Address);
         function Convert is new Ada.Unchecked_Conversion
            (Change_State_Callback, System.Address);

         function Build
            (Name           : String;
             Activate       : Activate_Callback := null;
             Parameter_Type : String := "";
             State          : String := "";
             Change_State   : Change_State_Callback := null)
            return GAction_Entry
         is
            P, S : chars_ptr := null_ptr;
         begin
            if Parameter_Type /= "" then
               P := New_String (Parameter_Type);
            end if;
            if State /= "" then
               S := New_String (State);
            end if;
            return GAction_Entry'
               (Name           => New_String (Name),
                Activate       => Convert (Activate),
                Parameter_Type => P,
                State          => S,
                Change_State   => Convert (Change_State),
                Padding        => &lt;&gt;);
         end Build;
       </body>
     </extra>
   </package>

   <package id="GtkApplication">
     <enum ctype="GtkApplicationInhibitFlags"/>
     <method id="gtk_application_get_windows" return="WidgetList"/>
   </package>

   <package id="GCancellable" ada="Glib.Cancellable">
     <method id="g_cancellable_make_pollfd" bind="False"/> <!-- requires GPoll_FD -->
   </package>

   <package id="GdkDeviceManager">
      <method id="gdk_device_manager_list_devices" return="DeviceList"/>
      <method id="::device-added" bind="False"/>
      <method id="::device-changed" bind="False"/>
      <method id="::device-removed" bind="False"/>
      <extra>
         <spec>
   function Get_Device_Manager
      (Self : not null access Gdk.Display.Gdk_Display_Record'Class)
      return Gdk.Device_Manager.Gdk_Device_Manager;
   --  Returns the Gdk.Device_Manager.Gdk_Device_Manager associated to
   --  Display.
   --  Since: gtk+ 3.0
         </spec>
         <body>
   function Get_Device_Manager
      (Self : not null access Gdk.Display.Gdk_Display_Record'Class)
       return Gdk.Device_Manager.Gdk_Device_Manager
   is
      function Internal (Self : System.Address) return System.Address;
      pragma Import (C, Internal, "gdk_display_get_device_manager");
      Stub_Gdk_Device_Manager : Gdk.Device_Manager.Gdk_Device_Manager_Record;
   begin
      return Gdk.Device_Manager.Gdk_Device_Manager (Get_User_Data (Internal (Get_Object (Self)), Stub_Gdk_Device_Manager));
   end Get_Device_Manager;
         </body>
      </extra>
   </package>

   <package id="GdkDisplay">
      <method id="gdk_display_get_app_launch_context" bind="False"/> <!-- requires GdkAppLaunchContext -->
      <method id="gdk_display_list_devices" bind="False"/> <!-- deprecated -->
      <method id="gdk_display_get_default_screen" bind="False"/> <!-- in gdk-screen.ads -->
      <method id="gdk_display_get_screen" bind="False"/> <!-- in gdk-screen.ads -->
      <method id="gdk_display_get_pointer" bind="False"/> <!-- deprecated by Gdk.Device.Get_Position -->
      <method id="gdk_display_warp_pointer" bind="False"/> <!-- deprecated, Gdk.Device.Warp -->
      <method id="gdk_display_get_device_manager" bind="False"/> <!-- in gdk-device_manager.ads -->
      <method id="gdk_display_device_is_grabbed" bind="False"/> <!-- circular dependency -->
      <method id="gdk_display_store_clipboard" bind="False"/> <!-- see below -->
      <method id="gdk_display_get_window_at_pointer" bind="False"/> <!-- see below -->
      <extra>
         <spec>
   procedure Store_Clipboard
      (Display          : not null access Gdk_Display_Record;
       Clipboard_Window : Gdk.Gdk_Window;
       Time             : Guint32;
       Targets          : Gdk.Types.Gdk_Atom_Array);
   --  Issues a request to the clipboard manager to store the clipboard data.
   --  On X11, this is a special program that works according to the
   --  freedesktop clipboard specification, available at &lt;ulink
   --  url="http://www.freedesktop.org/Standards/clipboard-manager-spec">
   --  http://www.freedesktop.org/Standards/clipboard-manager-spec&lt;/ulink&gt;>.
   --  Since: gtk+ 2.6
   --  "clipboard_window": a Gdk.Gdk_Window belonging to the clipboard owner
   --  "time_": a timestamp
   --  "targets": an array of targets that should be saved, or null if all
   --  available targets should be saved.
   --  "n_targets": length of the Targets array

   procedure Get_Window_At_Pointer
     (Display : access Gdk_Display_Record;
      Win_X   : out Glib.Gint;
      Win_Y   : out Glib.Gint;
      Win     : out Gdk.Gdk_Window);
   --  Obtains the window underneath the mouse pointer, returning the location
   --  of that window in Win_X, Win_Y. Returns nullif the window
   --  under the mouse pointer is not known to GDK (for example, belongs to
   --  another application).
   --  (Win_X, Win_Y) are relative to the origin of the window under the
   --  pointer.
   --
   --  Obsolescent: use Gdk.Device.Get_Window_At_Position instead.
         </spec>
         <body>
   procedure Store_Clipboard
     (Display          : not null access Gdk_Display_Record;
      Clipboard_Window : Gdk_Window;
      Time             : Guint32;
      Targets          : Gdk.Types.Gdk_Atom_Array)
   is
      procedure Internal
        (Display          : System.Address;
         Clipboard_Window : Gdk_Window;
         Time             : Guint32;
         Targets          : System.Address;
         N_Targets        : Gint);
      pragma Import (C, Internal, "gdk_display_store_clipboard");
   begin
      Internal (Get_Object (Display), Clipboard_Window, Time,
                Targets (Targets'First)'Address, Targets'Length);
   end Store_Clipboard;

   procedure Get_Window_At_Pointer
     (Display : access Gdk_Display_Record;
      Win_X   : out Gint;
      Win_Y   : out Gint;
      Win     : out Gdk_Window)
   is
      function Internal
        (Display : System.Address;
         Win_X   : access Gint;
         Win_Y   : access Gint) return Gdk_Window;
      pragma Import (C, Internal, "gdk_display_get_window_at_pointer");
      X, Y : aliased Gint;
   begin
      Win   := Internal (Get_Object (Display), X'Access, Y'Access);
      Win_X := X;
      Win_Y := Y;
   end Get_Window_At_Pointer;
         </body>
      </extra>
   </package>

   <!-- Below were added just for the sake of parsing the files to get information
        on their symbols, and properly substitute them in the docs.
        No file is generated from them.
   -->

   <package id="GtkNumerableIcon">
     <method id="gtk_numerable_icon_new" ada="Gtk_New"/>
     <method id="gtk_numerable_icon_new_with_style_context" ada="Gtk_New_With_Style_Context"/>
   </package>

  <package id="GtkIMContext">
    <!-- There are issues with binding string parameters for the following
         two methods: -->
    <method id="gtk_im_context_get_preedit_string" bind="False" />
    <method id="gtk_im_context_get_surrounding" bind="False" />
  </package>

</GIR>
