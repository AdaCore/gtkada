--- gdk/win32/gdkim-win32.c.old	Tue Jul 25 17:33:26 2000
+++ gdk/win32/gdkim-win32.c	Mon Feb  5 18:08:50 2001
@@ -253,71 +253,19 @@
 	       gint         dest_max)
 {
   guchar *cp, *end;
-  gint n;
-  
+
+  if (src_len == 0)
+    return 0;
+
+  /* Assume no UTF-8 encoding */
+
   cp = (guchar *) src;
   end = cp + src_len;
-  n = 0;
-  while (cp != end && dest != dest + dest_max)
-    {
-      gint i, mask = 0, len;
-      guchar c = *cp;
-
-      if (c < 0x80)
-	{
-	  len = 1;
-	  mask = 0x7f;
-	}
-      else if ((c & 0xe0) == 0xc0)
-	{
-	  len = 2;
-	  mask = 0x1f;
-	}
-      else if ((c & 0xf0) == 0xe0)
-	{
-	  len = 3;
-	  mask = 0x0f;
-	}
-      else if ((c & 0xf8) == 0xf0)
-	{
-	  len = 4;
-	  mask = 0x07;
-	}
-      else if ((c & 0xfc) == 0xf8)
-	{
-	  len = 5;
-	  mask = 0x03;
-	}
-      else if ((c & 0xfc) == 0xfc)
-	{
-	  len = 6;
-	  mask = 0x01;
-	}
-      else
-	return -1;
-
-      if (cp + len > end)
-	return -1;
-
-      *dest = (cp[0] & mask);
-      for (i = 1; i < len; i++)
-	{
-	  if ((cp[i] & 0xc0) != 0x80)
-	    return -1;
-	  *dest <<= 6;
-	  *dest |= (cp[i] & 0x3f);
-	}
-      if (*dest == -1)
-	return -1;
-
-      cp += len;
-      dest++;
-      n++;
-    }
-  if (cp != end)
-    return -1;
 
-  return n;
+  while (cp != end)
+    *dest++ = *cp++;
+
+  return src_len;
 }
 
 gint
@@ -337,57 +285,18 @@
 		    gint         src_len,
 		    gint         dest_max)
 {
-  wchar_t *wcp;
   guchar *cp, *end;
-  gint n;
-  
-  wcp = dest;
+
+  if (src_len == 0)
+    return 0;
+
+  /* Assume no UTF-8 encoding */
+
   cp = (guchar *) src;
   end = cp + src_len;
-  n = 0;
-  while (cp != end && wcp != dest + dest_max)
-    {
-      gint i, mask = 0, len;
-      guchar c = *cp;
-
-      if (c < 0x80)
-	{
-	  len = 1;
-	  mask = 0x7f;
-	}
-      else if ((c & 0xe0) == 0xc0)
-	{
-	  len = 2;
-	  mask = 0x1f;
-	}
-      else if ((c & 0xf0) == 0xe0)
-	{
-	  len = 3;
-	  mask = 0x0f;
-	}
-      else /* Other lengths are not possible with 16-bit wchar_t! */
-	return -1;
-
-      if (cp + len > end)
-	return -1;
-
-      *wcp = (cp[0] & mask);
-      for (i = 1; i < len; i++)
-	{
-	  if ((cp[i] & 0xc0) != 0x80)
-	    return -1;
-	  *wcp <<= 6;
-	  *wcp |= (cp[i] & 0x3f);
-	}
-      if (*wcp == 0xFFFF)
-	return -1;
-
-      cp += len;
-      wcp++;
-      n++;
-    }
-  if (cp != end)
-    return -1;
 
-  return n;
+  while (cp != end)
+    *dest++ = *cp++;
+
+  return src_len;
 }
--- gdk/win32/gdkpixmap-win32.c.old	Tue Sep 12 09:15:28 2000
+++ gdk/win32/gdkpixmap-win32.c	Tue Sep 12 09:52:44 2000
@@ -778,13 +778,13 @@
 	  if (mask && color->transparent)
 	    {
 	      if (cnt < xcnt)
-		gdk_draw_line (*mask, gc, cnt, ycnt, xcnt - 1, ycnt);
+		gdk_draw_line (*mask, gc, cnt, ycnt, xcnt - 2, ycnt);
 	      cnt = xcnt + 1;
 	    }
 	}
 
       if (mask && (cnt < xcnt))
-	gdk_draw_line (*mask, gc, cnt, ycnt, xcnt - 1, ycnt);
+	gdk_draw_line (*mask, gc, cnt, ycnt, xcnt - 2, ycnt);
     }
 
  error:
--- gdk/win32/gdkdrawable-win32.c.old	Tue Sep 12 10:01:22 2000
+++ gdk/win32/gdkdrawable-win32.c	Tue Feb  6 11:43:54 2001
@@ -759,7 +759,7 @@
   HDC hdc;
   HBRUSH hbr = NULL;
   gboolean ok = TRUE;
-  int i;
+  int i, x, y;
 
   GDK_NOTE (MISC, g_print ("gdk_win32_draw_segments: %#x destdc: (%d) %#x "
 			   "nsegs: %d\n",
@@ -803,17 +803,28 @@
     }
   else
     {
-      for (i = 0; i < nsegs; i++)
+      for (i = 0; i < nsegs; i++) 
 	{
 	  if (!MoveToEx (hdc, segs[i].x1, segs[i].y1, NULL))
 	    WIN32_API_FAILED ("MoveToEx");
 	  if (!LineTo (hdc, segs[i].x2, segs[i].y2))
 	    WIN32_API_FAILED ("LineTo #1");
-	  
+
 	  /* Draw end pixel */
 	  if (gc_data->pen_width == 1)
-	    if (!LineTo (hdc, segs[i].x2 + 1, segs[i].y2))
-	      WIN32_API_FAILED ("LineTo #2");
+	    {
+	      /* try to fix small lines that are off by one pixel */
+	      y = segs[i].y1 - segs[i].y2;
+	      y = y < 0 ? -y : y;
+
+	      if (y > 2)
+		x = segs[i].x2;
+	      else
+		x = segs[i].x2 + 1;
+
+	      if (!LineTo (hdc, x, segs[i].y2))
+		WIN32_API_FAILED ("LineTo #2");
+	    }
 	}
     }
   gdk_gc_postdraw (drawable, gc_private, GDK_GC_FOREGROUND|GDK_GC_BACKGROUND);
--- gdk/win32/gdkgc-win32.c.old	Sat Jun 10 18:56:02 2000
+++ gdk/win32/gdkgc-win32.c	Tue Feb  6 11:44:55 2001
@@ -322,7 +322,7 @@
 
   if (mask & GDK_GC_LINE_WIDTH)
     {
-      data->pen_width = values->line_width;
+      data->pen_width = values->line_width ? values->line_width : 1;
       data->values_mask |= GDK_GC_LINE_WIDTH;
       GDK_NOTE (MISC, (g_print ("%spw=%d", s, data->pen_width),
 		       s = ","));
@@ -517,6 +517,8 @@
   values->tile = data->tile;
   values->stipple = data->stipple;
 
+#if 0   /* This code does not work properly, desactivate it to avoid spurious
+           warnings */
   if (data->clip_region != NULL)
     {
       RECT rect;
@@ -547,6 +549,7 @@
       values->clip_mask = pixmap;
     }
   else
+#endif
     values->clip_mask = NULL;
   values->subwindow_mode = data->subwindow_mode;
   values->ts_x_origin = data->ts_x_origin;
@@ -628,8 +631,8 @@
 			 rectangle->x, rectangle->y));
       if ((data->clip_region =
 	   CreateRectRgn (rectangle->x, rectangle->y,
-			  rectangle->x + rectangle->width,
-			  rectangle->y + rectangle->height)) == NULL)
+			  rectangle->x + rectangle->width + 1,
+			  rectangle->y + rectangle->height + 1)) == NULL)
 	WIN32_API_FAILED ("CreateRectRgn");
 
       data->values_mask |= GDK_GC_CLIP_MASK;
@@ -979,7 +982,7 @@
       && data->clip_region != NULL
       && (data->values_mask & (GDK_GC_CLIP_X_ORIGIN | GDK_GC_CLIP_Y_ORIGIN)))
     OffsetRgn (data->clip_region,
-	       -data->clip_x_origin, -data->clip_y_origin);
+	       -(data->clip_x_origin - 1), -(data->clip_y_origin - 1));
   data->xgc = NULL;
 }
 
--- gtk/gtk.def.old	Fri Jun  9 18:55:38 2000
+++ gtk/gtk.def	Fri Jun  9 18:56:04 2000
@@ -1098,6 +1098,8 @@
 	gtk_table_set_homogeneous
 	gtk_table_set_row_spacing
 	gtk_table_set_row_spacings
+	gtk_target_list_add_table
+	gtk_target_list_find
 	gtk_target_list_new
 	gtk_target_list_unref
 	gtk_tearoff_menu_item_get_type
--- gtk/gtkwidget.c.old	Wed Jul 12 10:26:42 2000
+++ gtk/gtkwidget.c	Tue Feb  6 11:46:17 2001
@@ -2705,7 +2705,10 @@
   gint signal_num;
 
   g_return_val_if_fail (widget != NULL, TRUE);
-  g_return_val_if_fail (GTK_IS_WIDGET (widget), TRUE);
+  /* Avoid error messages under win32 that seem to be acceptable. */
+  /*g_return_val_if_fail (GTK_IS_WIDGET (widget), TRUE);*/
+  if (GTK_IS_WIDGET (widget) != TRUE)
+    return TRUE;
 
   gtk_widget_ref (widget);
   return_val = FALSE;
@@ -4868,7 +4871,10 @@
 gtk_widget_ref (GtkWidget *widget)
 {
   g_return_if_fail (widget != NULL);
-  g_return_if_fail (GTK_IS_WIDGET (widget));
+  /* Avoid error messages under win32 that seem to be acceptable. */
+  /*g_return_if_fail (GTK_IS_WIDGET (widget));*/
+  if (GTK_IS_WIDGET (widget) != TRUE)
+    return;
 
   gtk_object_ref ((GtkObject*) widget);
 }
@@ -4877,7 +4883,10 @@
 gtk_widget_unref (GtkWidget *widget)
 {
   g_return_if_fail (widget != NULL);
-  g_return_if_fail (GTK_IS_WIDGET (widget));
+  /* Avoid error messages under win32 that seem to be acceptable. */
+  /*g_return_if_fail (GTK_IS_WIDGET (widget));*/
+  if (GTK_IS_WIDGET (widget) != TRUE)
+    return;
 
   gtk_object_unref ((GtkObject*) widget);
 }
--- gtk/gtktext.c.old	Tue Sep 12 16:55:44 2000
+++ gtk/gtktext.c	Tue Feb  6 11:47:41 2001
@@ -5107,22 +5107,42 @@
       bitmap = text->line_arrow_bitmap;
       bitmap_width = line_arrow_width;
       bitmap_height = line_arrow_height;
+
+      /* Draw the arrow sign */
+      gdk_window_get_size (text->text_area, &width, NULL);
+      width -= LINE_WRAP_ROOM;
+
+      gdk_gc_set_ts_origin (text->gc,
+			    width + 1,
+			    height - bitmap_height - 1);
+      gdk_gc_set_foreground (text->gc, &GTK_WIDGET (text)->style->text[GTK_STATE_NORMAL]);
+      gdk_draw_line (text->text_area,
+		     text->gc, width + 1, height - 3, width + line_arrow_width,
+		     height - 3);
+      gdk_draw_line (text->text_area,
+		     text->gc, width + line_arrow_width - 2, height - 6,
+		     width + line_arrow_width + 1, height - 3);
+      gdk_draw_line (text->text_area,
+		     text->gc, width + line_arrow_width - 2, height,
+		     width + line_arrow_width + 1, height - 3);
+      gdk_gc_set_ts_origin (text->gc, 0, 0);
+      return;
     }
   
   gdk_window_get_size (text->text_area, &width, NULL);
   width -= LINE_WRAP_ROOM;
-  
+
   gdk_gc_set_stipple (text->gc,
 		      bitmap);
   
   gdk_gc_set_fill (text->gc, GDK_STIPPLED);
   
   gdk_gc_set_foreground (text->gc, &GTK_WIDGET (text)->style->text[GTK_STATE_NORMAL]);
-  
+
   gdk_gc_set_ts_origin (text->gc,
 			width + 1,
 			height - bitmap_height - 1);
-  
+ 
   gdk_draw_rectangle (text->text_area,
 		      text->gc,
 		      TRUE,
--- gtk/gtkfilesel.c.old	Mon Jan 15 11:07:42 2001
+++ gtk/gtkfilesel.c	Mon Jan 15 13:11:46 2001
@@ -1476,10 +1476,23 @@
   gint selection_index = -1;
   gint file_list_width;
   gint dir_list_width;
-  
+  GdkCursor *cursor = NULL;
+  GdkWindow *window;
+ 
   g_return_if_fail (fs != NULL);
   g_return_if_fail (GTK_IS_FILE_SELECTION (fs));
-  
+ 
+  window = GTK_WIDGET (fs)->window;
+
+  if (window != NULL)
+    {
+      cursor = gdk_cursor_new (GDK_WATCH);
+      gdk_window_set_cursor (window, cursor);
+      gdk_cursor_destroy (cursor);
+      cursor = gdk_cursor_new (GDK_LEFT_PTR);
+      gdk_flush ();
+    } 
+
   cmpl_state = (CompletionState*) fs->cmpl_state;
   poss = cmpl_completion_matches (rel_path, &rem_path, cmpl_state);
 
@@ -1487,6 +1500,12 @@
     {
       /* Something went wrong. */
       gtk_file_selection_abort (fs);
+
+      if (window != NULL)
+	{
+	  gdk_window_set_cursor (window, cursor);
+	  gdk_cursor_destroy (cursor);
+	}
       return;
     }
 
@@ -1629,6 +1648,11 @@
 	}
       
     }
+    if (window != NULL)
+      {
+	gdk_window_set_cursor (window, cursor);
+	gdk_cursor_destroy (cursor);
+      }
 }
 
 static void
