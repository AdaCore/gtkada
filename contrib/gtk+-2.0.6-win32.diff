This is a patch against Gtk+ 2.0.6 sources that fixes Windows specific
problems.

Mon Sep 16 12:39:09  2002	Florent Duguet <duguet@gnat.com>

	* pangowin32.c : optimization of the pango rendering through caching.

Mon Sep 16 12:03:54  2002	Arnaud Charlet <charlet@gnat.com>

	* pango/modules/basic/basic-win32.c: fix typo in module entry name, so
	that --with-included-modules works under Windows.

	* glib/build/win32/compile-resource: fix handling of errors

	* gtk+/build/win32/compile-resource: ditto

Fri Sep 13 14:56:43  2002	Florent Duguet <duguet@gnat.com>

	* gtk+/gdk/win32/gdkselection-win32.c: modifying the utf8 string
	clean-up for proper copy paste of strings with empty lines.

Thu Sep 12 18:03:02 2002	Florent Duguet <duguet@gnat.com>

	* gtk+/gdk/win32/gdkevents-win32.c: force an update when paint message
	is received this forces a refresh of zones which are actually
	invalidated and visible

Wed Sep 11 16:55:47  2002	Florent Duguet <duguet@gnat.com>

	* gtk+/gdk/win32/gdkgeometry-win32.c: ask for a repaint of the
	invalidate zone to address smoothness issues

#########################################
# Ctrl-C
#########################################

--- gtk+/gdk/win32/save/gdkevents-win32.c      Tue Jun  4 19:31:17 2002
+++ gtk+/gdk/win32/gdkevents-win32.c   Wed Jun  5 11:08:12 2002
@@ -886,6 +886,11 @@
 static guint
 vk_from_char (guint c)
 {
+  if ((c >= 1) && (c <=26))
+    {
+      return (c - 1 + 'A') ;
+    }
   switch (c)
     {
     case '\b':


#########################################
# always on top
#########################################

--- gtk+/gdk/win32/save/gdkwindow-win32.c      Fri May 31 12:18:44 2002
+++ gtk+/gdk/win32/gdkwindow-win32.c   Wed Jun  5 15:51:34 2002
@@ -1519,7 +1516,9 @@
   if (!SetParent (window_id, parent_id))
        WIN32_API_FAILED ("SetParent");
 #else /* make the modal window topmost instead */
-  if (!SetWindowPos (window_id, HWND_TOPMOST, 0, 0, 0, 0,
+  if (!SetWindowPos (window_id, HWND_NOTOPMOST, 0, 0, 0, 0,
                      SWP_NOMOVE | SWP_NOSIZE))
     WIN32_API_FAILED ("SetWindowPos");
 #endif



#########################################
# boxes display (e.g. tab characters)
#########################################

--- pango/pango/save/pangowin32.c   Thu Jun  6 11:27:34 2002
+++ pango/pango/pangowin32.c        Thu Jun  6 14:07:58 2002
@@ -240,7 +240,7 @@
 {
   HFONT old_hfont = NULL;
   HFONT hfont;
-  int i;
+  int i, idx ;
   guint16 *glyph_indexes;
   INT *dX;

@@ -255,16 +255,23 @@
   glyph_indexes = g_new (guint16, glyphs->num_glyphs);
   dX = g_new (INT, glyphs->num_glyphs);

+  idx = 0 ;
   for (i = 0; i <glyphs->num_glyphs; i++)
     {
-      glyph_indexes[i] = glyphs->glyphs[i].glyph;
-      dX[i] = glyphs->glyphs[i].geometry.width / PANGO_SCALE;
+      /* fduguet : skips the zero glyphs */
+      if (glyphs->glyphs[i].glyph != 0)
+        {
+          /* glyph is handeled */
+          glyph_indexes[idx] = glyphs->glyphs[i].glyph ;
+          dX[idx] = glyphs->glyphs[i].geometry.width / PANGO_SCALE ;
+          ++idx ;
+        }
     }

   ExtTextOutW (hdc, x, y,
               ETO_GLYPH_INDEX,
               NULL,
-              glyph_indexes, glyphs->num_glyphs,
+              glyph_indexes, idx,
               dX);

   SelectObject (hdc, old_hfont); /* restore */


#########################################
# memory leak - GdkImage not unreferenced
#########################################

--- gtk+/gdk/win32/save/gdkpixmap-win32.c Fri Jun 21 16:08:55 2002
+++ gtk+/gdk/win32/gdkpixmap-win32.c Fri Jun 21 16:10:25 2002
@@ -101,6 +101,7 @@
 {
   GdkPixmapImplWin32 *impl = GDK_PIXMAP_IMPL_WIN32 (object);
   GdkPixmap *wrapper = GDK_PIXMAP (GDK_DRAWABLE_IMPL_WIN32 (impl)->wrapper);
+  GdkImage *image = impl->image ;
 
   GDK_NOTE (PIXMAP, g_print ("gdk_pixmap_impl_win32_finalize: %p\n",
 			     GDK_PIXMAP_HBITMAP (wrapper)));
@@ -109,6 +110,9 @@
     WIN32_GDI_FAILED ("DeleteObject");
 
   gdk_win32_handle_table_remove (GDK_PIXMAP_HBITMAP (wrapper));
+
+  image->windowing_data = NULL ; /* avoiding loop in unref */
+  g_object_unref (image) ;
 
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }


#########################################
# memory leak - increasing size of translate_queue
#########################################

--- gtk+/gdk/win32/save/gdkgeometry-win32.c	2002-02-10 14:18:50.000000000 +0100
+++ gtk+/gdk/win32/gdkgeometry-win32.c	2002-09-02 18:38:33.000000000 +0200
@@ -770,6 +774,24 @@
 }
 
 static void
+gdk_window_queue_append (GdkWindow *window, GdkWindowQueueItem *item)
+{
+  int i ;
+
+  if (g_slist_length (translate_queue) >= 128)
+    {
+      GdkWindowImplWin32 * impl = GDK_WINDOW_IMPL_WIN32 (GDK_WINDOW_OBJECT (window)->impl) ;
+      GdkRegion * whole_region = gdk_region_rectangle (&impl->position_info.clip_rect) ;
+      _gdk_window_process_expose (window,
+                          GetCurrentTime (),
+                          whole_region ) ;
+      gdk_region_destroy (whole_region) ;
+    }
+
+  translate_queue = g_slist_append (translate_queue, item) ;
+}
+
+static void
 gdk_window_queue_translation (GdkWindow *window,
 			      gint       dx,
 			      gint       dy)
@@ -787,7 +809,8 @@
 			     dx, dy));
 
   gdk_drawable_ref (window);
-  translate_queue = g_slist_append (translate_queue, item);
+  /*translate_queue = g_slist_append (translate_queue, item);*/
+  gdk_window_queue_append (window, item);
 }
 
 gboolean
@@ -810,7 +833,8 @@
 			     area->extents.x1, area->extents.y1));
 
   gdk_drawable_ref (window);
-  translate_queue = g_slist_append (translate_queue, item);
+  /*translate_queue = g_slist_append (translate_queue, item);*/
+  gdk_window_queue_append (window, item);
 
   return TRUE;
 #else


#########################################
# linefeeds in copy-paste
#########################################

--- gtk+/gdk/win32/save/gdkproperty-win32.c Fri Jun 21 18:14:52 2002
+++ gtk+/gdk/win32/gdkproperty-win32.c Fri Jun 21 18:14:52 2002
@@ -305,7 +305,7 @@
 	  method = PLAIN_ASCII;
 	  size = nelements;
 	  for (i = 0; i < nelements; i++)
-	    if (*data == '\n')
+	    if (data[i] == '\n')
 	      size++;
 	  size++;
 	  GDK_NOTE (DND, g_print ("...as text: %.40s\n", data));
@@ -390,7 +390,7 @@
 	  cf = CF_TEXT;
 	  for (i = 0; i < nelements; i++)
 	    {
-	      if (*data == '\n')
+	      if (data[i] == '\n')
 		*ucptr++ = '\r';
 	      *ucptr++ = data[i];
 	    }
#########################################
# Selection problem B430-008
#########################################


--- gtk+/gtk/save/gtktextview.c	Wed Jul  3 12:42:28 2002
+++ gtk+/gtk/gtktextview.c	Wed Jul  3 11:52:51 2002
@@ -3866,8 +3866,11 @@
 
   text_view = GTK_TEXT_VIEW (widget);
 
+  /* 
   if (event->window != text_view->text_window->bin_window)
     return FALSE;
+  */
 
   if (event->button == 1)
     {

#########################################
# GtkTextView smoothness issues
#########################################

--- gtk+/gdk/win32/gdkgeometry-win32.c.old	2002-02-10 14:18:50.000000000 +0100
+++ gtk+/gdk/win32/gdkgeometry-win32.c	2002-09-11 16:21:14.000000000 +0200
@@ -134,14 +134,18 @@
 
       gdk_window_queue_translation (window, dx, dy);
 
-      if (!ScrollWindowEx (GDK_WINDOW_HWND (window),
+      if (ScrollWindowEx (GDK_WINDOW_HWND (window),
                            dx, dy, /* in: scroll offsets */
                            NULL, /* in: scroll rect, NULL == entire client area */
                            &clipRect, /* in: restrict to */
                            NULL, /* out: update region */
                            NULL, /* out: update rect */
                            SW_INVALIDATE))
-        WIN32_API_FAILED ("ScrollWindowEx");
+      {
+	  PostMessage (GDK_WINDOW_HWND (window), WM_PAINT, 0,0) ;
+      } else {
+          WIN32_API_FAILED ("ScrollWindowEx");
+      }
     }
 
   tmp_list = obj->children;
--- gtk+/gdk/win32/gdkevents-win32.c.old	2002-03-06 01:36:08.000000000 +0100
+++ gtk+/gdk/win32/gdkevents-win32.c	2002-09-12 17:37:07.000000000 +0200
@@ -2972,6 +2976,13 @@
 	    _gdk_window_process_expose (window, msg->time, &expose_rect);
 
 	    return_val = FALSE;
+          /* fduguet : force a process_all_updates to refresh the window 
+           * when receiving a paint message.
+	   * -> only do this if window is visible */
+          if (!GDK_WINDOW_DESTROYED (window))
+            if (gdk_window_is_visible (window))
+              gdk_window_process_updates (window, FALSE) ;
         }
       break;


--- gtk+/gdk/win32/gdkselection-win32.c.old	2002-02-10 14:18:50.000000000 +0100
+++ gtk+/gdk/win32/gdkselection-win32.c	2002-09-13 14:55:09.000000000 +0200
@@ -793,13 +793,19 @@
 
   while (*p)
     {
-      if (*p == '\r' || *p == '\n')
-	{
-	  p++;
-	  if (*p == '\r' || *p == '\n')
-	    p++;
-
-	  g_string_append_c (result, '\n');
+      if (*p == '\r')
+        {
+          p++ ;
+          if (*p == '\n')
+            {
+              p++ ;
+	      g_string_append_c (result, '\n') ; /* win32 new-line */
+	    }
+	}
+      else if (*p == '\n')
+        {
+          p++ ;
+	  g_string_append_c (result, '\n'); /* unix new-line */
 	}
       else
 	{
--- pango/modules/basic/basic-win32.c.orig	2002-09-15 00:56:30.000000000 +0200
+++ pango/modules/basic/basic-win32.c	2002-09-15 01:00:02.000000000 +0200
@@ -233,8 +233,8 @@
 /* The following three functions provide the public module API for
  * Pango
  */
-#ifdef MODULE_PREFIX
-#define MODULE_ENTRY(func) _pango_basic_##func
+#ifdef WIN32_MODULE_PREFIX
+#define MODULE_ENTRY(func) _pango_basic_win32_##func
 #else
 #define MODULE_ENTRY(func) func
 #endif
--- glib/build/win32/compile-resource.orig	2002-09-14 17:43:47.000000000 +0200
+++ glib/build/win32/compile-resource	2002-09-14 17:40:59.000000000 +0200
@@ -37,12 +37,10 @@
         buildnumber=0
     fi
 
-    m4 -DBUILDNUMBER=$buildnumber <$rcfile >$$.rc
-    windres $$.rc $resfile
+    m4 -DBUILDNUMBER=$buildnumber <$rcfile >$$.rc &&
+    windres $$.rc $resfile &&
     rm $$.rc
-    exit 0
+else
+    # Return failure
+    exit 1
 fi
-
-# Return failure
-
-exit 1
--- gtk+/build/win32/compile-resource.orig	2002-09-14 17:43:47.000000000 +0200
+++ gtk+/build/win32/compile-resource	2002-09-14 17:40:59.000000000 +0200
@@ -37,12 +37,10 @@
         buildnumber=0
     fi
 
-    m4 -DBUILDNUMBER=$buildnumber <$rcfile >$$.rc
-    windres $$.rc $resfile
+    m4 -DBUILDNUMBER=$buildnumber <$rcfile >$$.rc &&
+    windres $$.rc $resfile &&
     rm $$.rc
-    exit 0
+else
+    # Return failure
+    exit 1
 fi
-
-# Return failure
-
-exit 1

#########################################
# Optimization of rendering
#########################################
--- pango/pango/pangowin32.c.old	2002-03-25 21:33:28.000000000 +0100
+++ pango/pangowin32.c	2002-09-16 12:37:31.000000000 +0200
@@ -223,6 +223,7 @@
 
 /**
  * pango_win32_render:
+ * 	optimized version of pango_win32_render
  * @hdc:     the device context
  * @font:    the font in which to draw the string
  * @glyphs:  the glyph string to draw
@@ -230,9 +231,11 @@
  * @y:       the y position of baseline (in pixels)
  *
  * Render a PangoGlyphString onto a Windows DC
+ *
+ * returns the geometric width of the rendered string (computed while rendered)
  */
-void 
-pango_win32_render (HDC                hdc,
+static int
+pango_win32_render_offset (HDC                hdc,
 		    PangoFont         *font,
 		    PangoGlyphString  *glyphs,
 		    int                x, 
@@ -240,37 +243,77 @@
 {
   HFONT old_hfont = NULL;
   HFONT hfont;
-  int i;
+  int i, idx, rendered_width, tmp ;
   guint16 *glyph_indexes;
   INT *dX;
+  /* temporary static storage for runs of less than 256 glyphes */
+  static guint16	stat_glyph_indices [256] ;
+  static INT		stat_dX [256] ;
+  static HFONT		previous_set_font = NULL ;
+  /* */
 
-  g_return_if_fail (glyphs != NULL);
+  if (glyphs == NULL) return 0 ;
 
   hfont = pango_win32_get_hfont (font);
   if (!hfont)
-    return;
+    return 0;
 
-  old_hfont = SelectObject (hdc, hfont);
-		
-  glyph_indexes = g_new (guint16, glyphs->num_glyphs);
-  dX = g_new (INT, glyphs->num_glyphs);
+  if (previous_set_font != hfont)
+    {
+      old_hfont = SelectObject (hdc, hfont);
+      previous_set_font = hfont ;
+    }
+
+  if (glyphs->num_glyphs > 256)
+  {
+    glyph_indexes = g_new (guint16, glyphs->num_glyphs) ;
+    dX = g_new (INT, glyphs->num_glyphs) ;
+  } else {
+    glyph_indexes = stat_glyph_indices ;
+    dX = stat_dX ;
+  }
 
+  idx = 0 ;
+  rendered_width = 0 ;
   for (i = 0; i <glyphs->num_glyphs; i++)
     {
-      glyph_indexes[i] = glyphs->glyphs[i].glyph;
-      dX[i] = glyphs->glyphs[i].geometry.width / PANGO_SCALE;
+      /* prevent from displaying squares */
+      if (glyphs->glyphs[i].glyph != 0)
+        {
+          /* glyph is actually handled */
+	  tmp = glyphs->glyphs[i].geometry.width / PANGO_SCALE ;
+          glyph_indexes[idx] = glyphs->glyphs[i].glyph ;
+	  dX[idx] = tmp ;
+	  rendered_width += tmp ;
+	  ++idx ;
+	}
     }
 
   ExtTextOutW (hdc, x, y,
 	       ETO_GLYPH_INDEX,
 	       NULL,
-	       glyph_indexes, glyphs->num_glyphs,
+	       glyph_indexes, idx,
 	       dX);
 
-  SelectObject (hdc, old_hfont); /* restore */
-  g_free (glyph_indexes);
-  g_free (dX);
+  if (glyphs->num_glyphs > 256)
+  {
+    g_free (glyph_indexes);
+    g_free (dX);
+  }
+
+  return rendered_width ;
 }
+void
+pango_win32_render (HDC               *hdc,
+		    PangoFont         *font,
+		    PangoGlyphString  *glyphs,
+		    int                x, 
+		    int                y)
+{
+	/* ignore the offset */
+	int	tmp = pango_win32_render_offset (hdc, font, glyphs, x,y) ;
+}
+
 
 static void
 pango_win32_font_get_glyph_extents (PangoFont      *font,
@@ -531,6 +574,9 @@
 
 /**
  * pango_win32_render_layout_line:
+ *
+ * optimized version
+ * 
  * @hdc:       HDC to use for uncolored drawing
  * @line:      a #PangoLayoutLine
  * @x:         the x position of start of string (in pixels)
@@ -545,18 +591,14 @@
 				int               y)
 {
   GSList *tmp_list = line->runs;
-  PangoRectangle overall_rect;
-  PangoRectangle logical_rect;
   PangoRectangle ink_rect;
+  COLORREF saved_fg_color;
+  COLORREF saved_bk_color;
   
-  int x_off = 0;
+  int x_off = 0, tmp_off ;
 
-  pango_layout_line_get_extents (line,NULL, &overall_rect);
-  
   while (tmp_list)
     {
-      HBRUSH oldfg = NULL;
-      HBRUSH brush = NULL;
       POINT points[2];
       PangoUnderline uline = PANGO_UNDERLINE_NONE;
       PangoLayoutRun *run = tmp_list->data;
@@ -567,69 +609,60 @@
 
       pango_win32_get_item_properties (run->item, &uline, &fg_color, &fg_set, &bg_color, &bg_set);
 
-      if (uline == PANGO_UNDERLINE_NONE)
-	pango_glyph_string_extents (run->glyphs, run->item->analysis.font,
-				    NULL, &logical_rect);
-      else
-	pango_glyph_string_extents (run->glyphs, run->item->analysis.font,
-				    &ink_rect, &logical_rect);
-
       if (bg_set)
 	{
-	  HBRUSH oldbrush;
-
-	  brush = CreateSolidBrush (RGB ((bg_color.color.red + 128) >> 8,
-					 (bg_color.color.green + 128) >> 8,
-					 (bg_color.color.blue + 128) >> 8));
-	  oldbrush = SelectObject (hdc, brush);
-	  Rectangle (hdc, x + (x_off + logical_rect.x) / PANGO_SCALE,
-			  y + overall_rect.y / PANGO_SCALE,
-			  logical_rect.width / PANGO_SCALE,
-			  overall_rect.height / PANGO_SCALE);
-	  SelectObject (hdc, oldbrush);
-	  DeleteObject (brush);
+	  saved_bk_color = SetBkColor (hdc, 
+                       RGB ((bg_color.color.red + 128) >> 8,
+                           (bg_color.color.green + 128) >> 8,
+                           (bg_color.color.blue + 128) >> 8));
 	}
 
       if (fg_set)
 	{
-	  brush = CreateSolidBrush (RGB ((fg_color.color.red + 128) >> 8,
-					 (fg_color.color.green + 128) >> 8,
-					 (fg_color.color.blue + 128) >> 8));
-	  oldfg = SelectObject (hdc, brush);
-	}
+	  saved_fg_color = SetTextColor (hdc, 
+                       RGB ((fg_color.color.red + 128) >> 8,
+                            (fg_color.color.green + 128) >> 8,
+                            (fg_color.color.blue + 128) >> 8));
+	}
+
+      tmp_off = pango_win32_render_offset (hdc, run->item->analysis.font, 
+                                 run->glyphs, x + x_off / PANGO_SCALE, y);
+
+      if (uline != PANGO_UNDERLINE_NONE) 
+        {
+	  pango_glyph_string_extents (run->glyphs, run->item->analysis.font,
+                                      &ink_rect, NULL);
+          switch (uline)
+            {
+              case PANGO_UNDERLINE_NONE:
+                break;
+              case PANGO_UNDERLINE_SINGLE:
+                points[0].x = x + (x_off + ink_rect.x) / PANGO_SCALE - 1;
+                points[1].x = x + (x_off + ink_rect.x + ink_rect.width) / PANGO_SCALE;
+                points[0].y = points[1].y = y + 2;
+                Polyline (hdc, points, 2);
+                /* Fall through */
+              case PANGO_UNDERLINE_DOUBLE:
+                points[0].y = points[1].y = y + 4;
+                Polyline (hdc, points, 2);
+                break;
+              case PANGO_UNDERLINE_LOW:
+                points[0].x = x + (x_off + ink_rect.x) / PANGO_SCALE - 1;
+                points[0].y = points[1].y = y + (ink_rect.y + ink_rect.height) / PANGO_SCALE + 2;
+                points[1].x = x + (x_off + ink_rect.x + ink_rect.width) / PANGO_SCALE;
+                Polyline (hdc, points, 2);
+                break;
+            }
+        }
 
-      pango_win32_render (hdc, run->item->analysis.font, run->glyphs,
-			  x + x_off / PANGO_SCALE, y);
+      /* really necessary in the context of pango ?? */
+      if (bg_set)
+	      SetBkColor (hdc, saved_bk_color) ;
+      if (fg_set)
+	      SetTextColor (hdc, saved_fg_color) ;
 
-      switch (uline)
-	{
-	case PANGO_UNDERLINE_NONE:
-	  break;
-	case PANGO_UNDERLINE_DOUBLE:
-	  points[0].x = x + (x_off + ink_rect.x) / PANGO_SCALE - 1;
-	  points[0].y = points[1].y = y + 4;
-	  points[1].x = x + (x_off + ink_rect.x + ink_rect.width) / PANGO_SCALE;
-	  Polyline (hdc, points, 2);
-	  /* Fall through */
-	case PANGO_UNDERLINE_SINGLE:
-	  points[0].y = points[1].y = y + 2;
-	  Polyline (hdc, points, 2);
-	  break;
-	case PANGO_UNDERLINE_LOW:
-	  points[0].x = x + (x_off + ink_rect.x) / PANGO_SCALE - 1;
-	  points[0].y = points[1].y = y + (ink_rect.y + ink_rect.height) / PANGO_SCALE + 2;
-	  points[1].x = x + (x_off + ink_rect.x + ink_rect.width) / PANGO_SCALE;
-	  Polyline (hdc, points, 2);
-	  break;
-	}
+      x_off += tmp_off ;
 
-      if (fg_set)
-	{
-	  SelectObject (hdc, oldfg);
-	  DeleteObject (brush);
-	}
-      
-      x_off += logical_rect.width;
     }
 }
 
@@ -654,6 +687,16 @@
   int indent;
   int width;
   int y_offset = 0;
+  /* save colors */
+  COLORREF	saved_foreground_color ;
+  COLORREF	saved_background_color ;
+  HFONT		saved_font ;
+  /* */
+
+  saved_foreground_color = GetTextColor (hdc) ;
+  saved_background_color = GetTextColor (hdc) ;
+  saved_font = SelectObject (hdc, NULL) ;
+
 
   gboolean first = TRUE;
   
@@ -714,6 +757,13 @@
       y_offset += logical_rect.height;
       tmp_list = tmp_list->next;
     }
+
+  /* restore colors */
+  SetTextColor (hdc, saved_foreground_color) ;
+  SetTextColor (hdc, saved_background_color) ;
+  SelectObject (hdc, saved_font) ;
+  /* */
+
 }
