2011-05-16  Jerome Lambourg <lambourg@adacore.com>

        * modules/engines/ms-windows/xp_theme.h, xp_theme.c, msw_style.c: Fix
        the display of notebook tabs in the wimp engine.
        Submitted at https://bugzilla.gnome.org/show_bug.cgi?id=650300

2011-04-27	Nicolas Setton  <setton@adacore.com>

	* gdk/win32/gdkevents-win32.c (gdk_event_translate): Refine
	previous patch (for K307-005), propagating button press/releases
	to grabbed window only for events received outside of Gtk+
	windows. This prevents an offset problem when dragging
	scroll bar sliders.
	For K422-021.
	This chunk should be considered temporary and not to be submitted
	for the time being.

2011-04-27	Nicolas Setton  <setton@adacore.com>

	* gtk/gtkselection.c: (_gtk_selection_request): Properly fill the
	window information. Prevents a crash when copying selection to the
	clipboard under Windows.

2011-04-10      Arnaud Charlet  <charlet@adacore.com>

	* modules/engines/ms-windows/msw_style.c (setup_system_styles): Fix
	typo.
	Submitted at https://bugzilla.gnome.org/show_bug.cgi?id=647460

	(draw_tab_button): Always use custom code to draw tab.
	Submitted at https://bugzilla.gnome.org/show_bug.cgi?id=647461

2011-04-06	Nicolas Setton  <setton@adacore.com>

	* gdk/win32/gdkevents-win32.c (doesnt_want_button_release,
	doesnt_want_button_press): reintroduce subprograms.
	(gdk_event_translate): Before generating GDK_BUTTON_PRESS and
	GDK_BUTTON_RELEASE, call propagate to switch window to the
	window, if any, which is currently grabbing the events.
	Fixes K307-005.

	Submitted at https://bugzilla.gnome.org/show_bug.cgi?id=646930

2010-10-21      Nicolas Setton  <setton@adacore.com>

	* gdk/win32/gdkevents-win32.c (generate_button_event): Remove wrong
	call to _gdk_event_button_generate.
	Fixes JA21-010.

2010-02-01      Arnaud Charlet  <charlet@adacore.com>

	* gdk/win32/gdkdrawable-win32.c	(draw_segments): Ignore LineTo
	errors.

2009-09-29      Nicolas Setton  <setton@adacore.com>

	* gdk/win32/gdkevents-win32.c:
	Protect against infinite loop in the events processing queue, in cases
	where the translation of events cause the same events to be
	regenerated. This protects against two cases of loops that have been
	observed under Citrix.
	(gdk_event_translate): Protect against reentry on move or size events
	that are being re-posted by Gtk+, which happens when a Citrix window
	receives move events but has never been mapped to a Gtk+ window.
	(_gdk_event_queue): After having processed all the messages, reset the
	reentry flags.

2009-07-20	Arnaud Charlet	<charlet@adacore.com>

	* configure: Work around ^M handling on cygwin with igncr

2006-06-05	Arnaud Charlet	<charlet@adacore.com>

	* gdk/win32/gdkgc-win32.c (_gdk_win32_gdkregion_to_hrgn): Disable
	harmless warning which is occurring often with Gtk+ >= 2.8.18

2002-11-25	Arnaud Charlet	<charlet@adacore.com>

	* gdk/win32/gdkevents-win32.c (handle_wm_paint): Force an update when
	paint message is received, otherwise windows in background are not
	immediately refreshed when moving a modal window on top of them.

	* gdk/Makefile.in: Remove gdk-win32res.o dependency,
	since we do not want to use the default Gtk+ icon.

--- gdk/win32/gdkevents-win32.c.old	2009-12-22 12:37:10.468370000 +0100
+++ gdk/win32/gdkevents-win32.c	2010-01-06 17:04:42.923000000 +0100
@@ -1692,6 +1692,12 @@ handle_wm_paint (MSG        *msg,
     _gdk_window_invalidate_for_expose (window, update_region);
   gdk_region_destroy (update_region);
 
+  /* Force a process_updates to refresh visible windows
+   * when receiving a paint message. */
+
+  if (!GDK_WINDOW_DESTROYED (window) && gdk_window_is_visible (window))
+    gdk_window_process_updates (window, FALSE);
+
   DeleteObject (hrgn);
 }
 
--- gdk/Makefile.in.orig	2010-09-23 16:27:22.000000000 +0200
+++ gdk/Makefile.in	2010-10-08 11:06:41.724000000 +0200
@@ -664,8 +664,8 @@ libgdk_quartz_2_0_la_LIBADD = quartz/lib
 libgdk_quartz_2_0_la_LDFLAGS = $(LDADD)
 libgdk_win32_2_0_la_SOURCES = $(common_sources) gdkkeynames.c
 libgdk_win32_2_0_la_LIBADD = win32/libgdk-win32.la $(GDK_DEP_LIBS)
-libgdk_win32_2_0_la_DEPENDENCIES = win32/libgdk-win32.la win32/rc/gdk-win32-res.o gdk.def
-libgdk_win32_2_0_la_LDFLAGS = -Wl,win32/rc/gdk-win32-res.o -export-symbols $(srcdir)/gdk.def $(LDADD)
+libgdk_win32_2_0_la_DEPENDENCIES = win32/libgdk-win32.la gdk.def
+libgdk_win32_2_0_la_LDFLAGS = -export-symbols $(srcdir)/gdk.def $(LDADD)
 @HAVE_INTROSPECTION_TRUE@introspection_files = $(filter-out \
 @HAVE_INTROSPECTION_TRUE@	gdkkeysyms-compat.h, \
 @HAVE_INTROSPECTION_TRUE@	$(gdk_public_h_sources)) \
--- gdk/win32/gdkgc-win32.c.orig
+++ gdk/win32/gdkgc-win32.c	2006-06-05 14:56:59.515625000 +0200
@@ -1160,8 +1160,7 @@ _gdk_win32_gdkregion_to_hrgn (GdkRegion 
       if (rect->bottom > rgndata->rdh.rcBound.bottom)
 	rgndata->rdh.rcBound.bottom = rect->bottom;
     }
-  if ((hrgn = ExtCreateRegion (NULL, nbytes, rgndata)) == NULL)
-    WIN32_API_FAILED ("ExtCreateRegion");
+  hrgn = ExtCreateRegion (NULL, nbytes, rgndata);
 
   g_free (rgndata);
 
--- configure.old	2009-02-23 15:54:03.650263500 +0100
+++ configure	2009-02-23 15:54:54.711263500 +0100
@@ -36969,6 +36971,7 @@ if test "$ac_cs_awk_cr" = "a${ac_cr}b"; 
 else
   ac_cs_awk_cr=$ac_cr
 fi
+ac_cs_awk_cr=$ac_cr
 
 echo 'BEGIN {' >"$tmp/subs1.awk" &&
 _ACEOF
*** gdk/win32/gdkevents-win32.c.before_patch	2009-09-22 20:06:09.000000000 +0200
--- gdk/win32/gdkevents-win32.c	2009-09-24 16:25:23.000000000 +0200
*************** static UINT client_message;
*** 133,138 ****
--- 133,144 ----
  static UINT got_gdk_events_message;
  static HWND modal_win32_dialog = NULL;
  
+ /* The following variables are used to protect against re-entry in the
+    _gdk_event_queue main loop, which can happen under Citrix. */
+ static gint activate_events = 0;
+ static gint move_or_size_events = 0;
+ static gint reentry_threshold = 3;
+ 
  #if 0
  static HKL latin_locale = NULL;
  #endif
*************** gdk_event_translate (MSG  *msg,
*** 2324,2330 ****
  	   */
  	  GDK_NOTE (EVENTS, g_print (" (posted)"));
  	
! 	  PostMessageW (msg->hwnd, msg->message, msg->wParam, msg->lParam);
  	}
        else if (msg->message == WM_CREATE)
  	{
--- 2330,2340 ----
  	   */
  	  GDK_NOTE (EVENTS, g_print (" (posted)"));
  	
! 	  /* Do not post this message if we have posted it too many times 
! 	     within the same event loop. */
! 	  move_or_size_events += 1;
! 	  if (move_or_size_events < reentry_threshold)
! 	     PostMessageW (msg->hwnd, msg->message, msg->wParam, msg->lParam);
  	}
        else if (msg->message == WM_CREATE)
  	{
*************** gdk_event_translate (MSG  *msg,
*** 3695,3701 ****
        if (is_modally_blocked (window) && LOWORD (msg->wParam) == WA_ACTIVE)
  	{
  	  GdkWindow *modal_current = _gdk_modal_current ();
! 	  SetActiveWindow (GDK_WINDOW_HWND (modal_current));
  	  *ret_valp = 0;
  	  return_val = TRUE;
  	  break;
--- 3705,3717 ----
        if (is_modally_blocked (window) && LOWORD (msg->wParam) == WA_ACTIVE)
  	{
  	  GdkWindow *modal_current = _gdk_modal_current ();
! 	  
! 	  /* Do not change the active window if we have done this too many
! 	     times within the same event loop. */
! 	  activate_events += 1;
! 	  if (activate_events < reentry_threshold)
! 	      SetActiveWindow (GDK_WINDOW_HWND (modal_current));
! 	    
  	  *ret_valp = 0;
  	  return_val = TRUE;
  	  break;
*************** _gdk_events_queue (GdkDisplay *display)
*** 3775,3780 ****
--- 3791,3801 ----
        TranslateMessage (&msg);
        DispatchMessageW (&msg);
      }
+   
+    /* we are leaving the events queue processing: reset flags that protect
+       against re-entry */
+    activate_events = 0;
+    move_or_size_events = 0;
  }
  
  static gboolean
--- gdk/win32/gdkdrawable-win32.c.old	2010-01-31 18:48:07.679800000 +0100
+++ gdk/win32/gdkdrawable-win32.c	2010-01-31 18:48:32.429800000 +0100
@@ -1246,7 +1246,7 @@ draw_segments (GdkGCWin32 *gcwin32,
 
 	  GDK_NOTE (DRAW, g_print (" +%d+%d..+%d+%d", x1, y1, x2, y2));
 	  GDI_CALL (MoveToEx, (hdc, x1, y1, NULL)) &&
-	    GDI_CALL (LineTo, (hdc, x2, y2));
+	    LineTo (hdc, x2, y2);
 	}
 
       GDK_NOTE (DRAW, g_print ("\n"));
--- gdk/win32/gdkevents-win32.c.old	2011-04-05 09:23:55.913000000 +0200
+++ gdk/win32/gdkevents-win32.c	2011-04-05 17:07:19.272000000 +0200
@@ -1727,8 +1734,10 @@ generate_button_event (GdkEventType type
 
   append_event (event);
 
+#if 0
   if (type == GDK_BUTTON_PRESS)
     _gdk_event_button_generate (_gdk_display, event);
+#endif
 }
 
 static void
--- gdk/win32/gdkevents-win32.c.original	2011-04-06 09:26:44.000000000 -0700
+++ gdk/win32/gdkevents-win32.c	2011-04-06 09:29:45.000000000 -0700
@@ -1459,6 +1459,20 @@ doesnt_want_char (gint mask,
   return !(mask & (GDK_KEY_PRESS_MASK | GDK_KEY_RELEASE_MASK));
 }
 
+static gboolean
+doesnt_want_button_release (gint mask,
+			    MSG *msg)
+{
+  return !(mask & GDK_BUTTON_RELEASE_MASK);
+}
+
+static gboolean
+doesnt_want_button_press (gint mask,
+			  MSG *msg)
+{
+  return !(mask & GDK_BUTTON_PRESS_MASK);
+}
+
 static void
 handle_configure_event (MSG       *msg,
 			GdkWindow *window)
@@ -2284,8 +2298,17 @@ gdk_event_translate (MSG  *msg,
 	break;
 
       /* TODO_CSW? Emulate X11's automatic active grab */
-      generate_button_event (GDK_BUTTON_PRESS, button,
-			     window, msg);
+      
+      grab = _gdk_display_get_last_pointer_grab (_gdk_display);
+
+      if (grab != NULL && 
+	  !propagate (&window, msg,
+		      grab->window, grab->owner_events, grab->event_mask,
+		      doesnt_want_button_press, TRUE))
+	;
+      else if (!GDK_WINDOW_DESTROYED (window))
+	  generate_button_event (GDK_BUTTON_PRESS, button,
+				 window, msg);
 
       return_val = TRUE;
       break;
@@ -2323,8 +2346,15 @@ gdk_event_translate (MSG  *msg,
 	}
 #endif
 
-      generate_button_event (GDK_BUTTON_RELEASE, button,
-			     window, msg);
+      grab = _gdk_display_get_last_pointer_grab (_gdk_display);
+
+      if (grab != NULL && 
+	  !propagate (&window, msg,
+		      grab->window, grab->owner_events, grab->event_mask,
+		      doesnt_want_button_release, TRUE))
+	;
+      else if (!GDK_WINDOW_DESTROYED (window))
+	generate_button_event (GDK_BUTTON_RELEASE, button, window, msg);
 
       return_val = TRUE;
       break;
--- modules/engines/ms-windows/msw_style.c.old
+++ modules/engines/ms-windows/msw_style.c
@@ -849,7 +849,7 @@ setup_system_styles (GtkStyle *style)
   sys_color_to_gtk_color (XP_THEME_CLASS_TEXT, COLOR_GRAYTEXT,
 			  &style->fg[GTK_STATE_INSENSITIVE]);
   sys_color_to_gtk_color (XP_THEME_CLASS_BUTTON, COLOR_BTNTEXT,
-        		  &style->bg[GTK_STATE_ACTIVE]);
+        		  &style->fg[GTK_STATE_ACTIVE]);
   sys_color_to_gtk_color (XP_THEME_CLASS_WINDOW, COLOR_WINDOWTEXT,
 			  &style->fg[GTK_STATE_PRELIGHT]);
 
-@@ -2590,7 +2590,9 @@ draw_tab_button (GtkStyle *style,
- 		 const gchar *detail,
- 		 gint x, gint y, gint width, gint height, gint gap_side)
- {
-+#if 0
-   if (gap_side == GTK_POS_TOP || gap_side == GTK_POS_BOTTOM)
-+#endif
-     {
-       /* experimental tab-drawing code from mozilla */
-       RECT rect;
--- gtk/gtkselection.c.orig	2011-04-26 11:45:47.000000000 +0200
+++ gtk/gtkselection.c	2011-04-26 12:05:34.000000000 +0200
@@ -2280,7 +2280,8 @@ _gtk_selection_request (GtkWidget *widge
 #ifdef GDK_WINDOWING_X11
   info->requestor = gdk_x11_window_foreign_new_for_display (display, event->requestor);
 #else
-  info->requestor = NULL;
+  info->requestor = gdk_window_lookup_for_display (display,
+						   event->requestor);
 #endif
 
   /* Determine conversions we need to perform */
--- gdk/win32/gdkevents-win32.c.intermediate	2011-04-26 16:44:14.000000000 +0200
+++ gdk/win32/gdkevents-win32.c	2011-04-27 13:54:12.000000000 +0200
@@ -2301,7 +2301,8 @@ gdk_event_translate (MSG  *msg,
       
       grab = _gdk_display_get_last_pointer_grab (_gdk_display);
 
-      if (grab != NULL && 
+      if (window == _gdk_root && 
+          grab != NULL && 
 	  !propagate (&window, msg,
 		      grab->window, grab->owner_events, grab->event_mask,
 		      doesnt_want_button_press, TRUE))
@@ -2348,7 +2349,8 @@ gdk_event_translate (MSG  *msg,
 
       grab = _gdk_display_get_last_pointer_grab (_gdk_display);
 
-      if (grab != NULL && 
+      if (window == _gdk_root && 
+          grab != NULL && 
 	  !propagate (&window, msg,
 		      grab->window, grab->owner_events, grab->event_mask,
 		      doesnt_want_button_release, TRUE))
*** modules/engines/ms-windows/msw_style.c.old	2011-02-19 15:31:37.000000000 +0100
--- modules/engines/ms-windows/msw_style.c	2011-05-16 08:15:33.897461000 +0200
***************
*** 2347,2352 ****
--- 2347,2414 ----
      DrawEdge (hdc, &shadeRect, EDGE_RAISED, BF_SOFT | shadeFlag);
  }
  
+ static void
+ get_notebook_tab_position (GtkNotebook *notebook, gboolean *start, gboolean *end)
+ {
+   /* default value */
+   *start = TRUE;
+   *end = FALSE;
+ 
+   gboolean found_tabs = FALSE;
+   gint i, n_pages;
+   
+   n_pages = gtk_notebook_get_n_pages (notebook);
+   for (i = 0; i < n_pages; i++) {
+     GtkWidget *tab_child;
+     GtkWidget *tab_label;
+     gboolean expand;
+     GtkPackType pack_type;
+     
+     tab_child = gtk_notebook_get_nth_page (notebook, i);
+     
+     /* Skip invisible tabs */
+     tab_label = gtk_notebook_get_tab_label (notebook, tab_child);
+     if (!tab_label || !GTK_WIDGET_VISIBLE (tab_label))
+       continue;
+     /* This is the same what the notebook does internally. */
+     if (tab_label && !gtk_widget_get_child_visible (tab_label)) {
+       /* One child is hidden because scroll arrows are present.
+        * So both corners are rounded. */
+       *start = FALSE;
+       *end = FALSE;
+       return;
+     }
+     
+     gtk_notebook_query_tab_label_packing 
+       (notebook, tab_child,
+        &expand,
+        NULL, /* don't need fill */
+        &pack_type);
+     
+     if (!found_tabs) {
+       //  First tab found
+       found_tabs = TRUE;
+       if (gtk_notebook_get_current_page (notebook) == i) {
+         *start = TRUE;
+       } else {
+         *start = FALSE;
+       }
+     }
+     
+     if (gtk_notebook_get_current_page (notebook) == i) {
+       if (expand) {
+         *end = TRUE;
+       } else {
+         *end = FALSE;
+         return;
+       }
+     } else {
+       *end = FALSE; 
+       return;
+     }
+   }
+ }
+ 
  static gboolean
  draw_themed_tab_button (GtkStyle *style,
  			GdkWindow *window,
***************
*** 2356,2576 ****
  			gint width, gint height, gint gap_side)
  {
    GdkPixmap *pixmap = NULL;
-   gint border_width =
-     gtk_container_get_border_width (GTK_CONTAINER (notebook));
-   GtkWidget *widget = GTK_WIDGET (notebook);
    GdkRectangle draw_rect, clip_rect;
-   GdkPixbufRotation rotation = GDK_PIXBUF_ROTATE_NONE;
    cairo_t *cr;
! 
!   if (gap_side == GTK_POS_TOP)
!     {
!       int widget_right;
! 
!       if (state_type == GTK_STATE_NORMAL)
! 	{
! 	  draw_rect.x = x;
! 	  draw_rect.y = y;
! 	  draw_rect.width = width + 2;
! 	  draw_rect.height = height;
! 
! 	  clip_rect = draw_rect;
! 	  clip_rect.height--;
! 	}
!       else
! 	{
! 	  draw_rect.x = x + 2;
! 	  draw_rect.y = y;
! 	  draw_rect.width = width - 2;
! 	  draw_rect.height = height - 2;
! 	  clip_rect = draw_rect;
! 	}
! 
!       /* If we are currently drawing the right-most tab, and if that tab is the selected tab... */
!       widget_right = widget->allocation.x + widget->allocation.width - border_width - 2;
! 
!       if (draw_rect.x + draw_rect.width >= widget_right)
! 	{
! 	  draw_rect.width = clip_rect.width = widget_right - draw_rect.x;
! 	}
!     }
!   if (gap_side == GTK_POS_BOTTOM)
!     {
!       int widget_right;
! 
!       if (state_type == GTK_STATE_NORMAL)
! 	{
! 	  draw_rect.x = x;
! 	  draw_rect.y = y;
! 	  draw_rect.width = width + 2;
! 	  draw_rect.height = height;
! 
! 	  clip_rect = draw_rect;
! 	}
!       else
! 	{
! 	  draw_rect.x = x + 2;
! 	  draw_rect.y = y + 2;
! 	  draw_rect.width = width - 2;
! 	  draw_rect.height = height - 2;
! 	  clip_rect = draw_rect;
! 	}
! 
!       /* If we are currently drawing the right-most tab, and if that tab is the selected tab... */
!       widget_right = widget->allocation.x + widget->allocation.width - border_width - 2;
! 
!       if (draw_rect.x + draw_rect.width >= widget_right)
! 	{
! 	  draw_rect.width = clip_rect.width = widget_right - draw_rect.x;
! 	}
! 
!       rotation = GDK_PIXBUF_ROTATE_UPSIDEDOWN;
      }
!   else if (gap_side == GTK_POS_LEFT)
!     {
!       int widget_bottom;
! 
!       if (state_type == GTK_STATE_NORMAL)
! 	{
! 	  draw_rect.x = x;
! 	  draw_rect.y = y;
! 	  draw_rect.width = width;
! 	  draw_rect.height = height + 2;
! 
! 	  clip_rect = draw_rect;
! 	  clip_rect.width--;
! 	}
!       else
! 	{
! 	  draw_rect.x = x;
! 	  draw_rect.y = y + 2;
! 	  draw_rect.width = width - 2;
! 	  draw_rect.height = height - 2;
! 	  clip_rect = draw_rect;
! 	}
! 
!       /* If we are currently drawing the bottom-most tab, and if that tab is the selected tab... */
!       widget_bottom = widget->allocation.x + widget->allocation.height - border_width - 2;
  
!       if (draw_rect.y + draw_rect.height >= widget_bottom)
! 	{
! 	  draw_rect.height = clip_rect.height = widget_bottom - draw_rect.y;
! 	}
  
!       rotation = GDK_PIXBUF_ROTATE_COUNTERCLOCKWISE;
!     }
!   else if (gap_side == GTK_POS_RIGHT)
      {
!       int widget_bottom;
! 
!       if (state_type == GTK_STATE_NORMAL)
! 	{
! 	  draw_rect.x = x + 1;
! 	  draw_rect.y = y;
! 	  draw_rect.width = width;
! 	  draw_rect.height = height + 2;
! 
! 	  clip_rect = draw_rect;
! 	  clip_rect.width--;
! 	}
!       else
! 	{
! 	  draw_rect.x = x + 2;
! 	  draw_rect.y = y + 2;
! 	  draw_rect.width = width - 2;
! 	  draw_rect.height = height - 2;
! 	  clip_rect = draw_rect;
! 	}
! 
!       /* If we are currently drawing the bottom-most tab, and if that tab is the selected tab... */
!       widget_bottom = widget->allocation.x + widget->allocation.height - border_width - 2;
! 
!       if (draw_rect.y + draw_rect.height >= widget_bottom)
! 	{
! 	  draw_rect.height = clip_rect.height = widget_bottom - draw_rect.y;
! 	}
! 
!       rotation = GDK_PIXBUF_ROTATE_CLOCKWISE;
      }
  
!   if (gap_side == GTK_POS_TOP)
      {
!       if (!xp_theme_draw (window, XP_THEME_ELEMENT_TAB_ITEM, style,
! 			  draw_rect.x, draw_rect.y,
! 			  draw_rect.width, draw_rect.height,
! 			  state_type, &clip_rect))
  	{
  	  return FALSE;
  	}
      }
    else
      {
!       GdkPixbuf *pixbuf;
!       GdkPixbuf *rotated;
  
!       if (gap_side == GTK_POS_LEFT || gap_side == GTK_POS_RIGHT)
! 	{
! 	  pixmap = gdk_pixmap_new (window, clip_rect.height, clip_rect.width, -1);
! 
! 	  if (!xp_theme_draw (pixmap, XP_THEME_ELEMENT_TAB_ITEM, style,
! 			      draw_rect.y - clip_rect.y, draw_rect.x - clip_rect.x,
! 			      draw_rect.height, draw_rect.width, state_type, 0))
! 	    {
! 	      g_object_unref (pixmap);
! 	      return FALSE;
! 	    }
! 
! 	  pixbuf = gdk_pixbuf_get_from_drawable (NULL, pixmap, NULL, 0, 0, 0, 0,
! 						 clip_rect.height, clip_rect.width);
! 	  g_object_unref (pixmap);
! 	}
!       else
  	{
- 	  pixmap = gdk_pixmap_new (window, clip_rect.width, clip_rect.height, -1);
- 
- 	  if (!xp_theme_draw (pixmap, XP_THEME_ELEMENT_TAB_ITEM, style,
- 			      draw_rect.x - clip_rect.x, draw_rect.y - clip_rect.y,
- 			      draw_rect.width, draw_rect.height, state_type, 0))
- 	    {
- 	      g_object_unref (pixmap);
- 	      return FALSE;
- 	    }
- 
- 	  pixbuf = gdk_pixbuf_get_from_drawable (NULL, pixmap, NULL, 0, 0, 0, 0,
- 						 clip_rect.width, clip_rect.height);
  	  g_object_unref (pixmap);
  	}
  
!       rotated = gdk_pixbuf_rotate_simple (pixbuf, rotation);
!       g_object_unref (pixbuf);
!       pixbuf = rotated;
! 
!       // XXX - This is really hacky and evil.  When we're drawing the left-most tab
!       //       while it is active on a bottom-oriented notebook, there is one white
!       //       pixel at the top.  There may be a better solution than this if someone
!       //       has time to discover it.
!       if (gap_side == GTK_POS_BOTTOM && state_type == GTK_STATE_NORMAL
! 	  && x == widget->allocation.x)
! 	{
! 	  int rowstride = gdk_pixbuf_get_rowstride (pixbuf);
! 	  int n_channels = gdk_pixbuf_get_n_channels (pixbuf);
! 	  int psub = 0;
! 
! 	  guchar *pixels = gdk_pixbuf_get_pixels (pixbuf);
! 	  guchar *p = pixels + rowstride;
! 
! 	  for (psub = 0; psub < n_channels; psub++)
! 	    {
! 	      pixels[psub] = p[psub];
! 	    }
! 	}
  
!       cr = gdk_cairo_create (window);
!       gdk_cairo_set_source_pixbuf (cr, pixbuf, clip_rect.x, clip_rect.y);
!       cairo_paint (cr);
!       cairo_destroy (cr);
!       g_object_unref (pixbuf);
!     }
  
    return TRUE;
  }
--- 2418,2532 ----
  			gint width, gint height, gint gap_side)
  {
    GdkPixmap *pixmap = NULL;
    GdkRectangle draw_rect, clip_rect;
    cairo_t *cr;
!   gboolean start, stop;
!   XpThemeElement element;
!   GdkPixbuf *pixbuf;
!   GdkPixbuf *rotated;
! 
!   get_notebook_tab_position (notebook, &start, &stop);
!   if (start && stop) {
!     // Both edges of the notebook are covered by the item
!     element = XP_THEME_ELEMENT_TAB_ITEM_BOTH_EDGES;
!   } else if (start) {
!     // The start edge is covered by the item
!     element = XP_THEME_ELEMENT_TAB_ITEM_LEFT_EDGE;
!   } else if (stop) {
!     //  the stop edge is reached by the item
!     element = XP_THEME_ELEMENT_TAB_ITEM_RIGHT_EDGE;
!   } else {
!     //  no edge should be aligned with the tab
!     element = XP_THEME_ELEMENT_TAB_ITEM;
!   }
! 
!   if (state_type == GTK_STATE_ACTIVE) {
!     switch (gap_side) {
!     case GTK_POS_TOP:
!       y -= 1;
!       break;
!     case GTK_POS_BOTTOM:
!       y += 1;
!       break;
!     case GTK_POS_LEFT:
!       x -= 1;
!       break;
!     case GTK_POS_RIGHT:
!       x += 1;
!       break;
      }
!   }
  
!   draw_rect.x = x;
!   draw_rect.y = y;
!   draw_rect.width = width;
!   draw_rect.height = height;
!   clip_rect = draw_rect;
  
!   /* Simple case: tabs on top are just drawn as is */
!   if (gap_side == GTK_POS_TOP)
      {
!        return xp_theme_draw
! 	 (window, element, style,
! 	  draw_rect.x, draw_rect.y,
! 	  draw_rect.width, draw_rect.height,
! 	  state_type, &clip_rect);
      }
  
!   if (clip_rect.width <= 0 || clip_rect.height <= 0)
!     return TRUE;
!       
!   if (gap_side == GTK_POS_LEFT || gap_side == GTK_POS_RIGHT)
      {
!       pixmap = gdk_pixmap_new (window, clip_rect.height, clip_rect.width, -1);
!       
!       if (!xp_theme_draw (pixmap, element, style,
! 			  draw_rect.y - clip_rect.y, draw_rect.x - clip_rect.x,
! 			  draw_rect.height, draw_rect.width, state_type, 0))
  	{
+ 	  g_object_unref (pixmap);
  	  return FALSE;
  	}
+ 
+       pixbuf = gdk_pixbuf_get_from_drawable (NULL, pixmap, NULL, 0, 0, 0, 0,
+ 					     clip_rect.height, clip_rect.width);
+       g_object_unref (pixmap);
      }
    else
      {
!       pixmap = gdk_pixmap_new (window, clip_rect.width, clip_rect.height, -1);
  
!       if (!xp_theme_draw (pixmap, element, style,
! 			  draw_rect.x - clip_rect.x, draw_rect.y - clip_rect.y,
! 			  draw_rect.width, draw_rect.height, state_type, 0))
  	{
  	  g_object_unref (pixmap);
+ 	  return FALSE;
  	}
  
!       pixbuf = gdk_pixbuf_get_from_drawable (NULL, pixmap, NULL, 0, 0, 0, 0,
! 					     clip_rect.width, clip_rect.height);
!       g_object_unref (pixmap);
!     }
! 
!   if (pixbuf == NULL) return FALSE;
! 
!   if (gap_side == GTK_POS_BOTTOM || gap_side == GTK_POS_LEFT) {
!     rotated = gdk_pixbuf_flip (pixbuf, FALSE);
!     g_object_unref (pixbuf);
!     pixbuf = rotated;
!   }
!   if (gap_side == GTK_POS_LEFT || gap_side == GTK_POS_RIGHT) {
!     rotated = gdk_pixbuf_rotate_simple (pixbuf, GDK_PIXBUF_ROTATE_CLOCKWISE);
!     g_object_unref (pixbuf);
!     pixbuf = rotated;
!   }
  
!   cr = gdk_cairo_create (window);
!   gdk_cairo_set_source_pixbuf (cr, pixbuf, clip_rect.x, clip_rect.y);
!   cairo_paint (cr);
!   cairo_destroy (cr);
!   g_object_unref (pixbuf);
  
    return TRUE;
  }
***************
*** 2670,2709 ****
  	      gint y, gint width, gint height, GtkPositionType gap_side,
  	      gint gap_x, gint gap_width)
  {
!   if (GTK_IS_NOTEBOOK (widget) && detail && !strcmp (detail, "notebook"))
      {
        GtkNotebook *notebook = GTK_NOTEBOOK (widget);
        int side = gtk_notebook_get_tab_pos (notebook);
!       int x2 = x, y2 = y, w2 = width, h2 = height;
  
!       if (side == GTK_POS_TOP)
! 	{
! 	  x2 = x;
! 	  y2 = y - gtk_notebook_get_tab_vborder (notebook);
! 	  w2 = width;
! 	  h2 = height + gtk_notebook_get_tab_vborder (notebook) * 2;
! 	}
!       else if (side == GTK_POS_BOTTOM)
! 	{
! 	  x2 = x;
! 	  y2 = y;
! 	  w2 = width;
! 	  h2 = height + gtk_notebook_get_tab_vborder (notebook) * 2;
! 	}
!       else if (side == GTK_POS_LEFT)
! 	{
! 	  x2 = x - gtk_notebook_get_tab_hborder (notebook);
! 	  y2 = y;
! 	  w2 = width + gtk_notebook_get_tab_hborder (notebook);
! 	  h2 = height;
! 	}
!       else if (side == GTK_POS_RIGHT)
! 	{
! 	  x2 = x;
! 	  y2 = y;
! 	  w2 = width + gtk_notebook_get_tab_hborder (notebook) * 2;
! 	  h2 = height;
! 	}
  
        if (xp_theme_draw (window, XP_THEME_ELEMENT_TAB_PANE, style,
  			 x2, y2, w2, h2, state_type, area))
--- 2627,2656 ----
  	      gint y, gint width, gint height, GtkPositionType gap_side,
  	      gint gap_x, gint gap_width)
  {
!   if (detail && !strcmp (detail, "notebook"))
      {
        GtkNotebook *notebook = GTK_NOTEBOOK (widget);
        int side = gtk_notebook_get_tab_pos (notebook);
!       int x2, y2, w2, h2;
  
!       x2 = x;
!       y2 = y;
!       w2 = width + style->xthickness;
!       h2 = height + style->ythickness;
! 
!       switch (side) {
!       case GTK_POS_TOP:
!         y2 -= 1;
!         break;
!       case GTK_POS_BOTTOM:
!         break;
!       case GTK_POS_LEFT:
!         x2 -= 1;
!         break;
!       case GTK_POS_RIGHT:
!         w2 += 1;
!         break;
!       }
  
        if (xp_theme_draw (window, XP_THEME_ELEMENT_TAB_PANE, style,
  			 x2, y2, w2, h2, state_type, area))
*** modules/engines/ms-windows/xp_theme.c.old	2011-02-19 15:31:37.000000000 +0100
--- modules/engines/ms-windows/xp_theme.c	2011-05-16 00:12:17.436523400 +0200
***************
*** 111,126 ****
  };
  
  static const short element_part_map[XP_THEME_ELEMENT__SIZEOF] = {
!   BP_CHECKBOX,
!   BP_CHECKBOX,
!   BP_CHECKBOX,
!   BP_PUSHBUTTON,
!   HP_HEADERITEM,
    CP_DROPDOWNBUTTON,
    TABP_BODY,
!   TABP_TABITEM,
!   TABP_TABITEMLEFTEDGE,
!   TABP_TABITEMRIGHTEDGE,
    TABP_PANE,
    SBP_THUMBBTNHORZ,
    SBP_THUMBBTNVERT,
--- 111,127 ----
  };
  
  static const short element_part_map[XP_THEME_ELEMENT__SIZEOF] = {
!   BP_CHECKBOX, // PRESSED_CHECKBOX
!   BP_CHECKBOX, // CHECKBOX
!   BP_CHECKBOX, // INCONSISTENT_CHECKBOX
!   BP_PUSHBUTTON, // BUTTON
!   HP_HEADERITEM, // LIST_HEADER
    CP_DROPDOWNBUTTON,
    TABP_BODY,
!   TABP_TABITEM,             // TAB_ITEM
!   TABP_TABITEMLEFTEDGE,     // TAB_ITEM_LEFT_EDGE
!   TABP_TABITEMRIGHTEDGE,    // TAB_ITEM_RIGHT_EDGE
!   TABP_TABITEMBOTHEDGE,     // TAB_ITEM_BOTH_EDGES
    TABP_PANE,
    SBP_THUMBBTNHORZ,
    SBP_THUMBBTNVERT,
***************
*** 408,413 ****
--- 409,415 ----
      case XP_THEME_ELEMENT_TAB_ITEM:
      case XP_THEME_ELEMENT_TAB_ITEM_LEFT_EDGE:
      case XP_THEME_ELEMENT_TAB_ITEM_RIGHT_EDGE:
+     case XP_THEME_ELEMENT_TAB_ITEM_BOTH_EDGES:
      case XP_THEME_ELEMENT_TAB_PANE:
        klazz = XP_THEME_CLASS_TAB;
        break;
***************
*** 536,541 ****
--- 538,544 ----
  
      case XP_THEME_ELEMENT_TAB_ITEM_LEFT_EDGE:
      case XP_THEME_ELEMENT_TAB_ITEM_RIGHT_EDGE:
+     case XP_THEME_ELEMENT_TAB_ITEM_BOTH_EDGES:
      case XP_THEME_ELEMENT_TAB_ITEM:
        switch (state)
  	{
*** modules/engines/ms-windows/xp_theme.h.old	2011-02-19 15:31:37.000000000 +0100
--- modules/engines/ms-windows/xp_theme.h	2011-05-16 00:11:54.692382800 +0200
***************
*** 59,64 ****
--- 59,65 ----
    XP_THEME_ELEMENT_TAB_ITEM,
    XP_THEME_ELEMENT_TAB_ITEM_LEFT_EDGE,
    XP_THEME_ELEMENT_TAB_ITEM_RIGHT_EDGE,
+   XP_THEME_ELEMENT_TAB_ITEM_BOTH_EDGES,
    XP_THEME_ELEMENT_TAB_PANE,
    XP_THEME_ELEMENT_SCROLLBAR_H,
    XP_THEME_ELEMENT_SCROLLBAR_V,
