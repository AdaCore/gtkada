2011-04-10      Arnaud Charlet  <charlet@adacore.com>

	* modules/engines/ms-windows/msw_style.c (setup_system_styles): Fix
	typo.
	Submitted at https://bugzilla.gnome.org/show_bug.cgi?id=647460

	(draw_tab_button): Always use custom code to draw tab.
	Submitted at https://bugzilla.gnome.org/show_bug.cgi?id=647461

2011-04-06	Nicolas Setton  <setton@adacore.com>

	* gdk/win32/gdkevents-win32.c (doesnt_want_button_release,
	doesnt_want_button_press): reintroduce subprograms.
	(gdk_event_translate): Before generating GDK_BUTTON_PRESS and
	GDK_BUTTON_RELEASE, call propagate to switch window to the
	window, if any, which is currently grabbing the events.
	Fixes K307-005.

	Submitted at https://bugzilla.gnome.org/show_bug.cgi?id=646930

2010-10-21      Nicolas Setton  <setton@adacore.com>

	* gdk/win32/gdkevents-win32.c (generate_button_event): Remove wrong
	call to _gdk_event_button_generate.
	Fixes JA21-010.

2010-02-01      Arnaud Charlet  <charlet@adacore.com>

	* gdk/win32/gdkdrawable-win32.c	(draw_segments): Ignore LineTo
	errors.

2009-09-29      Nicolas Setton  <setton@adacore.com>

	* gdk/win32/gdkevents-win32.c:
	Protect against infinite loop in the events processing queue, in cases
	where the translation of events cause the same events to be
	regenerated. This protects against two cases of loops that have been
	observed under Citrix.
	(gdk_event_translate): Protect against reentry on move or size events
	that are being re-posted by Gtk+, which happens when a Citrix window
	receives move events but has never been mapped to a Gtk+ window.
	(_gdk_event_queue): After having processed all the messages, reset the
	reentry flags.

2009-07-20	Arnaud Charlet	<charlet@adacore.com>

	* configure: Work around ^M handling on cygwin with igncr

2007-10-10	Arnaud Charlet	<charlet@adacore.com>

	* modules/engines/ms-windows/msw_style.c (draw_themed_tab_button):
	Avoid SEGV in case pixbuf is null or clip_rect is empty.
	Fixes G928-005

2006-06-05	Arnaud Charlet	<charlet@adacore.com>

	* gdk/win32/gdkgc-win32.c (_gdk_win32_gdkregion_to_hrgn): Disable
	harmless warning which is occurring often with Gtk+ >= 2.8.18

2002-11-25	Arnaud Charlet	<charlet@adacore.com>

	* gdk/win32/gdkevents-win32.c (handle_wm_paint): Force an update when
	paint message is received, otherwise windows in background are not
	immediately refreshed when moving a modal window on top of them.

	* gdk/Makefile.in: Remove gdk-win32res.o dependency,
	since we do not want to use the default Gtk+ icon.

--- gdk/win32/gdkevents-win32.c.old	2009-12-22 12:37:10.468370000 +0100
+++ gdk/win32/gdkevents-win32.c	2010-01-06 17:04:42.923000000 +0100
@@ -1692,6 +1692,12 @@ handle_wm_paint (MSG        *msg,
     _gdk_window_invalidate_for_expose (window, update_region);
   gdk_region_destroy (update_region);
 
+  /* Force a process_updates to refresh visible windows
+   * when receiving a paint message. */
+
+  if (!GDK_WINDOW_DESTROYED (window) && gdk_window_is_visible (window))
+    gdk_window_process_updates (window, FALSE);
+
   DeleteObject (hrgn);
 }
 
--- gdk/Makefile.in.orig	2010-09-23 16:27:22.000000000 +0200
+++ gdk/Makefile.in	2010-10-08 11:06:41.724000000 +0200
@@ -664,8 +664,8 @@ libgdk_quartz_2_0_la_LIBADD = quartz/lib
 libgdk_quartz_2_0_la_LDFLAGS = $(LDADD)
 libgdk_win32_2_0_la_SOURCES = $(common_sources) gdkkeynames.c
 libgdk_win32_2_0_la_LIBADD = win32/libgdk-win32.la $(GDK_DEP_LIBS)
-libgdk_win32_2_0_la_DEPENDENCIES = win32/libgdk-win32.la win32/rc/gdk-win32-res.o gdk.def
-libgdk_win32_2_0_la_LDFLAGS = -Wl,win32/rc/gdk-win32-res.o -export-symbols $(srcdir)/gdk.def $(LDADD)
+libgdk_win32_2_0_la_DEPENDENCIES = win32/libgdk-win32.la gdk.def
+libgdk_win32_2_0_la_LDFLAGS = -export-symbols $(srcdir)/gdk.def $(LDADD)
 @HAVE_INTROSPECTION_TRUE@introspection_files = $(filter-out \
 @HAVE_INTROSPECTION_TRUE@	gdkkeysyms-compat.h, \
 @HAVE_INTROSPECTION_TRUE@	$(gdk_public_h_sources)) \
--- gdk/win32/gdkgc-win32.c.orig
+++ gdk/win32/gdkgc-win32.c	2006-06-05 14:56:59.515625000 +0200
@@ -1160,8 +1160,7 @@ _gdk_win32_gdkregion_to_hrgn (GdkRegion 
       if (rect->bottom > rgndata->rdh.rcBound.bottom)
 	rgndata->rdh.rcBound.bottom = rect->bottom;
     }
-  if ((hrgn = ExtCreateRegion (NULL, nbytes, rgndata)) == NULL)
-    WIN32_API_FAILED ("ExtCreateRegion");
+  hrgn = ExtCreateRegion (NULL, nbytes, rgndata);
 
   g_free (rgndata);
 
--- modules/engines/ms-windows/msw_style.c.orig	2008-03-12 05:17:03.000000000 +0100
+++ modules/engines/ms-windows/msw_style.c	2008-04-17 18:35:13.515625000 +0200
@@ -2649,6 +2649,9 @@ draw_themed_tab_button (GtkStyle *style,
       GdkPixbuf *pixbuf;
       GdkPixbuf *rotated;
 
+      if (clip_rect.width <= 0 || clip_rect.height <= 0)
+        return TRUE;
+      
       if (gap_side == GTK_POS_LEFT || gap_side == GTK_POS_RIGHT)
 	{
 	  pixmap = gdk_pixmap_new (window, clip_rect.height, clip_rect.width, -1);
@@ -2682,6 +2685,7 @@ draw_themed_tab_button (GtkStyle *style,
 	  g_object_unref (pixmap);
 	}
 
+      if (pixbuf != NULL) {
       rotated = gdk_pixbuf_rotate_simple (pixbuf, rotation);
       g_object_unref (pixbuf);
       pixbuf = rotated;
@@ -2710,6 +2714,7 @@ draw_themed_tab_button (GtkStyle *style,
 		       clip_rect.width, clip_rect.height, GDK_RGB_DITHER_NONE,
 		       0, 0);
       g_object_unref (pixbuf);
+      }
     }
 
   return TRUE;
--- configure.old	2009-02-23 15:54:03.650263500 +0100
+++ configure	2009-02-23 15:54:54.711263500 +0100
@@ -36969,6 +36971,7 @@ if test "$ac_cs_awk_cr" = "a${ac_cr}b"; 
 else
   ac_cs_awk_cr=$ac_cr
 fi
+ac_cs_awk_cr=$ac_cr
 
 echo 'BEGIN {' >"$tmp/subs1.awk" &&
 _ACEOF
*** gdk/win32/gdkevents-win32.c.before_patch	2009-09-22 20:06:09.000000000 +0200
--- gdk/win32/gdkevents-win32.c	2009-09-24 16:25:23.000000000 +0200
*************** static UINT client_message;
*** 133,138 ****
--- 133,144 ----
  static UINT got_gdk_events_message;
  static HWND modal_win32_dialog = NULL;
  
+ /* The following variables are used to protect against re-entry in the
+    _gdk_event_queue main loop, which can happen under Citrix. */
+ static gint activate_events = 0;
+ static gint move_or_size_events = 0;
+ static gint reentry_threshold = 3;
+ 
  #if 0
  static HKL latin_locale = NULL;
  #endif
*************** gdk_event_translate (MSG  *msg,
*** 2324,2330 ****
  	   */
  	  GDK_NOTE (EVENTS, g_print (" (posted)"));
  	
! 	  PostMessageW (msg->hwnd, msg->message, msg->wParam, msg->lParam);
  	}
        else if (msg->message == WM_CREATE)
  	{
--- 2330,2340 ----
  	   */
  	  GDK_NOTE (EVENTS, g_print (" (posted)"));
  	
! 	  /* Do not post this message if we have posted it too many times 
! 	     within the same event loop. */
! 	  move_or_size_events += 1;
! 	  if (move_or_size_events < reentry_threshold)
! 	     PostMessageW (msg->hwnd, msg->message, msg->wParam, msg->lParam);
  	}
        else if (msg->message == WM_CREATE)
  	{
*************** gdk_event_translate (MSG  *msg,
*** 3695,3701 ****
        if (is_modally_blocked (window) && LOWORD (msg->wParam) == WA_ACTIVE)
  	{
  	  GdkWindow *modal_current = _gdk_modal_current ();
! 	  SetActiveWindow (GDK_WINDOW_HWND (modal_current));
  	  *ret_valp = 0;
  	  return_val = TRUE;
  	  break;
--- 3705,3717 ----
        if (is_modally_blocked (window) && LOWORD (msg->wParam) == WA_ACTIVE)
  	{
  	  GdkWindow *modal_current = _gdk_modal_current ();
! 	  
! 	  /* Do not change the active window if we have done this too many
! 	     times within the same event loop. */
! 	  activate_events += 1;
! 	  if (activate_events < reentry_threshold)
! 	      SetActiveWindow (GDK_WINDOW_HWND (modal_current));
! 	    
  	  *ret_valp = 0;
  	  return_val = TRUE;
  	  break;
*************** _gdk_events_queue (GdkDisplay *display)
*** 3775,3780 ****
--- 3791,3801 ----
        TranslateMessage (&msg);
        DispatchMessageW (&msg);
      }
+   
+    /* we are leaving the events queue processing: reset flags that protect
+       against re-entry */
+    activate_events = 0;
+    move_or_size_events = 0;
  }
  
  static gboolean
--- gdk/win32/gdkdrawable-win32.c.old	2010-01-31 18:48:07.679800000 +0100
+++ gdk/win32/gdkdrawable-win32.c	2010-01-31 18:48:32.429800000 +0100
@@ -1246,7 +1246,7 @@ draw_segments (GdkGCWin32 *gcwin32,
 
 	  GDK_NOTE (DRAW, g_print (" +%d+%d..+%d+%d", x1, y1, x2, y2));
 	  GDI_CALL (MoveToEx, (hdc, x1, y1, NULL)) &&
-	    GDI_CALL (LineTo, (hdc, x2, y2));
+	    LineTo (hdc, x2, y2);
 	}
 
       GDK_NOTE (DRAW, g_print ("\n"));
--- gdk/win32/gdkevents-win32.c.old	2011-04-05 09:23:55.913000000 +0200
+++ gdk/win32/gdkevents-win32.c	2011-04-05 17:07:19.272000000 +0200
@@ -1727,8 +1734,10 @@ generate_button_event (GdkEventType type
 
   append_event (event);
 
+#if 0
   if (type == GDK_BUTTON_PRESS)
     _gdk_event_button_generate (_gdk_display, event);
+#endif
 }
 
 static void
--- gdk/win32/gdkevents-win32.c.original	2011-04-06 09:26:44.000000000 -0700
+++ gdk/win32/gdkevents-win32.c	2011-04-06 09:29:45.000000000 -0700
@@ -1459,6 +1459,20 @@ doesnt_want_char (gint mask,
   return !(mask & (GDK_KEY_PRESS_MASK | GDK_KEY_RELEASE_MASK));
 }
 
+static gboolean
+doesnt_want_button_release (gint mask,
+			    MSG *msg)
+{
+  return !(mask & GDK_BUTTON_RELEASE_MASK);
+}
+
+static gboolean
+doesnt_want_button_press (gint mask,
+			  MSG *msg)
+{
+  return !(mask & GDK_BUTTON_PRESS_MASK);
+}
+
 static void
 handle_configure_event (MSG       *msg,
 			GdkWindow *window)
@@ -2284,8 +2298,17 @@ gdk_event_translate (MSG  *msg,
 	break;
 
       /* TODO_CSW? Emulate X11's automatic active grab */
-      generate_button_event (GDK_BUTTON_PRESS, button,
-			     window, msg);
+      
+      grab = _gdk_display_get_last_pointer_grab (_gdk_display);
+
+      if (grab != NULL && 
+	  !propagate (&window, msg,
+		      grab->window, grab->owner_events, grab->event_mask,
+		      doesnt_want_button_press, TRUE))
+	;
+      else if (!GDK_WINDOW_DESTROYED (window))
+	  generate_button_event (GDK_BUTTON_PRESS, button,
+				 window, msg);
 
       return_val = TRUE;
       break;
@@ -2323,8 +2346,15 @@ gdk_event_translate (MSG  *msg,
 	}
 #endif
 
-      generate_button_event (GDK_BUTTON_RELEASE, button,
-			     window, msg);
+      grab = _gdk_display_get_last_pointer_grab (_gdk_display);
+
+      if (grab != NULL && 
+	  !propagate (&window, msg,
+		      grab->window, grab->owner_events, grab->event_mask,
+		      doesnt_want_button_release, TRUE))
+	;
+      else if (!GDK_WINDOW_DESTROYED (window))
+	generate_button_event (GDK_BUTTON_RELEASE, button, window, msg);
 
       return_val = TRUE;
       break;
--- modules/engines/ms-windows/msw_style.c.old
+++ modules/engines/ms-windows/msw_style.c
@@ -849,7 +849,7 @@ setup_system_styles (GtkStyle *style)
   sys_color_to_gtk_color (XP_THEME_CLASS_TEXT, COLOR_GRAYTEXT,
 			  &style->fg[GTK_STATE_INSENSITIVE]);
   sys_color_to_gtk_color (XP_THEME_CLASS_BUTTON, COLOR_BTNTEXT,
-        		  &style->bg[GTK_STATE_ACTIVE]);
+        		  &style->fg[GTK_STATE_ACTIVE]);
   sys_color_to_gtk_color (XP_THEME_CLASS_WINDOW, COLOR_WINDOWTEXT,
 			  &style->fg[GTK_STATE_PRELIGHT]);
 
@@ -2590,7 +2590,9 @@ draw_tab_button (GtkStyle *style,
 		 const gchar *detail,
 		 gint x, gint y, gint width, gint height, gint gap_side)
 {
+#if 0
   if (gap_side == GTK_POS_TOP || gap_side == GTK_POS_BOTTOM)
+#endif
     {
       /* experimental tab-drawing code from mozilla */
       RECT rect;
