2007-03-31	Arnaud Charlet	<charlet@adacore.com>

	* modules/engines/ms-windows/msw_style.c (draw_extension): Revert to
	Gtk+ 2.8.20 implementation, to draw notebook tabs properly.
	Fixes G330-007

2006-06-05	Arnaud Charlet	<charlet@adacore.com>

	* gdk/win32/gdkgc-win32.c (_gdk_win32_gdkregion_to_hrgn): Disable
	harmless warning which is occurring often with Gtk+ 2.8.18.

2006-02-20	Arnaud Charlet	<charlet@adacore.com>

	* gtk/Makefile.in, demos/Makefile.in,
	gdk-pixbuf/Makefile.in, modules/input/Makefile.in: Force call to
	gdk-pixbuf-csource., gdk-pixbuf-query-loaders.,
	gtk-query-immodules-2.0. and gtk-update-icon-cache. to work around
	cygwin ambiguity.

2002-11-25	Arnaud Charlet	<charlet@adacore.com>

	* gdk/Makefile.in: Remove gdk-win32res.o dependency,
	since we do not want to use the default Gtk+ icon.

2003-03-27	Arnaud Charlet <charlet@adacore.com>

	* gdk/win32/gdkwindow-win32.c: Bring parent window on top when
	destroying a modal window. Fixes unexpected lost focus.

2002-09-12	Florent Duguet	<duguet@adacore.com>

	* gdk/win32/gdkevents-win32.c: Force an update when paint message
	is received, otherwise windows in background are not immediately
	refreshed when moving a modal window on top of them.
	Add handling of WM_NCPAINT message to refresh some areas when a window
	from another application is moved on top of the current app.

--- gdk/win32/gdkevents-win32.c.old	2006-02-21 10:02:58.000000000 +0100
+++ gdk/win32/gdkevents-win32.c	2006-02-21 10:08:22.000000000 +0100
@@ -2125,6 +2125,12 @@ handle_wm_paint (MSG        *msg,
   _gdk_window_process_expose (window, update_region);
   gdk_region_destroy (update_region);
 
+  /* Force a process_updates to refresh visible windows
+   * when receiving a paint message. */
+
+  if (!GDK_WINDOW_DESTROYED (window) && gdk_window_is_visible (window))
+    gdk_window_process_updates (window, FALSE);
+
   DeleteObject (hrgn);
 }
 
@@ -2964,6 +2970,35 @@ gdk_event_translate (MSG  *msg,
       *ret_valp = 1;
       break;
 
+    case WM_NCPAINT:
+      if (msg->wParam < 1)
+	break;
+
+      {
+	HRGN hrgn;
+
+	hrgn = CreateRectRgn (0, 0, 0, 0);
+	if (GetUpdateRgn (msg->hwnd, hrgn, FALSE) == ERROR)
+	  {
+	    WIN32_GDI_FAILED ("GetUpdateRgn");
+	    break;
+	  }
+
+	{
+	  GdkRegion *update_region = _gdk_win32_hrgn_to_region (hrgn);
+
+	  _gdk_windowing_window_get_offsets (window, &xoffset, &yoffset);
+	  gdk_region_offset (update_region, xoffset, yoffset);
+
+	  _gdk_window_process_expose (window, update_region);
+	  gdk_region_destroy (update_region);
+
+	  DeleteObject (hrgn);
+	  return_val = FALSE;
+	}
+      }
+      break;
+
     case WM_PAINT:
       handle_wm_paint (msg, window, FALSE, NULL);
       break;
--- gdk/win32/gdkwindow-win32.c.old	2006-02-21 10:09:41.000000000 +0100
+++ gdk/win32/gdkwindow-win32.c	2006-02-21 10:10:19.000000000 +0100
@@ -837,6 +837,15 @@ _gdk_windowing_window_destroy (GdkWindow
   GDK_NOTE (MISC, g_print ("_gdk_windowing_window_destroy: %p\n",
 			   GDK_WINDOW_HWND (window)));
 
+  if (private->modal_hint)
+    {
+      HWND parent = (HWND) GetWindowLong
+	(GDK_WINDOW_HWND (window), GWL_HWNDPARENT);
+
+      if ((long)parent > 1 && !BringWindowToTop (parent))
+	WIN32_API_FAILED ("BringWindowToTop");
+    }
+
   if (private->extension_events != 0)
     _gdk_input_window_destroy (window);
 
--- gdk-pixbuf/Makefile.in.old	2006-02-21 09:00:26.000000000 +0100
+++ gdk-pixbuf/Makefile.in	2006-02-21 08:58:57.000000000 +0100
@@ -1603,7 +1603,7 @@ distclean-local:
 install-data-hook: install-ms-lib install-def-file
 	@if $(RUN_QUERY_LOADER_TEST) ; then \
 	  $(mkinstalldirs) $(DESTDIR)$(sysconfdir)/gtk-2.0 ; \
-	  $(top_builddir)/gdk-pixbuf/gdk-pixbuf-query-loaders > $(DESTDIR)$(sysconfdir)/gtk-2.0/gdk-pixbuf.loaders ; \
+	  $(top_builddir)/gdk-pixbuf/gdk-pixbuf-query-loaders. > $(DESTDIR)$(sysconfdir)/gtk-2.0/gdk-pixbuf.loaders ; \
 	else \
 	  echo "***" ; \
 	  echo "*** Warning: gdk-pixbuf.loaders not built" ; \
@@ -1622,7 +1622,7 @@ uninstall-local: uninstall-ms-lib uninst
 @BUILD_DYNAMIC_MODULES_TRUE@	LOADERS=`echo libpixbufloader-*.la` ; \
 @BUILD_DYNAMIC_MODULES_TRUE@	if test "x$$LOADERS" != 'xlibpixbufloader-*.la' ; then \
 @BUILD_DYNAMIC_MODULES_TRUE@          echo "Writing a gdk-pixbuf.loader file to use when running examples before installing gdk-pixbuf."; \
-@BUILD_DYNAMIC_MODULES_TRUE@	  $(top_builddir)/gdk-pixbuf/gdk-pixbuf-query-loaders $$LOADERS > ./gdk-pixbuf.loaders ;\
+@BUILD_DYNAMIC_MODULES_TRUE@	  $(top_builddir)/gdk-pixbuf/gdk-pixbuf-query-loaders. $$LOADERS > ./gdk-pixbuf.loaders ;\
 @BUILD_DYNAMIC_MODULES_TRUE@	else \
 @BUILD_DYNAMIC_MODULES_TRUE@          echo "No dynamic modules found; will use only static modules for uninstalled example programs."; \
 @BUILD_DYNAMIC_MODULES_TRUE@	  touch gdk-pixbuf.loaders; \
--- demos/Makefile.in.old	2006-02-20 16:58:02.000000000 +0100
+++ demos/Makefile.in	2006-02-21 09:06:00.000000000 +0100
@@ -317,9 +317,9 @@ $(am__append_1)
 @HAVE_PNG_TRUE@BUILT_SOURCES = test-inline-pixbufs.h
 
 @CROSS_COMPILING_TRUE@pixbuf_csource = $(GDK_PIXBUF_CSOURCE)
-@CROSS_COMPILING_FALSE@pixbuf_csource = GDK_PIXBUF_MODULE_FILE=$(top_builddir)/gdk-pixbuf/gdk-pixbuf.loaders $(top_builddir)/gdk-pixbuf/gdk-pixbuf-csource
+@CROSS_COMPILING_FALSE@pixbuf_csource = GDK_PIXBUF_MODULE_FILE=$(top_builddir)/gdk-pixbuf/gdk-pixbuf.loaders $(top_builddir)/gdk-pixbuf/gdk-pixbuf-csource.
 @CROSS_COMPILING_TRUE@pixbuf_csource_deps = 
-@CROSS_COMPILING_FALSE@pixbuf_csource_deps = $(top_builddir)/gdk-pixbuf/gdk-pixbuf-csource $(top_builddir)/gdk-pixbuf/gdk-pixbuf.loaders 
+@CROSS_COMPILING_FALSE@pixbuf_csource_deps = $(top_builddir)/gdk-pixbuf/gdk-pixbuf-csource. $(top_builddir)/gdk-pixbuf/gdk-pixbuf.loaders 
 
 testpixbuf_DEPENDENCIES = $(DEPS)
 testpixbuf_drawable_DEPENDENCIES = $(DEPS)
--- modules/input/Makefile.in.old	2006-02-21 09:07:45.000000000 +0100
+++ modules/input/Makefile.in	2006-02-21 09:08:12.000000000 +0100
@@ -800,8 +800,8 @@ install-data-hook:
 	@if $(RUN_QUERY_IMMODULES_TEST) ; then \
 	  echo $(mkinstalldirs) $(DESTDIR)$(sysconfdir)/gtk-2.0 ; \
 	  $(mkinstalldirs) $(DESTDIR)$(sysconfdir)/gtk-2.0 ; \
-	  echo "$(top_builddir)/gtk/gtk-query-immodules-2.0 > $(DESTDIR)$(sysconfdir)/gtk-2.0/gtk.immodules" ; \
-	  $(top_builddir)/gtk/gtk-query-immodules-2.0 > $(DESTDIR)$(sysconfdir)/gtk-2.0/gtk.immodules ; \
+	  echo "$(top_builddir)/gtk/gtk-query-immodules-2.0. > $(DESTDIR)$(sysconfdir)/gtk-2.0/gtk.immodules" ; \
+	  $(top_builddir)/gtk/gtk-query-immodules-2.0. > $(DESTDIR)$(sysconfdir)/gtk-2.0/gtk.immodules ; \
 	else \
 	  echo "***" ; \
 	  echo "*** Warning: gtk.immodules not built" ; \
@@ -815,7 +815,7 @@ uninstall-local:
 	rm -f $(DESTDIR)$(sysconfdir)/gtk-2.0/gtk.immodules
 
 gtk.immodules: Makefile.am $(module_LTLIBRARIES)
-	$(top_builddir)/gtk/gtk-query-immodules-2.0 $(module_LTLIBRARIES) > gtk.immodules
+	$(top_builddir)/gtk/gtk-query-immodules-2.0. $(module_LTLIBRARIES) > gtk.immodules
 
 @CROSS_COMPILING_FALSE@all-local: gtk.immodules
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
--- gtk/Makefile.in.orig	2007-01-05 19:44:17.000000000 +0100
+++ gtk/Makefile.in	2007-01-08 17:08:17.078125000 +0100
@@ -2956,7 +2956,7 @@ stamp-icons: $(STOCK_ICONS)
 
 gtkbuiltincache.h: @REBUILD@ stamp-icons
 	$(MAKE) $(AM_MAKEFLAGS) gtk-update-icon-cache$(EXEEXT)
-	$(gtk_update_icon_cache_program) --force --ignore-theme-index		\
+	$(gtk_update_icon_cache_program). --force --ignore-theme-index		\
 	   --source builtin_icons stock-icons > gtkbuiltincache.h.tmp &&        \
 	mv gtkbuiltincache.h.tmp gtkbuiltincache.h
 
--- gdk/win32/gdkgc-win32.c.old	2005-07-18 17:20:28.000000000 +0200
+++ gdk/win32/gdkgc-win32.c	2006-06-05 14:56:59.515625000 +0200
@@ -1160,8 +1160,7 @@ _gdk_win32_gdkregion_to_hrgn (GdkRegion 
       if (rect->bottom > rgndata->rdh.rcBound.bottom)
 	rgndata->rdh.rcBound.bottom = rect->bottom;
     }
-  if ((hrgn = ExtCreateRegion (NULL, nbytes, rgndata)) == NULL)
-    WIN32_API_FAILED ("ExtCreateRegion");
+  hrgn = ExtCreateRegion (NULL, nbytes, rgndata);
 
   g_free (rgndata);
 
--- gdk/Makefile.in.orig	2007-03-14 05:12:38.000000000 +0100
+++ gdk/Makefile.in	2007-03-23 17:23:57.062500000 +0100
@@ -462,8 +462,8 @@ libgdk_win32_2_0_la_SOURCES = $(common_s
 libgdk_win32_2_0_la_LIBADD = win32/libgdk-win32.la $(GDK_DEP_LIBS) \
   $(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la
 
-libgdk_win32_2_0_la_DEPENDENCIES = win32/libgdk-win32.la win32/rc/gdk-win32-res.o gdk.def
-libgdk_win32_2_0_la_LDFLAGS = -Wl,win32/rc/gdk-win32-res.o -export-symbols gdk.def $(LDADD) $(am__append_1) $(am__append_2)
+libgdk_win32_2_0_la_DEPENDENCIES = win32/libgdk-win32.la gdk.def
+libgdk_win32_2_0_la_LDFLAGS = -export-symbols gdk.def $(LDADD) $(am__append_1) $(am__append_2)
 
 @MS_LIB_AVAILABLE_TRUE@noinst_DATA = gdk-win32-$(GTK_API_VERSION).lib
 
--- modules/engines/ms-windows/msw_style.c.old	2007-03-31 21:53:05.703125000 +0200
+++ modules/engines/ms-windows/msw_style.c	2007-03-31 21:55:46.359375000 +0200
@@ -2403,165 +2403,44 @@ draw_extension (GtkStyle * style,
     if (widget && GTK_IS_NOTEBOOK (widget) && detail && !strcmp (detail, "tab"))
 	{
 	    GtkNotebook *notebook = GTK_NOTEBOOK (widget);
-	    GdkPixmap *pixmap = NULL;
-	    GdkDrawable *target = NULL;
-	    gint x2 = 0, y2 = 0, w2 = width, h2 = height;
+	    gint x2, y2, w2, h2;
 	    int tab_part = XP_THEME_ELEMENT_TAB_ITEM;
-	    int real_gap_side = gtk_notebook_get_tab_pos (notebook);
-	    int border_width = gtk_container_get_border_width (GTK_CONTAINER (notebook));
-	    gboolean last_tab;
+		int real_gap_side = gtk_notebook_get_tab_pos (notebook);
 
-	    /* why this differs from the above gap_side, i have no idea... */
-	    if (real_gap_side == GTK_POS_LEFT)
-	      {
-		/* Create "rotated" pixmap.. swap width and height */
-		pixmap = gdk_pixmap_new (window, height, width, -1);
-		target = pixmap;
-		x2 = 0;
-		y2 = 0;
-		w2 = height;
-		h2 = width - (state_type == GTK_STATE_NORMAL ? 0 : notebook->tab_hborder);
-
-		/* If we are currently rendering the bottom-most tab, and if that tab is the selected tab... */
-		if (widget->allocation.y + widget->allocation.height - border_width == y + height &&
-		    state_type == GTK_STATE_NORMAL)
-		  {
-		    w2--;
-		  }
-	      }
-	    else if (real_gap_side == GTK_POS_RIGHT)
-	      {
-		/* Create "rotated" pixmap.. swap width and height */
-		x2 = 0;
-		y2 = 0;
-		w2 = height;
-		h2 = width - (state_type == GTK_STATE_NORMAL ? 0 : notebook->tab_hborder);
-		pixmap = gdk_pixmap_new (window, w2, h2, -1);
-		target = pixmap;
-
-		/* If we are currently rendering the bottom-most tab, and if that tab is the selected tab... */
-		if (widget->allocation.y + widget->allocation.height - border_width == y + height &&
-		    state_type == GTK_STATE_NORMAL)
-		  {
-		    w2--;
-		  }
-	      }
-	    else if (real_gap_side == GTK_POS_TOP)
-	      {
-		target = window;
-		x2 = x;
-		y2 = y;
-		w2 = width;
-		if (state_type == GTK_STATE_NORMAL)
-		  h2 = height;
-		else
-		  h2 = height - notebook->tab_vborder;
-
-		/* If we are currently drawing the right-most tab, and if that tab is the selected tab... */
-		if (widget->allocation.x + widget->allocation.width - border_width == x + width &&
-		    state_type == GTK_STATE_NORMAL)
-		  {
-		    x2--;
-		  }
-	      }
-	    else if (real_gap_side == GTK_POS_BOTTOM)
-	      {
-		x2 = x;
-		y2 = y + (state_type == GTK_STATE_NORMAL ? 0 : notebook->tab_vborder);
-		w2 = width;
-		h2 = height - (state_type == GTK_STATE_NORMAL ? 0 : notebook->tab_vborder * 2);
-		target = window;
-
-		/* If we are currently drawing the right-most tab (any state)... */
-		if (widget->allocation.x + widget->allocation.width - border_width == x + width)
-		  {
-		    x2--;
-		    w2--;
-		  }
-	      }
+		/* why this differs from the above gap_side, i have no idea... */
+	    x2 = x;
+	    y2 = y;
+	    w2 = width;
+	    h2 = height;
 
-	    if (xp_theme_draw (target, tab_part, style, x2, y2, w2, h2, state_type, NULL /*area*/))
+	    if (xp_theme_draw (window, tab_part,
+			 style, x2, y2, w2, h2, (real_gap_side == GTK_POS_TOP ? state_type : GTK_STATE_SELECTED), area))
 		{
-		    GdkPixbufRotation rotation = GDK_PIXBUF_ROTATE_NONE;
-		    if (real_gap_side == GTK_POS_BOTTOM)
-		        rotation = GDK_PIXBUF_ROTATE_UPSIDEDOWN;
-		    else if (real_gap_side == GTK_POS_LEFT)
-		        rotation = GDK_PIXBUF_ROTATE_COUNTERCLOCKWISE;
-		    else if (real_gap_side == GTK_POS_RIGHT)
-		        rotation = GDK_PIXBUF_ROTATE_CLOCKWISE;
-
-		    if (rotation != GDK_PIXBUF_ROTATE_NONE)
-			{
-			   GdkPixbuf * pixbuf, * rotated;
-
-			   pixbuf = gdk_pixbuf_get_from_drawable (NULL, target, NULL, x2, y2, 0, 0, w2, h2);
-
-			   rotated = gdk_pixbuf_rotate_simple (pixbuf, rotation);
-			   g_object_unref (pixbuf);
-			   pixbuf = rotated;
-
-			   if (real_gap_side == GTK_POS_RIGHT)
-			     {
-			       x2 = x + (state_type == GTK_STATE_NORMAL ? 0 : notebook->tab_hborder);
-			       y2 = y;
-			       w2 = width - (state_type == GTK_STATE_NORMAL ? 0 : notebook->tab_hborder);
-			       h2 = height;
-
-			       if (widget->allocation.y + widget->allocation.height - border_width == y + height &&
-				   state_type == GTK_STATE_NORMAL)
-				 {
-				   h2--;
-				 }
-			     }
-			   else if (real_gap_side == GTK_POS_LEFT)
-			     {
-			       x2 = x;
-			       y2 = y;
-			       w2 = width - (state_type == GTK_STATE_NORMAL ? 0 : notebook->tab_hborder);
-			       h2 = height;
-
-			       if (widget->allocation.y + widget->allocation.height - border_width == y + height &&
-				   state_type == GTK_STATE_NORMAL)
-				 {
-				   h2--;
-				 }
-			     }
-
-			   gdk_draw_pixbuf (window, NULL, pixbuf, 0, 0, x2, y2, w2, h2, GDK_RGB_DITHER_NONE, 0, 0);
-
-			   if (real_gap_side == GTK_POS_LEFT || real_gap_side == GTK_POS_RIGHT)
-			     {
-			       g_object_unref (pixmap);
-			     }
-			}
-		    return;
+			return;
 		} else if (real_gap_side == GTK_POS_TOP || real_gap_side == GTK_POS_BOTTOM) {
-		    /* experimental tab-drawing code from mozilla */
+			/* experimental tab-drawing code from mozilla */
 		    RECT rect;
-		    HDC dc;
-		    gint32 aPosition;
+    		HDC dc;
+			gint32 aPosition;
+
+    		dc = get_window_dc(style, window, state_type, x, y, width, height, &rect);
 
-		    dc = get_window_dc(style, window, state_type, x, y, width, height, &rect);
+			if (real_gap_side == GTK_POS_TOP)
+				aPosition = BF_TOP;
+			else if (real_gap_side == GTK_POS_BOTTOM)
+				aPosition = BF_BOTTOM;
+			else if (real_gap_side == GTK_POS_LEFT)
+				aPosition = BF_LEFT;
+			else
+				aPosition = BF_RIGHT;
 
-		    if (real_gap_side == GTK_POS_TOP)
-		        aPosition = BF_TOP;
-		    else if (real_gap_side == GTK_POS_BOTTOM)
-		        aPosition = BF_BOTTOM;
-		    else if (real_gap_side == GTK_POS_LEFT)
-		        aPosition = BF_LEFT;
-		    else
-		        aPosition = BF_RIGHT;
-
-                    if( state_type == GTK_STATE_PRELIGHT )
-                        state_type = GTK_STATE_NORMAL;
-		    if (area)
-		        gdk_gc_set_clip_rectangle (style->dark_gc[state_type], area);
-		    DrawTab (dc, rect, aPosition, state_type != GTK_STATE_PRELIGHT, (real_gap_side != GTK_POS_LEFT), (real_gap_side != GTK_POS_RIGHT));
-		    if (area)
-		        gdk_gc_set_clip_rectangle (style->dark_gc[state_type], NULL);
+			if (area)
+				gdk_gc_set_clip_rectangle (style->dark_gc[state_type], area);
+			DrawTab (dc, rect, aPosition, state_type != GTK_STATE_PRELIGHT, (real_gap_side != GTK_POS_LEFT), (real_gap_side != GTK_POS_RIGHT));
+			if (area)
+				gdk_gc_set_clip_rectangle (style->dark_gc[state_type], NULL);
 
-		    release_window_dc (style, window, state_type);
-                    return;
+			release_window_dc (style, window, state_type);
 		}
 	}
     parent_class->draw_extension
