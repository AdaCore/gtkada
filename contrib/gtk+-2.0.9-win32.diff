This is a patch against Gtk+ 2.0.9 sources that fixes Windows specific problems.

Wed Jan 15 14:18:23  2003	Arnaud Charlet <charlet@gnat.com

	* gtk+/gdk/win32/gdkevents-win32.c: Fix handling of negative coordinates
	* gtk+/gtk/gtkmenuitem.c: Ditto

Thu Nov 28 11:54:59  2002	Arnaud Charlet <charlet@gnat.com>

	* pango/pango/pangowin32.c: Remove initialization of
	pango_win32_os_version_info.

	* pango/pango/pangowin32-fontmap.c (pango_win32_font_map_class_init):
	Properly initialize pango_win32_os_version_info.

Mon Nov 25 12:00:14  2002	Arnaud Charlet <charlet@gnat.com>

	* gtk+/gdk/win32/Makefile.am: Remove gdk-win32res.lo dependency,
	since we do not want to use the default Gtk+ icon.

	* gtk+/gdk/win32/gdkmain-win32.c: Define dummy symbol when
	G_ENABLE_DEBUG is not defined, to work around undefined symbol.

Tue Nov  5 11:54:18  2002	Arnaud Charlet <charlet@gnat.com>

	* glib/glib/glib.def: Add missing symbol.

	* gtk+/gdk/win32/gdkwindow-win32.c
	(gdk_window_unstick): Remove spurious warning.
	(gdk_window_set_transient_for): Use TOPMOST after all, since
	NO_TOPMOST is too confusing.

	* gtk+/gdk/win32/gdkevents-win32.c (gdk_event_translate): Add handling
	of maximized and minimized events.

Mon Sep 16 12:39:09  2002	Florent Duguet <duguet@gnat.com>

	* pango/pango/pangowin32.c: Optimization of the pango rendering through
	caching.

Wed Sep 11 16:55:47  2002	Florent Duguet <duguet@gnat.com>

	* gtk+/gdk/win32/gdkgeometry-win32.c: Ask for a repaint of the
	invalidate zone to address smoothness issues.

#########################################
# Selection problem B430-008
#########################################


--- gtk+/gtk/gtktextview.c.old	2002-11-05 11:11:07 +0100
+++ gtk+/gtk/gtktextview.c	2002-11-05 11:11:25 +0100
@@ -3874,8 +3874,10 @@
 
   text_view = GTK_TEXT_VIEW (widget);
 
+#if 0
   if (event->window != text_view->text_window->bin_window)
     return FALSE;
+#endif
 
   if (event->button == 1)
     {

#########################################
# GtkTextView smoothness issues
#########################################

--- gtk+/gdk/win32/gdkgeometry-win32.c.old	2002-11-05 11:13:39 +0100
+++ gtk+/gdk/win32/gdkgeometry-win32.c	2002-11-05 11:14:52 +0100
@@ -140,13 +140,17 @@
 
       gdk_window_queue_translation (window, dx, dy);
 
-      if (!ScrollWindowEx (GDK_WINDOW_HWND (window),
-                           dx, dy, /* in: scroll offsets */
-                           NULL, /* in: scroll rect, NULL == entire client area */
-                           &clipRect, /* in: restrict to */
-                           NULL, /* in: update region */
-                           NULL, /* out: update rect */
-                           SW_INVALIDATE | SW_SCROLLCHILDREN))
+      if (ScrollWindowEx (GDK_WINDOW_HWND (window),
+                          dx, dy, /* in: scroll offsets */
+                          NULL, /* in: scroll rect, NULL == entire client area */
+                          &clipRect, /* in: restrict to */
+                          NULL, /* in: update region */
+                          NULL, /* out: update rect */
+                          SW_INVALIDATE | SW_SCROLLCHILDREN))
+	{
+	  PostMessage (GDK_WINDOW_HWND (window), WM_PAINT, 0,0);
+	}
+      else
         WIN32_API_FAILED ("ScrollWindowEx");
     }
 
#########################################
# Optimization of rendering
#########################################
--- pango/pango/pangowin32.c	2002/11/07 09:29:03	1.1
+++ pango/pango/pangowin32.c	2002/11/07 10:08:09
@@ -227,22 +227,15 @@
   return result;
 }
 
-/**
- * pango_win32_render:
- * @hdc:     the device context
- * @font:    the font in which to draw the string
- * @glyphs:  the glyph string to draw
- * @x:       the x position of start of string (in pixels)
- * @y:       the y position of baseline (in pixels)
- *
- * Render a PangoGlyphString onto a Windows DC
- */
-void 
-pango_win32_render (HDC               hdc,
-		    PangoFont        *font,
-		    PangoGlyphString *glyphs,
-		    int               x, 
-		    int               y)
+#define CACHE_SIZE 256
+static HFONT pango_win32_render_offset_previous_font;
+
+static int 
+pango_win32_render_offset (HDC               hdc,
+			   PangoFont        *font,
+			   PangoGlyphString *glyphs,
+			   int               x, 
+			   int               y)
 {
   HFONT old_hfont = NULL;
   HFONT hfont;
@@ -251,17 +244,33 @@
   gint *dX;
   gint last_x = 0;
   PangoGlyphUnit start_x_offset = 0, x_offset = 0;
+  /* temporary static storage for runs of less than 256 glyphes */
+  static guint16 stat_glyph_indices [CACHE_SIZE];
+  static gint stat_dX [CACHE_SIZE];
 
-  g_return_if_fail (glyphs != NULL);
+  if (glyphs == NULL)
+    return 0;
 
   hfont = pango_win32_get_hfont (font);
   if (!hfont)
-    return;
+    return 0;
 
-  old_hfont = SelectObject (hdc, hfont);
-		
-  glyph_indexes = g_new (guint16, glyphs->num_glyphs);
-  dX = g_new (INT, glyphs->num_glyphs);
+  if (pango_win32_render_offset_previous_font != hfont)
+    {
+      old_hfont = SelectObject (hdc, hfont);
+      pango_win32_render_offset_previous_font = hfont;
+    }
+
+  if (glyphs->num_glyphs > CACHE_SIZE)
+    {
+      glyph_indexes = g_new (guint16, glyphs->num_glyphs);
+      dX = g_new (INT, glyphs->num_glyphs);
+    }
+  else
+    {
+      glyph_indexes = stat_glyph_indices;
+      dX = stat_dX;
+    }
 
 #ifdef PANGO_WIN32_DEBUGGING
   PING (("num_glyphs:%d", glyphs->num_glyphs));
@@ -324,9 +333,34 @@
 	       glyph_indexes, num_valid_glyphs,
 	       dX);
 
-  SelectObject (hdc, old_hfont); /* restore */
-  g_free (glyph_indexes);
-  g_free (dX);
+  if (glyphs->num_glyphs > CACHE_SIZE)
+    {
+      g_free (glyph_indexes);
+      g_free (dX);
+    }
+
+  return PANGO_PIXELS (x_offset - start_x_offset);
+}
+
+/**
+ * pango_win32_render:
+ * @hdc:     the device context
+ * @font:    the font in which to draw the string
+ * @glyphs:  the glyph string to draw
+ * @x:       the x position of start of string (in pixels)
+ * @y:       the y position of baseline (in pixels)
+ *
+ * Render a PangoGlyphString onto a Windows DC
+ */
+void 
+pango_win32_render (HDC               hdc,
+		    PangoFont        *font,
+		    PangoGlyphString *glyphs,
+		    int               x, 
+		    int               y)
+{
+  pango_win32_render_offset_previous_font = NULL;
+  (void) pango_win32_render_offset (hdc, font, glyphs, x, y);
 }
 
 static void
@@ -611,18 +645,16 @@
 				int              y)
 {
   GSList *tmp_list = line->runs;
-  PangoRectangle overall_rect;
-  PangoRectangle logical_rect;
   PangoRectangle ink_rect;
+  COLORREF saved_fg_color = 0;
+  COLORREF saved_bk_color = 0;
   
-  int x_off = 0;
+  int x_off = 0, tmp_off;
+
+  pango_win32_render_offset_previous_font = NULL;
 
-  pango_layout_line_get_extents (line,NULL, &overall_rect);
-  
   while (tmp_list)
     {
-      HBRUSH oldfg = NULL;
-      HBRUSH brush = NULL;
       POINT points[2];
       PangoUnderline uline = PANGO_UNDERLINE_NONE;
       PangoLayoutRun *run = tmp_list->data;
@@ -633,69 +665,56 @@
 
       pango_win32_get_item_properties (run->item, &uline, &fg_color, &fg_set, &bg_color, &bg_set);
 
-      if (uline == PANGO_UNDERLINE_NONE)
-	pango_glyph_string_extents (run->glyphs, run->item->analysis.font,
-				    NULL, &logical_rect);
-      else
-	pango_glyph_string_extents (run->glyphs, run->item->analysis.font,
-				    &ink_rect, &logical_rect);
-
       if (bg_set)
-	{
-	  HBRUSH oldbrush;
-
-	  brush = CreateSolidBrush (RGB ((bg_color.color.red + 128) >> 8,
-					 (bg_color.color.green + 128) >> 8,
-					 (bg_color.color.blue + 128) >> 8));
-	  oldbrush = SelectObject (hdc, brush);
-	  Rectangle (hdc, x + PANGO_PIXELS (x_off + logical_rect.x),
-			  y + PANGO_PIXELS (overall_rect.y),
-			  PANGO_PIXELS (logical_rect.width),
-			  PANGO_PIXELS (overall_rect.height));
-	  SelectObject (hdc, oldbrush);
-	  DeleteObject (brush);
-	}
+	saved_bk_color = SetBkColor (hdc,
+				     RGB ((bg_color.color.red + 128) >> 8,
+					  (bg_color.color.green + 128) >> 8,
+					  (bg_color.color.blue + 128) >> 8));
 
       if (fg_set)
-	{
-	  brush = CreateSolidBrush (RGB ((fg_color.color.red + 128) >> 8,
-					 (fg_color.color.green + 128) >> 8,
-					 (fg_color.color.blue + 128) >> 8));
-	  oldfg = SelectObject (hdc, brush);
-	}
+	saved_fg_color = SetTextColor (hdc,
+				       RGB ((fg_color.color.red + 128) >> 8,
+					    (fg_color.color.green + 128) >> 8,
+					    (fg_color.color.blue + 128) >> 8));
+
+      tmp_off = pango_win32_render_offset (hdc, run->item->analysis.font,
+					   run->glyphs,
+					   x + PANGO_PIXELS (x_off), y);
 
-      pango_win32_render (hdc, run->item->analysis.font, run->glyphs,
-			  x + PANGO_PIXELS (x_off), y);
-
-      switch (uline)
+      if (uline != PANGO_UNDERLINE_NONE)
 	{
-	case PANGO_UNDERLINE_NONE:
-	  break;
-	case PANGO_UNDERLINE_DOUBLE:
-	  points[0].x = x + PANGO_PIXELS (x_off + ink_rect.x) - 1;
-	  points[0].y = points[1].y = y + 4;
-	  points[1].x = x + PANGO_PIXELS (x_off + ink_rect.x + ink_rect.width);
-	  Polyline (hdc, points, 2);
-	  /* Fall through */
-	case PANGO_UNDERLINE_SINGLE:
-	  points[0].y = points[1].y = y + 2;
-	  Polyline (hdc, points, 2);
-	  break;
-	case PANGO_UNDERLINE_LOW:
-	  points[0].x = x + PANGO_PIXELS (x_off + ink_rect.x) - 1;
-	  points[0].y = points[1].y = y + PANGO_PIXELS (ink_rect.y + ink_rect.height) + 2;
-	  points[1].x = x + PANGO_PIXELS (x_off + ink_rect.x + ink_rect.width);
-	  Polyline (hdc, points, 2);
-	  break;
+	  pango_glyph_string_extents (run->glyphs, run->item->analysis.font,
+				      &ink_rect, NULL);
+
+	  switch (uline)
+	    {
+	      case PANGO_UNDERLINE_NONE:
+		break;
+	      case PANGO_UNDERLINE_DOUBLE:
+		points[0].x = x + PANGO_PIXELS (x_off + ink_rect.x) - 1;
+		points[0].y = points[1].y = y + 4;
+		points[1].x = x + PANGO_PIXELS (x_off + ink_rect.x + ink_rect.width);
+		Polyline (hdc, points, 2);
+		/* Fall through */
+	      case PANGO_UNDERLINE_SINGLE:
+		points[0].y = points[1].y = y + 2;
+		Polyline (hdc, points, 2);
+		break;
+	      case PANGO_UNDERLINE_LOW:
+		points[0].x = x + PANGO_PIXELS (x_off + ink_rect.x) - 1;
+		points[0].y = points[1].y = y + PANGO_PIXELS (ink_rect.y + ink_rect.height) + 2;
+		points[1].x = x + PANGO_PIXELS (x_off + ink_rect.x + ink_rect.width);
+		Polyline (hdc, points, 2);
+		break;
+	    }
 	}
 
+      if (bg_set)
+	SetBkColor (hdc, saved_bk_color);
       if (fg_set)
-	{
-	  SelectObject (hdc, oldfg);
-	  DeleteObject (brush);
-	}
-      
-      x_off += logical_rect.width;
+	SetTextColor (hdc, saved_fg_color);
+
+      x_off += tmp_off;
     }
 }
 
@@ -720,6 +739,14 @@
   int indent;
   int width;
   int y_offset = 0;
+  COLORREF saved_foreground_color;
+  COLORREF saved_background_color;
+  HFONT saved_font;
+
+  /* save colors */
+  saved_foreground_color = GetTextColor (hdc);
+  saved_background_color = GetTextColor (hdc);
+  saved_font = SelectObject (hdc, NULL);
 
   gboolean first = TRUE;
   
@@ -780,6 +807,11 @@
       y_offset += logical_rect.height;
       tmp_list = tmp_list->next;
     }
+
+  /* restore colors */
+  SetTextColor (hdc, saved_foreground_color);
+  SetTextColor (hdc, saved_background_color);
+  SelectObject (hdc, saved_font);
 }
 
 /* This utility function is duplicated here and in pango-layout.c; should it be
--- glib/glib/glib.def.old	2002-11-05 11:52:22 +0100
+++ glib/glib/glib.def	2002-11-05 11:52:35 +0100
@@ -333,6 +333,7 @@
 	g_main_loop_ref
 	g_main_loop_run
 	g_main_loop_unref
+	g_main_thread_init
 	g_malloc
 	g_malloc0
 	g_markup_error_quark
--- gtk+/gdk/win32/gdkwindow-win32.c.old	2002-11-05 11:06:15 +0100
+++ gtk+/gdk/win32/gdkwindow-win32.c	2002-11-05 19:55:08 +0100
@@ -1526,7 +1526,7 @@
   if (!SetParent (window_id, parent_id))
 	WIN32_API_FAILED ("SetParent");
 #else /* make the modal window topmost instead */
-  if (!SetWindowPos (window_id, HWND_NOTOPMOST, 0, 0, 0, 0,
+  if (!SetWindowPos (window_id, HWND_TOPMOST, 0, 0, 0, 0,
                      SWP_NOMOVE | SWP_NOSIZE))
     WIN32_API_FAILED ("SetWindowPos");
 #endif
@@ -2397,11 +2397,7 @@
   if (GDK_WINDOW_DESTROYED (window))
     return;
 
-  if (GDK_WINDOW_IS_MAPPED (window))
-    {
-      g_warning ("gdk_window_unstick (%p) ???", GDK_WINDOW_HWND (window));
-    }
-  else
+  if (!GDK_WINDOW_IS_MAPPED (window))
     {
       /* Flip our client side flag, the real work happens on map. */
       gdk_synthesize_window_state (window,
--- gtk+/gdk/win32/gdkevents-win32.c	2002/11/05 19:15:02	1.2
+++ gtk+/gdk/win32/gdkevents-win32.c	2002/11/05 19:21:57
@@ -3192,6 +3192,8 @@
 	  if (k_grab_window == window)
 	    gdk_keyboard_ungrab (msg->time);
 
+	  private->state |= GDK_WINDOW_STATE_ICONIFIED;
+
 	  return_val = !GDK_WINDOW_DESTROYED (window);
 	}
       else if ((msg->wParam == SIZE_RESTORED
@@ -3218,6 +3220,14 @@
 	  GDK_WINDOW_IMPL_WIN32 (private->impl)->width = event->configure.width;
 	  GDK_WINDOW_IMPL_WIN32 (private->impl)->height = event->configure.height;
 
+	  if (msg->wParam == SIZE_RESTORED)
+	    private->state = 0;
+	  else if (msg->wParam == SIZE_MAXIMIZED)
+	    {
+	      private->state |= GDK_WINDOW_STATE_MAXIMIZED;
+	      private->state &= ~GDK_WINDOW_STATE_ICONIFIED;
+	    }
+
 	  if (private->resize_count > 1)
 	    private->resize_count -= 1;
 	  
--- gtk+/gdk/win32/Makefile.am	2002/11/25 10:58:36	1.1
+++ gtk+/gdk/win32/Makefile.am	2002/11/25 10:59:18
@@ -79,4 +79,4 @@
 libgdkinclude_HEADERS =		\
 	gdkwin32.h
 
-libgdk_win32_la_LIBADD = rc/gdk-win32res.lo
+libgdk_win32_la_LIBADD =
--- gtk+/gdk/win32/gdkmain-win32.c	2002/11/25 11:17:43	1.1
+++ gtk+/gdk/win32/gdkmain-win32.c	2002/11/25 11:20:28
@@ -964,4 +964,13 @@
       : ((v = gdk_drawable_get_visual (d)) ? v->depth : gdk_visual_get_system ()->depth)));
 }
 
+#else
+
+gchar *
+gdk_win32_gdkrectangle_to_string (const GdkRectangle *rect)
+{
+  return "";
+}
+
 #endif /* G_ENABLE_DEBUG */
+
--- pango/pango/pangowin32-fontmap.c	2002/11/28 10:43:07	1.1
+++ pango/pango/pangowin32-fontmap.c	2002/11/28 10:46:57
@@ -189,7 +189,14 @@
   class->list_families = pango_win32_font_map_list_families;
 
   if (pango_win32_hdc == NULL)
-    pango_win32_hdc = CreateDC ("DISPLAY", NULL, NULL, NULL);
+    {
+      pango_win32_hdc = CreateDC ("DISPLAY", NULL, NULL, NULL);
+      memset (&pango_win32_os_version_info, 0,
+              sizeof (pango_win32_os_version_info));
+      pango_win32_os_version_info.dwOSVersionInfoSize =
+        sizeof (OSVERSIONINFO);
+      GetVersionEx (&pango_win32_os_version_info);
+    }
 }
 
 static PangoWin32FontMap *fontmap = NULL;
--- pango/pango/pangowin32.c	2002/11/28 10:38:13	1.2
+++ pango/pango/pangowin32.c	2002/11/28 10:46:43
@@ -41,7 +41,7 @@
 
 #define PANGO_WIN32_UNKNOWN_FLAG 0x10000000
 
-HDC pango_win32_hdc;
+HDC pango_win32_hdc = NULL;
 OSVERSIONINFO pango_win32_os_version_info;
 
 typedef struct _PangoWin32FontClass   PangoWin32FontClass;
@@ -193,16 +193,6 @@
   font_class->find_shaper = pango_win32_font_find_shaper;
   font_class->get_glyph_extents = pango_win32_font_get_glyph_extents;
   font_class->get_metrics = pango_win32_font_get_metrics;
-
-  if (pango_win32_hdc == NULL)
-    {
-      pango_win32_hdc = CreateDC ("DISPLAY", NULL, NULL, NULL);
-      memset (&pango_win32_os_version_info, 0,
-	      sizeof (pango_win32_os_version_info));
-      pango_win32_os_version_info.dwOSVersionInfoSize =
-	sizeof (OSVERSIONINFO);
-      GetVersionEx (&pango_win32_os_version_info);
-    }
 }
 
 PangoWin32Font *
--- gtk+/gdk/win32/gdkevents-win32.c	2003/01/14 16:30:22	1.2
+++ gtk+/gdk/win32/gdkevents-win32.c	2003/01/14 17:30:39
@@ -43,6 +43,8 @@
 #include "gdkinput-win32.h"
 #include "gdkkeysyms.h"
 
+#include <windowsx.h>
+
 #ifdef G_WITH_CYGWIN
 #include <fcntl.h>
 #include <errno.h>
@@ -183,8 +185,8 @@
   msg.lParam = lparam;
   msg.time = _gdk_win32_get_next_tick (0);
   pos = GetMessagePos ();
-  msg.pt.x = LOWORD (pos);
-  msg.pt.y = HIWORD (pos);
+  msg.pt.x = GET_X_LPARAM (pos);
+  msg.pt.y = GET_Y_LPARAM (pos);
 
   event = _gdk_event_new ();
   ((GdkEventPrivate *)event)->flags = GDK_EVENT_PENDING;
@@ -1285,11 +1287,11 @@
   if (!(GDK_WINDOW_OBJECT (window)->event_mask & GDK_ENTER_NOTIFY_MASK))
     return;
 
-  /* Enter events are at LOWORD (msg->lParam), HIWORD
+  /* Enter events are at GET_X_LPARAM (msg->lParam), GET_Y_LPARAM
    * (msg->lParam) in msg->hwnd */
 
-  pt.x = LOWORD (msg->lParam);
-  pt.y = HIWORD (msg->lParam);
+  pt.x = GET_X_LPARAM (msg->lParam);
+  pt.y = GET_Y_LPARAM (msg->lParam);
   if (msg->hwnd != GDK_WINDOW_HWND (window))
     {
       ClientToScreen (msg->hwnd, &pt);
@@ -1528,11 +1530,12 @@
 {
   POINT pt;
 
-  pt.x = LOWORD (msg->lParam);
-  pt.y = HIWORD (msg->lParam);
+  pt.x = GET_X_LPARAM (msg->lParam);
+  pt.y = GET_Y_LPARAM (msg->lParam);
   ClientToScreen (GDK_WINDOW_HWND (window1), &pt);
   ScreenToClient (GDK_WINDOW_HWND (window2), &pt);
   msg->lParam = MAKELPARAM (pt.x, pt.y);
+
   GDK_NOTE (EVENTS, g_print ("...new coords are (%ld,%ld)\n", pt.x, pt.y));
 }
 
@@ -2034,8 +2037,8 @@
        * around that. Also, the position is in screen coordinates, not
        * client coordinates as with the button messages.
        */
-      pt.x = LOWORD (msg->lParam);
-      pt.y = HIWORD (msg->lParam);
+      pt.x = GET_X_LPARAM (msg->lParam);
+      pt.y = GET_Y_LPARAM (msg->lParam);
       if ((hwnd = WindowFromPoint (pt)) == NULL)
 	goto done;
 
@@ -2073,8 +2076,8 @@
       _gdk_windowing_window_get_offsets (window, &xoffset, &yoffset);
       event->scroll.x = (gint16) pt.x + xoffset;
       event->scroll.y = (gint16) pt.y + yoffset;
-      event->scroll.x_root = (gint16) LOWORD (msg->lParam);
-      event->scroll.y_root = (gint16) HIWORD (msg->lParam);
+      event->scroll.x_root = (gint16) GET_X_LPARAM (msg->lParam);
+      event->scroll.y_root = (gint16) GET_Y_LPARAM (msg->lParam);
       event->scroll.state = 0;	/* No state information with MSH_MOUSEWHEEL */
       event->scroll.device = _gdk_core_pointer;
       return_val = !GDK_WINDOW_DESTROYED (window);
@@ -2553,7 +2556,7 @@
 		g_print ("WM_%cBUTTONDOWN: %p  (%d,%d)\n",
 			 " LMR"[button],
 			 msg->hwnd,
-			 LOWORD (msg->lParam), HIWORD (msg->lParam)));
+			 GET_X_LPARAM (msg->lParam), GET_Y_LPARAM (msg->lParam)));
 
       if (((GdkWindowObject *) window)->extension_events != 0
 	  && _gdk_input_ignore_core)
@@ -2593,8 +2596,8 @@
       event->button.time = _gdk_win32_get_next_tick (msg->time);
       if (window != orig_window)
 	translate_mouse_coords (orig_window, window, msg);
-      event->button.x = current_x = (gint16) LOWORD (msg->lParam);
-      event->button.y = current_y = (gint16) HIWORD (msg->lParam);
+      event->button.x = current_x = (gint16) GET_X_LPARAM (msg->lParam);
+      event->button.y = current_y = (gint16) GET_Y_LPARAM (msg->lParam);
       _gdk_windowing_window_get_offsets (window, &xoffset, &yoffset);
       event->button.x += xoffset;  /* XXX translate current_x, y too? */
       event->button.y += yoffset;
@@ -2622,7 +2625,7 @@
 		g_print ("WM_%cBUTTONUP: %p  (%d,%d)\n",
 			 " LMR"[button],
 			 msg->hwnd,
-			 LOWORD (msg->lParam), HIWORD (msg->lParam)));
+			 GET_X_LPARAM (msg->lParam), GET_Y_LPARAM (msg->lParam)));
 
       ASSIGN_WINDOW (find_window_for_pointer_event (window, msg));
 
@@ -2651,8 +2654,8 @@
 	  if (window != orig_window)
 	    translate_mouse_coords (orig_window, window, msg);
 	  _gdk_windowing_window_get_offsets (window, &xoffset, &yoffset);
-	  event->button.x = (gint16) LOWORD (msg->lParam) + xoffset;
-	  event->button.y = (gint16) HIWORD (msg->lParam) + yoffset;
+	  event->button.x = (gint16) GET_X_LPARAM (msg->lParam) + xoffset;
+	  event->button.y = (gint16) GET_Y_LPARAM (msg->lParam) + yoffset;
 	  event->button.x_root = current_x_root = msg->pt.x;
 	  event->button.y_root = current_y_root = msg->pt.y;
 	  event->button.axes = NULL;
@@ -2673,7 +2676,7 @@
       GDK_NOTE (EVENTS,
 		g_print ("WM_MOUSEMOVE: %p  %#x (%d,%d)\n",
 			 msg->hwnd, msg->wParam,
-			 LOWORD (msg->lParam), HIWORD (msg->lParam)));
+			 GET_X_LPARAM (msg->lParam), GET_Y_LPARAM (msg->lParam)));
 
       ASSIGN_WINDOW (find_window_for_pointer_event (window, msg));
 
@@ -2682,8 +2685,8 @@
        * even if the mouse doesn't move. This disturbs gtk.
        */
       if (window == current_window
-	  && LOWORD (msg->lParam) == current_x
-	  && HIWORD (msg->lParam) == current_y)
+	  && GET_X_LPARAM (msg->lParam) == current_x
+	  && GET_Y_LPARAM (msg->lParam) == current_y)
 	break;
 
       /* HB: only process mouse move messages if we own the active window. */
@@ -2713,8 +2716,8 @@
       event->motion.time = _gdk_win32_get_next_tick (msg->time);
       if (window != orig_window)
 	translate_mouse_coords (orig_window, window, msg);
-      event->motion.x = current_x = (gint16) LOWORD (msg->lParam);
-      event->motion.y = current_y = (gint16) HIWORD (msg->lParam);
+      event->motion.x = current_x = (gint16) GET_X_LPARAM (msg->lParam);
+      event->motion.y = current_y = (gint16) GET_Y_LPARAM (msg->lParam);
       _gdk_windowing_window_get_offsets (window, &xoffset, &yoffset);
       event->motion.x += xoffset;
       event->motion.y += yoffset;
@@ -2732,7 +2735,7 @@
       GDK_NOTE (EVENTS,
 		g_print ("WM_NCMOUSEMOVE: %p  x,y: %d %d\n",
 			 msg->hwnd,
-			 LOWORD (msg->lParam), HIWORD (msg->lParam)));
+			 GET_X_LPARAM (msg->lParam), GET_Y_LPARAM (msg->lParam)));
       if (current_window != NULL
 	  && (GDK_WINDOW_OBJECT (current_window)->event_mask & GDK_LEAVE_NOTIFY_MASK))
 	{
@@ -2765,7 +2768,7 @@
 
     case WM_MOUSEWHEEL:
       GDK_NOTE (EVENTS, g_print ("WM_MOUSEWHEEL: %p %d\n",
-				 msg->hwnd, HIWORD (msg->wParam)));
+				 msg->hwnd, GET_Y_LPARAM (msg->wParam)));
 
       event->scroll.type = GDK_SCROLL;
 
@@ -2774,8 +2777,8 @@
        * coordinates as with the button messages. I love the
        * consistency of Windows.
        */
-      pt.x = LOWORD (msg->lParam);
-      pt.y = HIWORD (msg->lParam);
+      pt.x = GET_X_LPARAM (msg->lParam);
+      pt.y = GET_Y_LPARAM (msg->lParam);
       if ((hwnd = WindowFromPoint (pt)) == NULL)
 	break;
 
@@ -2813,8 +2816,8 @@
       _gdk_windowing_window_get_offsets (window, &xoffset, &yoffset);
       event->scroll.x = (gint16) pt.x + xoffset;
       event->scroll.y = (gint16) pt.y + yoffset;
-      event->scroll.x_root = (gint16) LOWORD (msg->lParam);
-      event->scroll.y_root = (gint16) HIWORD (msg->lParam);
+      event->scroll.x_root = (gint16) GET_X_LPARAM (msg->lParam);
+      event->scroll.y_root = (gint16) GET_Y_LPARAM (msg->lParam);
       event->scroll.state = build_pointer_event_state (msg);
       event->scroll.device = _gdk_core_pointer;
       return_val = !GDK_WINDOW_DESTROYED (window);
@@ -3200,7 +3203,7 @@
     case WM_MOVE:
       GDK_NOTE (EVENTS, g_print ("WM_MOVE: %p  (%d,%d)\n",
 				 msg->hwnd,
-				 LOWORD (msg->lParam), HIWORD (msg->lParam)));
+				 GET_X_LPARAM (msg->lParam), GET_Y_LPARAM (msg->lParam)));
 
       if (!(private->event_mask & GDK_STRUCTURE_MASK))
 	break;
@@ -3211,8 +3214,8 @@
 	{
 	  event->configure.type = GDK_CONFIGURE;
 	  event->configure.window = window;
-	  event->configure.x = LOWORD (msg->lParam);
-	  event->configure.y = HIWORD (msg->lParam);
+	  event->configure.x = GET_X_LPARAM (msg->lParam);
+	  event->configure.y = GET_Y_LPARAM (msg->lParam);
 	  GetClientRect (msg->hwnd, &rect);
 	  event->configure.width = rect.right;
 	  event->configure.height = rect.bottom;
--- gtk+/gtk/gtkmenuitem.c	2003/01/15 11:24:21	1.1
+++ gtk+/gtk/gtkmenuitem.c	2003/01/15 11:43:42
@@ -870,7 +870,7 @@
   gint screen_width;
   gint screen_height;
   gint twidth, theight;
-  gint tx, ty;
+  gint tx, ty, otx, oty;
 
   g_return_if_fail (menu != NULL);
   g_return_if_fail (x != NULL);
@@ -885,14 +885,14 @@
   screen_width = gdk_screen_width ();
   screen_height = gdk_screen_height ();
 
-  if (!gdk_window_get_origin (widget->window, &tx, &ty))
+  if (!gdk_window_get_origin (widget->window, &otx, &oty))
     {
       g_warning ("Menu not on screen");
       return;
     }
 
-  tx += widget->allocation.x;
-  ty += widget->allocation.y;
+  tx = otx + widget->allocation.x;
+  ty = oty + widget->allocation.y;
 
   switch (menu_item->submenu_placement)
     {
@@ -939,14 +939,14 @@
       ty += widget->allocation.height / 4;
 
       /* If the height of the menu doesn't fit we move it upward. */
-      ty = CLAMP (ty, 0, MAX (0, screen_height - theight));
+      ty = oty < 0 ? ty : CLAMP (ty, 0, MAX (0, screen_height - theight));
       break;
     }
 
   /* If we have negative, tx, here it is because we can't get
    * the menu all the way on screen. Favor the left portion.
    */
-  *x = CLAMP (tx, 0, MAX (0, screen_width - twidth));
+  *x = otx < 0 ? tx : CLAMP (tx, 0, MAX (0, screen_width - twidth));
   *y = ty;
 }
 
