2010-04-16  Arnaud Charlet  <charlet@adacore.com>

	* gtk/gtktreemodelfilter.[ch]: Import all changes from Gtk+ 2.18.9

2009-09-19  Arnaud Charlet  <charlet@adacore.com>

	* gtk/gtktreemodel.c (gtk_tree_model_row_has_child_toggled): Replace
	g_return_if_fail by explicit check, since path may legitimately
	be NULL (I918-021).

2009-01-12  Nicolas Setton  <setton@adacore.com>

	* gtktreeview.c (gtk_tree_view_enter_notify): Do not react to
	 crossing events.
	(gtk_tree_view_leave_notify): Likewise.
        Prevents unwanted side-effects of synth-crossing. (I106-018)

2009-01-06  Nicolas Setton  <setton@adacore.com>

	* gtk/gtktreeview.c (gtk_tree_view_enter_notify): Put kludge to
	work around Gtk+ bug in handling of keyboard keys+focus events in
	tree view (HC15-032).

2006-02-23  Arnaud Charlet  <charlet@adacore.com>

	* gdk/x11/gdkasync.c: #define ANSICPP on Solaris, to work around
	bug in X11/Xmd.h on Solaris 8.

2003-11-27  Arnaud Charlet  <charlet@adacore.com>

	* gtk/gtktextview.c (incremental_validate_callback): Increase amount
	of characters validated at each call, this gives a better behavior
	when loading big files.
	Submitted at http://bugzilla.gnome.org/show_bug.cgi?id=332057

--- gtk/gtktextview.c.old	2006-02-17 16:11:04.000000000 +0100
+++ gtk/gtktextview.c	2006-02-20 17:08:54.691581240 +0100
@@ -3273,7 +3273,7 @@ incremental_validate_callback (gpointer 
   
   DV(g_print(G_STRLOC"\n"));
   
-  gtk_text_layout_validate (text_view->layout, 2000);
+  gtk_text_layout_validate (text_view->layout, 20000);
 
   gtk_text_view_update_adjustments (text_view);
   
--- gdk/x11/gdkasync.c.old	Thu Feb 23 11:30:46 2006
+++ gdk/x11/gdkasync.c	Thu Feb 23 11:48:14 2006
@@ -47,6 +47,11 @@ in this Software without prior written a
 #ifdef NEED_XIPROTO_H_FOR_XREPLY
 #include <X11/extensions/XIproto.h>
 #endif
+
+#if defined (sun) && defined (__SVR4)
+#define ANSICPP
+#endif
+
 #include <X11/Xlibint.h>
 #include "gdkasync.h"
 #include "gdkx.h"
--- gtk/gtktreeview.c.old	2008-11-24 07:35:35.000000000 +0100
+++ gtk/gtktreeview.c	2009-01-06 15:14:25.171875000 +0100
@@ -5459,6 +5459,9 @@ gtk_tree_view_enter_notify (GtkWidget   
   if (tree_view->priv->tree == NULL)
     return FALSE;
 
+  if (event->y == 0)
+    return FALSE;
+
   /* find the node internally */
   new_y = TREE_WINDOW_Y_TO_RBTREE_Y(tree_view, event->y);
   if (new_y < 0)
--- gtk/gtktreeview.c.orig	2009-01-12 11:49:09.000000000 +0100
+++ gtk/gtktreeview.c	2009-01-12 15:44:05.000000000 +0100
@@ -5461,6 +5461,12 @@ gtk_tree_view_enter_notify (GtkWidget   
   GtkRBNode *node;
   gint new_y;
 
+  if (event->mode == GDK_CROSSING_GRAB 
+      || event->mode == GDK_CROSSING_NORMAL
+      || event->mode == GDK_CROSSING_GTK_GRAB
+      || event->mode == GDK_CROSSING_GTK_UNGRAB)
+    return TRUE;
+
   /* Sanity check it */
   if (event->window != tree_view->priv->bin_window)
     return FALSE;
@@ -5487,7 +5493,10 @@ gtk_tree_view_leave_notify (GtkWidget   
 {
   GtkTreeView *tree_view;
 
-  if (event->mode == GDK_CROSSING_GRAB)
+  if (event->mode == GDK_CROSSING_GRAB 
+      || event->mode == GDK_CROSSING_NORMAL
+      || event->mode == GDK_CROSSING_GTK_GRAB
+      || event->mode == GDK_CROSSING_GTK_UNGRAB)
     return TRUE;
 
   tree_view = GTK_TREE_VIEW (widget);
--- gtk/gtktreemodel.c.old	2009-09-19 12:03:49.804000000 +0200
+++ gtk/gtktreemodel.c	2009-09-19 12:41:00.954000000 +0200
@@ -1512,8 +1512,11 @@ gtk_tree_model_row_has_child_toggled (Gt
 				      GtkTreeIter  *iter)
 {
   g_return_if_fail (GTK_IS_TREE_MODEL (tree_model));
-  g_return_if_fail (path != NULL);
-  g_return_if_fail (iter != NULL);
+
+  if (path == NULL)
+    return;
+  if (iter == NULL)
+    return;
 
   g_signal_emit (tree_model, tree_model_signals[ROW_HAS_CHILD_TOGGLED], 0, path, iter);
 }
--- gtk/gtktreemodelfilter.h	2009-06-04 21:18:04.000000000 +0200
+++ gtk/gtktreemodelfilter.h	2010-03-12 16:09:14.000000000 +0100
@@ -35,7 +35,7 @@ G_BEGIN_DECLS
 #define GTK_TREE_MODEL_FILTER_CLASS(vtable)     (G_TYPE_CHECK_CLASS_CAST ((vtable), GTK_TYPE_TREE_MODEL_FILTER, GtkTreeModelFilterClass))
 #define GTK_IS_TREE_MODEL_FILTER(obj)           (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GTK_TYPE_TREE_MODEL_FILTER))
 #define GTK_IS_TREE_MODEL_FILTER_CLASS(vtable)  (G_TYPE_CHECK_CLASS_TYPE ((vtable), GTK_TYPE_TREE_MODEL_FILTER))
-#define GTK_TREE_MODEL_FILTER_GET_CLASS(inst)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GTK_TYPE_TREE_MODEL_FILTER, GtkTreeModelFilterClass))
+#define GTK_TREE_MODEL_FILTER_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GTK_TYPE_TREE_MODEL_FILTER, GtkTreeModelFilterClass))
 
 typedef gboolean (* GtkTreeModelFilterVisibleFunc) (GtkTreeModel *model,
                                                     GtkTreeIter  *iter,
--- gtk/gtktreemodelfilter.c	2009-08-29 04:07:54.000000000 +0200
+++ gtk/gtktreemodelfilter.c	2010-03-17 14:31:48.000000000 +0100
@@ -73,7 +73,7 @@ struct _FilterLevel
   gint ref_count;
   gint visible_nodes;
 
-  FilterElt *parent_elt;
+  gint parent_elt_index;
   FilterLevel *parent_level;
 };
 
@@ -129,6 +129,9 @@ enum
 #define FILTER_ELT(filter_elt) ((FilterElt *)filter_elt)
 #define FILTER_LEVEL(filter_level) ((FilterLevel *)filter_level)
 
+#define FILTER_LEVEL_PARENT_ELT(level) (&g_array_index (FILTER_LEVEL ((level))->parent_level->array, FilterElt, FILTER_LEVEL ((level))->parent_elt_index))
+#define FILTER_LEVEL_ELT_INDEX(level, elt) (FILTER_ELT ((elt)) - FILTER_ELT (FILTER_LEVEL ((level))->array->data))
+
 /* general code (object/interface init, properties, etc) */
 static void         gtk_tree_model_filter_tree_model_init                 (GtkTreeModelIface       *iface);
 static void         gtk_tree_model_filter_drag_source_init                (GtkTreeDragSourceIface  *iface);
@@ -214,7 +217,7 @@ static gboolean    gtk_tree_model_filter
 /* private functions */
 static void        gtk_tree_model_filter_build_level                      (GtkTreeModelFilter     *filter,
                                                                            FilterLevel            *parent_level,
-                                                                           FilterElt              *parent_elt,
+                                                                           gint                    parent_elt_index,
                                                                            gboolean                emit_inserted);
 
 static void        gtk_tree_model_filter_free_level                       (GtkTreeModelFilter     *filter,
@@ -257,6 +260,8 @@ static GtkTreePath *gtk_real_tree_model_
 static FilterElt   *gtk_tree_model_filter_get_nth                         (GtkTreeModelFilter     *filter,
                                                                            FilterLevel            *level,
                                                                            int                     n);
+static gboolean    gtk_tree_model_filter_elt_is_visible_in_target         (FilterLevel            *level,
+                                                                           FilterElt              *elt);
 static FilterElt   *gtk_tree_model_filter_get_nth_visible                 (GtkTreeModelFilter     *filter,
                                                                            FilterLevel            *level,
                                                                            int                     n);
@@ -436,12 +441,13 @@ gtk_tree_model_filter_get_property (GObj
 static void
 gtk_tree_model_filter_build_level (GtkTreeModelFilter *filter,
                                    FilterLevel        *parent_level,
-                                   FilterElt          *parent_elt,
+                                   gint                parent_elt_index,
                                    gboolean            emit_inserted)
 {
   GtkTreeIter iter;
   GtkTreeIter first_node;
   GtkTreeIter root;
+  FilterElt *parent_elt = NULL;
   FilterLevel *new_level;
   gint length = 0;
   gint i;
@@ -474,6 +480,8 @@ gtk_tree_model_filter_build_level (GtkTr
       GtkTreeIter parent_iter;
       GtkTreeIter child_parent_iter;
 
+      parent_elt = &g_array_index (parent_level->array, FilterElt, parent_elt_index);
+
       parent_iter.stamp = filter->priv->stamp;
       parent_iter.user_data = parent_level;
       parent_iter.user_data2 = parent_elt;
@@ -499,10 +507,10 @@ gtk_tree_model_filter_build_level (GtkTr
                                         length);
   new_level->ref_count = 0;
   new_level->visible_nodes = 0;
-  new_level->parent_elt = parent_elt;
+  new_level->parent_elt_index = parent_elt_index;
   new_level->parent_level = parent_level;
 
-  if (parent_elt)
+  if (parent_elt_index >= 0)
     parent_elt->children = new_level;
   else
     filter->priv->root = new_level;
@@ -510,9 +518,9 @@ gtk_tree_model_filter_build_level (GtkTr
   /* increase the count of zero ref_counts */
   while (parent_level)
     {
-      parent_elt->zero_ref_count++;
+      g_array_index (parent_level->array, FilterElt, parent_elt_index).zero_ref_count++;
 
-      parent_elt = parent_level->parent_elt;
+      parent_elt_index = parent_level->parent_elt_index;
       parent_level = parent_level->parent_level;
     }
   if (new_level != filter->priv->root)
@@ -526,6 +534,7 @@ gtk_tree_model_filter_build_level (GtkTr
     {
       if (gtk_tree_model_filter_visible (filter, &iter))
         {
+          GtkTreeIter f_iter;
           FilterElt filter_elt;
 
           filter_elt.offset = i;
@@ -540,26 +549,29 @@ gtk_tree_model_filter_build_level (GtkTr
           g_array_append_val (new_level->array, filter_elt);
           new_level->visible_nodes++;
 
-          if (new_level->parent_level || filter->priv->virtual_root)
-            {
-              GtkTreeIter f_iter;
-
-              f_iter.stamp = filter->priv->stamp;
-              f_iter.user_data = new_level;
-              f_iter.user_data2 = &(g_array_index (new_level->array, FilterElt, new_level->array->len - 1));
+          f_iter.stamp = filter->priv->stamp;
+          f_iter.user_data = new_level;
+          f_iter.user_data2 = &(g_array_index (new_level->array, FilterElt, new_level->array->len - 1));
 
-              gtk_tree_model_filter_ref_node (GTK_TREE_MODEL (filter), &f_iter);
+          if (new_level->parent_level || filter->priv->virtual_root)
+            gtk_tree_model_filter_ref_node (GTK_TREE_MODEL (filter), &f_iter);
 
-              if (emit_inserted)
-                {
-                  GtkTreePath *f_path;
+          if (emit_inserted)
+            {
+              GtkTreePath *f_path;
+              GtkTreeIter children;
 
-                  f_path = gtk_tree_model_get_path (GTK_TREE_MODEL (filter),
-                                                    &f_iter);
-                  gtk_tree_model_row_inserted (GTK_TREE_MODEL (filter),
-                                               f_path, &f_iter);
-                  gtk_tree_path_free (f_path);
-                }
+              f_path = gtk_tree_model_get_path (GTK_TREE_MODEL (filter),
+                                                &f_iter);
+              gtk_tree_model_row_inserted (GTK_TREE_MODEL (filter),
+                                           f_path, &f_iter);
+              gtk_tree_path_free (f_path);
+
+              if (gtk_tree_model_iter_children (filter->priv->child_model,
+                                                &children, &iter))
+                gtk_tree_model_filter_update_children (filter,
+                                                       new_level,
+                                                       FILTER_ELT (f_iter.user_data2));
             }
         }
       i++;
@@ -626,13 +638,13 @@ gtk_tree_model_filter_free_level (GtkTre
   if (filter_level->ref_count == 0)
     {
       FilterLevel *parent_level = filter_level->parent_level;
-      FilterElt *parent_elt = filter_level->parent_elt;
+      gint parent_elt_index = filter_level->parent_elt_index;
 
       while (parent_level)
         {
-	  parent_elt->zero_ref_count--;
+	  g_array_index (parent_level->array, FilterElt, parent_elt_index).zero_ref_count--;
 
-	  parent_elt = parent_level->parent_elt;
+	  parent_elt_index = parent_level->parent_elt_index;
 	  parent_level = parent_level->parent_level;
         }
 
@@ -640,8 +652,8 @@ gtk_tree_model_filter_free_level (GtkTre
         filter->priv->zero_ref_count--;
     }
 
-  if (filter_level->parent_elt)
-    filter_level->parent_elt->children = NULL;
+  if (filter_level->parent_elt_index >= 0)
+    FILTER_LEVEL_PARENT_ELT (filter_level)->children = NULL;
   else
     filter->priv->root = NULL;
 
@@ -672,7 +684,10 @@ gtk_tree_model_filter_elt_get_path (Filt
     {
       gtk_tree_path_prepend_index (path, walker2->offset);
 
-      walker2 = walker->parent_elt;
+      if (!walker->parent_level)
+        break;
+
+      walker2 = FILTER_LEVEL_PARENT_ELT (walker);
       walker = walker->parent_level;
     }
 
@@ -804,6 +819,32 @@ gtk_tree_model_filter_get_nth (GtkTreeMo
   return &g_array_index (level->array, FilterElt, n);
 }
 
+static gboolean
+gtk_tree_model_filter_elt_is_visible_in_target (FilterLevel *level,
+                                                FilterElt   *elt)
+{
+  gint elt_index;
+
+  if (!elt->visible)
+    return FALSE;
+
+  if (level->parent_elt_index == -1)
+    return TRUE;
+
+  do
+    {
+      elt_index = level->parent_elt_index;
+      level = level->parent_level;
+
+      if (elt_index >= 0
+          && !g_array_index (level->array, FilterElt, elt_index).visible)
+        return FALSE;
+    }
+  while (level);
+
+  return TRUE;
+}
+
 static FilterElt *
 gtk_tree_model_filter_get_nth_visible (GtkTreeModelFilter *filter,
                                        FilterLevel        *level,
@@ -848,11 +889,11 @@ gtk_tree_model_filter_fetch_child (GtkTr
   FilterElt elt;
 
   /* check if child exists and is visible */
-  if (level->parent_elt)
+  if (level->parent_elt_index >= 0)
     {
       c_parent_path =
         gtk_tree_model_filter_elt_get_path (level->parent_level,
-                                            level->parent_elt,
+                                            FILTER_LEVEL_PARENT_ELT (level),
                                             filter->priv->virtual_root);
       if (!c_parent_path)
         return NULL;
@@ -931,7 +972,7 @@ gtk_tree_model_filter_fetch_child (GtkTr
     {
       FilterElt *e = &(g_array_index (level->array, FilterElt, i));
       if (e->children)
-        e->children->parent_elt = e;
+        e->children->parent_elt_index = i;
     }
 
   c_iter.stamp = filter->priv->stamp;
@@ -950,14 +991,18 @@ gtk_tree_model_filter_remove_node (GtkTr
 {
   FilterElt *elt, *parent;
   FilterLevel *level, *parent_level;
-  gint i, length;
+  gint i, length, parent_elt_index;
 
   gboolean emit_child_toggled = FALSE;
 
   level = FILTER_LEVEL (iter->user_data);
   elt = FILTER_ELT (iter->user_data2);
 
-  parent = level->parent_elt;
+  parent_elt_index = level->parent_elt_index;
+  if (parent_elt_index >= 0)
+    parent = FILTER_LEVEL_PARENT_ELT (level);
+  else
+    parent = NULL;
   parent_level = level->parent_level;
 
   length = level->array->len;
@@ -972,7 +1017,10 @@ gtk_tree_model_filter_remove_node (GtkTr
    *  if level != root level and visible nodes == 0, emit row-has-child-toggled.
    */
 
-  if (level != filter->priv->root && level->visible_nodes == 0)
+  if (level != filter->priv->root
+      && level->visible_nodes == 0
+      && parent
+      && parent->visible)
     emit_child_toggled = TRUE;
 
   if (length > 1)
@@ -980,9 +1028,13 @@ gtk_tree_model_filter_remove_node (GtkTr
       GtkTreePath *path;
       FilterElt *tmp;
 
-      /* we emit row-deleted, and remove the node from the cache.
+      /* We emit row-deleted, and remove the node from the cache.
+       * If it has any children, these will be removed here as well.
        */
 
+      if (elt->children)
+        gtk_tree_model_filter_free_level (filter, elt->children);
+
       path = gtk_tree_model_get_path (GTK_TREE_MODEL (filter), iter);
       elt->visible = FALSE;
       gtk_tree_model_filter_increment_stamp (filter);
@@ -1015,7 +1067,7 @@ gtk_tree_model_filter_remove_node (GtkTr
                */
               elt = &g_array_index (level->array, FilterElt, i);
               if (elt->children)
-                elt->children->parent_elt = elt;
+                elt->children->parent_elt_index = i;
             }
         }
     }
@@ -1024,10 +1076,16 @@ gtk_tree_model_filter_remove_node (GtkTr
     {
       GtkTreePath *path;
 
-      /* we emit row-deleted, but keep the node in the cache and
-       * referenced.
+      /* We emit row-deleted, but keep the node in the cache and
+       * referenced.  Its children will be removed.
        */
 
+      if (elt->children)
+        {
+          gtk_tree_model_filter_free_level (filter, elt->children);
+          elt->children = NULL;
+        }
+
       path = gtk_tree_model_get_path (GTK_TREE_MODEL (filter), iter);
       elt->visible = FALSE;
       gtk_tree_model_filter_increment_stamp (filter);
@@ -1038,7 +1096,7 @@ gtk_tree_model_filter_remove_node (GtkTr
     {
       GtkTreePath *path;
 
-      /* blow level away */
+      /* Blow level away, including any child levels */
 
       path = gtk_tree_model_get_path (GTK_TREE_MODEL (filter), iter);
       elt->visible = FALSE;
@@ -1170,6 +1228,7 @@ gtk_tree_model_filter_row_changed (GtkTr
   gboolean requested_state;
   gboolean current_state;
   gboolean free_c_path = FALSE;
+  gboolean signals_emitted = FALSE;
 
   g_return_if_fail (c_path != NULL || c_iter != NULL);
 
@@ -1230,14 +1289,18 @@ gtk_tree_model_filter_row_changed (GtkTr
        */
       gtk_tree_path_free (path);
       path = gtk_tree_model_get_path (GTK_TREE_MODEL (filter), &iter);
-      gtk_tree_model_row_changed (GTK_TREE_MODEL (filter), path, &iter);
 
       level = FILTER_LEVEL (iter.user_data);
       elt = FILTER_ELT (iter.user_data2);
 
-      /* and update the children */
-      if (gtk_tree_model_iter_children (c_model, &children, &real_c_iter))
-        gtk_tree_model_filter_update_children (filter, level, elt);
+      if (gtk_tree_model_filter_elt_is_visible_in_target (level, elt))
+        {
+          gtk_tree_model_row_changed (GTK_TREE_MODEL (filter), path, &iter);
+
+          /* and update the children */
+          if (gtk_tree_model_iter_children (c_model, &children, &real_c_iter))
+            gtk_tree_model_filter_update_children (filter, level, elt);
+        }
 
       goto done;
     }
@@ -1250,27 +1313,29 @@ gtk_tree_model_filter_row_changed (GtkTr
   /* make sure the new item has been pulled in */
   if (!filter->priv->root)
     {
-      gint i;
       FilterLevel *root;
 
-      gtk_tree_model_filter_build_level (filter, NULL, NULL, FALSE);
+      gtk_tree_model_filter_build_level (filter, NULL, -1, TRUE);
 
-      root = FILTER_LEVEL (filter->priv->root);
+      /* We will only proceed below if the item is found.  If the item
+       * is found, we can be sure row-inserted has just been emitted
+       * for it.
+       */
+      signals_emitted = TRUE;
 
-      if (root)
-        {
-          for (i = 0; i < root->array->len; i++)
-            g_array_index (root->array, FilterElt, i).visible = FALSE;
-          root->visible_nodes = 0;
-        }
+      root = FILTER_LEVEL (filter->priv->root);
     }
 
   gtk_tree_model_filter_increment_stamp (filter);
 
+  /* We need to allow to build new levels, because we are then pulling
+   * in a child in an invisible level.  We only want to find path if it
+   * is in a visible level (and thus has a parent that is visible).
+   */
   if (!path)
     path = gtk_real_tree_model_filter_convert_child_path_to_path (filter,
                                                                   c_path,
-                                                                  TRUE,
+                                                                  FALSE,
                                                                   TRUE);
 
   if (!path)
@@ -1289,15 +1354,32 @@ gtk_tree_model_filter_row_changed (GtkTr
       level->visible_nodes++;
     }
 
-  if ((level->parent_elt && level->parent_elt->visible) || !level->parent_elt)
+  if (gtk_tree_model_filter_elt_is_visible_in_target (level, elt))
     {
       /* visibility changed -- reget path */
       gtk_tree_path_free (path);
       path = gtk_tree_model_get_path (GTK_TREE_MODEL (filter), &iter);
 
-      gtk_tree_model_row_inserted (GTK_TREE_MODEL (filter), path, &iter);
+      if (!signals_emitted)
+        gtk_tree_model_row_inserted (GTK_TREE_MODEL (filter), path, &iter);
+
+      if (level->parent_level && level->visible_nodes == 1)
+        {
+          /* We know that this is the first visible node in this level, so
+           * we need to emit row-has-child-toggled on the parent.  This
+           * does not apply to the root level.
+           */
+
+          gtk_tree_path_up (path);
+          gtk_tree_model_get_iter (GTK_TREE_MODEL (filter), &iter, path);
+
+          gtk_tree_model_row_has_child_toggled (GTK_TREE_MODEL (filter),
+                                                path,
+                                                &iter);
+        }
 
-      if (gtk_tree_model_iter_children (c_model, &children, c_iter))
+      if (!signals_emitted
+          && gtk_tree_model_iter_children (c_model, &children, c_iter))
         gtk_tree_model_filter_update_children (filter, level, elt);
     }
 
@@ -1379,7 +1461,7 @@ gtk_tree_model_filter_row_inserted (GtkT
         goto done;
 
       /* build level will pull in the new child */
-      gtk_tree_model_filter_build_level (filter, NULL, NULL, FALSE);
+      gtk_tree_model_filter_build_level (filter, NULL, -1, FALSE);
 
       if (filter->priv->root
           && FILTER_LEVEL (filter->priv->root)->visible_nodes)
@@ -1506,7 +1588,7 @@ gtk_tree_model_filter_row_inserted (GtkT
     {
       FilterElt *e = &g_array_index (level->array, FilterElt, i);
       if (e->children)
-        e->children->parent_elt = e;
+        e->children->parent_elt_index = i;
     }
 
   /* don't emit the signal if we aren't visible */
@@ -1555,6 +1637,7 @@ gtk_tree_model_filter_row_has_child_togg
   GtkTreeIter iter;
   FilterLevel *level;
   FilterElt *elt;
+  gboolean requested_state;
 
   g_return_if_fail (c_path != NULL && c_iter != NULL);
 
@@ -1564,12 +1647,13 @@ gtk_tree_model_filter_row_has_child_togg
   if (filter->priv->virtual_root && !filter->priv->root
       && !gtk_tree_path_compare (c_path, filter->priv->virtual_root))
     {
-      gtk_tree_model_filter_build_level (filter, NULL, NULL, TRUE);
+      gtk_tree_model_filter_build_level (filter, NULL, -1, TRUE);
       return;
     }
 
-  if (!gtk_tree_model_filter_visible (filter, c_iter))
-    return;
+  /* For all other levels, there is a chance that the visibility state
+   * of the parent has changed now.
+   */
 
   path = gtk_real_tree_model_filter_convert_child_path_to_path (filter,
                                                                 c_path,
@@ -1580,18 +1664,60 @@ gtk_tree_model_filter_row_has_child_togg
 
   gtk_tree_model_filter_get_iter_full (GTK_TREE_MODEL (data), &iter, path);
 
-  gtk_tree_path_free (path);
-
   level = FILTER_LEVEL (iter.user_data);
   elt = FILTER_ELT (iter.user_data2);
 
-  g_assert (elt->visible);
+  gtk_tree_path_free (path);
+
+  requested_state = gtk_tree_model_filter_visible (filter, c_iter);
+
+  if (!elt->visible && !requested_state)
+    {
+      /* The parent node currently is not visible and will not become
+       * visible, so we will not pass on the row-has-child-toggled event.
+       */
+      return;
+    }
+  else if (elt->visible && !requested_state)
+    {
+      /* The node is no longer visible, so it has to be removed.
+       * _remove_node() takes care of emitting row-has-child-toggled
+       * when required.
+       */
+      level->visible_nodes--;
+
+      gtk_tree_model_filter_remove_node (filter, &iter);
+
+      return;
+    }
+  else if (!elt->visible && requested_state)
+    {
+      elt->visible = TRUE;
+      level->visible_nodes++;
+
+      /* Only insert if the parent is visible in the target */
+      if (gtk_tree_model_filter_elt_is_visible_in_target (level, elt))
+        {
+          path = gtk_tree_model_get_path (GTK_TREE_MODEL (filter), &iter);
+          gtk_tree_model_row_inserted (GTK_TREE_MODEL (filter), path, &iter);
+          gtk_tree_path_free (path);
+
+          /* We do not update children now, because that will happen
+           * below.
+           */
+        }
+    }
+  /* For the remaining possibility, elt->visible && requested_state
+   * no action is required.
+   */
 
   /* If this node is referenced and has children, build the level so we
    * can monitor it for changes.
    */
   if (elt->ref_count > 1 && gtk_tree_model_iter_has_child (c_model, c_iter))
-    gtk_tree_model_filter_build_level (filter, level, elt, TRUE);
+    gtk_tree_model_filter_build_level (filter, level,
+                                       FILTER_LEVEL_ELT_INDEX (level, elt),
+                                       TRUE);
 
   /* get a path taking only visible nodes into account */
   path = gtk_tree_model_get_path (GTK_TREE_MODEL (data), &iter);
@@ -1607,11 +1733,12 @@ gtk_tree_model_filter_row_deleted (GtkTr
   GtkTreeModelFilter *filter = GTK_TREE_MODEL_FILTER (data);
   GtkTreePath *path;
   GtkTreeIter iter;
-  FilterElt *elt, *parent = NULL;
+  FilterElt *elt;
   FilterLevel *level, *parent_level = NULL;
   gboolean emit_child_toggled = FALSE;
   gint offset;
   gint i;
+  gint parent_elt_index = -1;
 
   g_return_if_fail (c_path != NULL);
 
@@ -1749,7 +1876,7 @@ gtk_tree_model_filter_row_deleted (GtkTr
           if (elt->offset > offset)
             elt->offset--;
           if (elt->children)
-            elt->children->parent_elt = elt;
+            elt->children->parent_elt_index = i;
         }
 
       return;
@@ -1774,7 +1901,7 @@ gtk_tree_model_filter_row_deleted (GtkTr
         {
           emit_child_toggled = TRUE;
           parent_level = level->parent_level;
-          parent = level->parent_elt;
+          parent_elt_index = level->parent_elt_index;
         }
 
       /* emit row_deleted */
@@ -1819,7 +1946,7 @@ gtk_tree_model_filter_row_deleted (GtkTr
           if (elt->offset > offset)
             elt->offset--;
           if (elt->children)
-            elt->children->parent_elt = elt;
+            elt->children->parent_elt_index = i;
         }
     }
 
@@ -1830,7 +1957,7 @@ gtk_tree_model_filter_row_deleted (GtkTr
 
       iter.stamp = filter->priv->stamp;
       iter.user_data = parent_level;
-      iter.user_data2 = parent;
+      iter.user_data2 = &g_array_index (parent_level->array, FilterElt, parent_elt_index);
 
       /* We set in_row_deleted to TRUE to avoid a level build triggered
        * by row-has-child-toggled (parent model could call iter_has_child
@@ -2013,7 +2140,7 @@ gtk_tree_model_filter_rows_reordered (Gt
     {
       FilterElt *e = &g_array_index (level->array, FilterElt, i);
       if (e->children)
-        e->children->parent_elt = e;
+        e->children->parent_elt_index = i;
     }
 
   /* emit rows_reordered */
@@ -2114,7 +2241,7 @@ gtk_tree_model_filter_get_iter_full (Gtk
   indices = gtk_tree_path_get_indices (path);
 
   if (filter->priv->root == NULL)
-    gtk_tree_model_filter_build_level (filter, NULL, NULL, FALSE);
+    gtk_tree_model_filter_build_level (filter, NULL, -1, FALSE);
   level = FILTER_LEVEL (filter->priv->root);
 
   depth = gtk_tree_path_get_depth (path);
@@ -2134,7 +2261,9 @@ gtk_tree_model_filter_get_iter_full (Gtk
       elt = gtk_tree_model_filter_get_nth (filter, level, indices[i]);
 
       if (!elt->children)
-        gtk_tree_model_filter_build_level (filter, level, elt, FALSE);
+        gtk_tree_model_filter_build_level (filter, level,
+                                           FILTER_LEVEL_ELT_INDEX (level, elt),
+                                           FALSE);
       level = elt->children;
     }
 
@@ -2169,7 +2298,7 @@ gtk_tree_model_filter_get_iter (GtkTreeM
   indices = gtk_tree_path_get_indices (path);
 
   if (filter->priv->root == NULL)
-    gtk_tree_model_filter_build_level (filter, NULL, NULL, FALSE);
+    gtk_tree_model_filter_build_level (filter, NULL, -1, FALSE);
   level = FILTER_LEVEL (filter->priv->root);
 
   depth = gtk_tree_path_get_depth (path);
@@ -2189,7 +2318,9 @@ gtk_tree_model_filter_get_iter (GtkTreeM
       elt = gtk_tree_model_filter_get_nth_visible (filter, level, indices[i]);
 
       if (!elt->children)
-        gtk_tree_model_filter_build_level (filter, level, elt, FALSE);
+        gtk_tree_model_filter_build_level (filter, level,
+                                           FILTER_LEVEL_ELT_INDEX (level, elt),
+                                           FALSE);
       level = elt->children;
     }
 
@@ -2216,6 +2347,7 @@ gtk_tree_model_filter_get_path (GtkTreeM
   GtkTreePath *retval;
   FilterLevel *level;
   FilterElt *elt;
+  gint elt_index;
 
   g_return_val_if_fail (GTK_IS_TREE_MODEL_FILTER (model), NULL);
   g_return_val_if_fail (GTK_TREE_MODEL_FILTER (model)->priv->child_model != NULL, NULL);
@@ -2223,6 +2355,7 @@ gtk_tree_model_filter_get_path (GtkTreeM
 
   level = iter->user_data;
   elt = iter->user_data2;
+  elt_index = FILTER_LEVEL_ELT_INDEX (level, elt);
 
   if (!elt->visible)
     return NULL;
@@ -2233,7 +2366,7 @@ gtk_tree_model_filter_get_path (GtkTreeM
     {
       int i = 0, index = 0;
 
-      while (&g_array_index (level->array, FilterElt, i) != elt)
+      while (i < elt_index)
         {
           if (g_array_index (level->array, FilterElt, i).visible)
             index++;
@@ -2243,7 +2376,7 @@ gtk_tree_model_filter_get_path (GtkTreeM
         }
 
       gtk_tree_path_prepend_index (retval, index);
-      elt = level->parent_elt;
+      elt_index = level->parent_elt_index;
       level = level->parent_level;
     }
 
@@ -2336,7 +2469,7 @@ gtk_tree_model_filter_iter_children (Gtk
       int i = 0;
 
       if (!filter->priv->root)
-        gtk_tree_model_filter_build_level (filter, NULL, NULL, FALSE);
+        gtk_tree_model_filter_build_level (filter, NULL, -1, FALSE);
       if (!filter->priv->root)
         return FALSE;
 
@@ -2366,20 +2499,24 @@ gtk_tree_model_filter_iter_children (Gtk
   else
     {
       int i = 0;
+      FilterElt *elt;
+
+      elt = FILTER_ELT (parent->user_data2);
 
-      if (FILTER_ELT (parent->user_data2)->children == NULL)
+      if (elt->children == NULL)
         gtk_tree_model_filter_build_level (filter,
                                            FILTER_LEVEL (parent->user_data),
-                                           FILTER_ELT (parent->user_data2),
+                                           FILTER_LEVEL_ELT_INDEX (parent->user_data, elt),
                                            FALSE);
-      if (FILTER_ELT (parent->user_data2)->children == NULL)
+
+      if (elt->children == NULL)
         return FALSE;
 
-      if (FILTER_ELT (parent->user_data2)->children->visible_nodes <= 0)
+      if (elt->children->visible_nodes <= 0)
         return FALSE;
 
       iter->stamp = filter->priv->stamp;
-      iter->user_data = FILTER_ELT (parent->user_data2)->children;
+      iter->user_data = elt->children;
 
       level = FILTER_LEVEL (iter->user_data);
 
@@ -2429,7 +2566,8 @@ gtk_tree_model_filter_iter_has_child (Gt
   if (!elt->children
       && gtk_tree_model_iter_has_child (filter->priv->child_model, &child_iter))
     gtk_tree_model_filter_build_level (filter, FILTER_LEVEL (iter->user_data),
-                                       elt, FALSE);
+                                       FILTER_LEVEL_ELT_INDEX (iter->user_data, elt),
+                                       FALSE);
 
   if (elt->children && elt->children->visible_nodes > 0)
     return TRUE;
@@ -2453,7 +2591,7 @@ gtk_tree_model_filter_iter_n_children (G
   if (!iter)
     {
       if (!filter->priv->root)
-        gtk_tree_model_filter_build_level (filter, NULL, NULL, FALSE);
+        gtk_tree_model_filter_build_level (filter, NULL, -1, FALSE);
 
       if (filter->priv->root)
         return FILTER_LEVEL (filter->priv->root)->visible_nodes;
@@ -2472,7 +2610,8 @@ gtk_tree_model_filter_iter_n_children (G
       gtk_tree_model_iter_has_child (filter->priv->child_model, &child_iter))
     gtk_tree_model_filter_build_level (filter,
                                        FILTER_LEVEL (iter->user_data),
-                                       elt, FALSE);
+                                       FILTER_LEVEL_ELT_INDEX (iter->user_data, elt),
+                                       FALSE);
 
   if (elt->children)
     return elt->children->visible_nodes;
@@ -2538,7 +2677,7 @@ gtk_tree_model_filter_iter_parent (GtkTr
     {
       iter->stamp = GTK_TREE_MODEL_FILTER (model)->priv->stamp;
       iter->user_data = level->parent_level;
-      iter->user_data2 = level->parent_elt;
+      iter->user_data2 = FILTER_LEVEL_PARENT_ELT (level);
 
       return TRUE;
     }
@@ -2571,14 +2710,14 @@ gtk_tree_model_filter_ref_node (GtkTreeM
   if (level->ref_count == 1)
     {
       FilterLevel *parent_level = level->parent_level;
-      FilterElt *parent_elt = level->parent_elt;
+      gint parent_elt_index = level->parent_elt_index;
 
       /* we were at zero -- time to decrease the zero_ref_count val */
       while (parent_level)
         {
-	  parent_elt->zero_ref_count--;
+          g_array_index (parent_level->array, FilterElt, parent_elt_index).zero_ref_count--;
 
-	  parent_elt = parent_level->parent_elt;
+          parent_elt_index = parent_level->parent_elt_index;
 	  parent_level = parent_level->parent_level;
         }
 
@@ -2624,14 +2763,14 @@ gtk_tree_model_filter_real_unref_node (G
   if (level->ref_count == 0)
     {
       FilterLevel *parent_level = level->parent_level;
-      FilterElt *parent_elt = level->parent_elt;
+      gint parent_elt_index = level->parent_elt_index;
 
       /* we are at zero -- time to increase the zero_ref_count val */
       while (parent_level)
         {
-          parent_elt->zero_ref_count++;
+          g_array_index (parent_level->array, FilterElt, parent_elt_index).zero_ref_count++;
 
-          parent_elt = parent_level->parent_elt;
+          parent_elt_index = parent_level->parent_elt_index;
           parent_level = parent_level->parent_level;
         }
 
@@ -3037,6 +3176,7 @@ gtk_tree_model_filter_convert_child_iter
   g_return_val_if_fail (filter->priv->child_model != NULL, FALSE);
   g_return_val_if_fail (filter_iter != NULL, FALSE);
   g_return_val_if_fail (child_iter != NULL, FALSE);
+  g_return_val_if_fail (filter_iter != child_iter, FALSE);
 
   filter_iter->stamp = 0;
 
@@ -3076,6 +3216,7 @@ gtk_tree_model_filter_convert_iter_to_ch
   g_return_if_fail (child_iter != NULL);
   g_return_if_fail (filter_iter != NULL);
   g_return_if_fail (filter_iter->stamp == filter->priv->stamp);
+  g_return_if_fail (filter_iter != child_iter);
 
   if (GTK_TREE_MODEL_FILTER_CACHE_CHILD_ITERS (filter))
     {
@@ -3124,7 +3265,7 @@ gtk_real_tree_model_filter_convert_child
   child_indices = gtk_tree_path_get_indices (real_path);
 
   if (filter->priv->root == NULL && build_levels)
-    gtk_tree_model_filter_build_level (filter, NULL, NULL, FALSE);
+    gtk_tree_model_filter_build_level (filter, NULL, -1, FALSE);
   level = FILTER_LEVEL (filter->priv->root);
 
   for (i = 0; i < gtk_tree_path_get_depth (real_path); i++)
@@ -3144,7 +3285,9 @@ gtk_real_tree_model_filter_convert_child
         {
           gtk_tree_path_append_index (retval, j);
           if (!tmp->children && build_levels)
-            gtk_tree_model_filter_build_level (filter, level, tmp, FALSE);
+            gtk_tree_model_filter_build_level (filter, level,
+                                               FILTER_LEVEL_ELT_INDEX (level, tmp),
+                                               FALSE);
           level = tmp->children;
           found_child = TRUE;
         }
@@ -3166,7 +3309,9 @@ gtk_real_tree_model_filter_convert_child
 
           gtk_tree_path_append_index (retval, j);
           if (!tmp->children && build_levels)
-            gtk_tree_model_filter_build_level (filter, level, tmp, FALSE);
+            gtk_tree_model_filter_build_level (filter, level,
+                                               FILTER_LEVEL_ELT_INDEX (level, tmp),
+                                               FALSE);
           level = tmp->children;
           found_child = TRUE;
         }
@@ -3258,7 +3403,7 @@ gtk_tree_model_filter_convert_path_to_ch
   retval = gtk_tree_path_new ();
   filter_indices = gtk_tree_path_get_indices (filter_path);
   if (!filter->priv->root)
-    gtk_tree_model_filter_build_level (filter, NULL, NULL, FALSE);
+    gtk_tree_model_filter_build_level (filter, NULL, -1, FALSE);
   level = FILTER_LEVEL (filter->priv->root);
 
   for (i = 0; i < gtk_tree_path_get_depth (filter_path); i++)
@@ -3275,7 +3420,9 @@ gtk_tree_model_filter_convert_path_to_ch
                                                    filter_indices[i]);
 
       if (elt->children == NULL)
-        gtk_tree_model_filter_build_level (filter, level, elt, FALSE);
+        gtk_tree_model_filter_build_level (filter, level,
+                                           FILTER_LEVEL_ELT_INDEX (level, elt),
+                                           FALSE);
 
       if (!level || level->visible_nodes <= filter_indices[i])
         {
