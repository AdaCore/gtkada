2011-05-16  Jerome Lambourg <lambourg@adacore.com>

        * modules/engines/ms-windows/xp_theme.h, xp_theme.c, msw_style.c: Fix
        the display of notebook tabs in the wimp engine.

2010-09-28  Nicolas Setton  <setton@adacore.com>

	* gtk/gtktextview.c (extend_selection): Fix typo in documentation.
	When extending the selection in SELECT_WORDS granularity past the
	end of a line, select only the EOL character(s).
	When extending the selection in SELECT_LINES granularity, include
	the EOL character(s) in the selection.

	Submitted at https://bugzilla.gnome.org/show_bug.cgi?id=630825

2010-12-06  Arnaud Charlet  <charlet@adacore.com>

	* gdk/x11/gdkdnd-x11.c (gdk_window_cache_new): Disable use of
	XCompositeGetOverlayWindow/XCompositeReleaseOverlayWindow, apparently
	not available on older linux distribs.

2010-03-27  Arnaud Charlet  <charlet@adacore.com>

	* gtk/gtkentry.c (gtk_entry_set_buffer): Prevent crashing when
	encountering a null buffer as reported on gtk+ list.

2010-03-24  Nicolas Setton  <setton@adacore.com>

	* gtk/gtktextview.c (gtk_text_view_check_cursor_blink): Do not
	register a cursor blink if the text view if not realized.
	This prevents a segmentation fault which can happen if the
	text_view happens to get the focus before it has been realized.

2010-01-11  Arnaud Charlet  <charlet@adacore.com>

	* gdk/gdkwindow.c (gdk_window_get_composite_drawable): Protect
	against NULL access.
	Observed when creating a new file in GPS under Windows.

2009-09-19  Arnaud Charlet  <charlet@adacore.com>

	* gtk/gtktreemodel.c (gtk_tree_model_row_has_child_toggled): Replace
	g_return_if_fail by explicit check, since path may legitimately
	be NULL (I918-021).

2009-01-12  Nicolas Setton  <setton@adacore.com>

	* gtktreeview.c (gtk_tree_view_enter_notify): Do not react to
	crossing events.
	(gtk_tree_view_leave_notify): Likewise.
        Prevents unwanted side-effects of synth-crossing. (I106-018)

2009-01-06  Nicolas Setton  <setton@adacore.com>

	* gtk/gtktreeview.c (gtk_tree_view_enter_notify): Put kludge to
	work around Gtk+ bug in handling of keyboard keys+focus events in
	tree view (HC15-032).

2006-02-23  Arnaud Charlet  <charlet@adacore.com>

	* gdk/x11/gdkasync.c: #define ANSICPP on Solaris, to work around
	bug in X11/Xmd.h on Solaris 8.

2003-11-27  Arnaud Charlet  <charlet@adacore.com>

	* gtk/gtktextview.c (incremental_validate_callback): Increase amount
	of characters validated at each call, this gives a better behavior
	when loading big files.
	Submitted at http://bugzilla.gnome.org/show_bug.cgi?id=332057

--- gtk/gtktextview.c.old	2006-02-17 16:11:04.000000000 +0100
+++ gtk/gtktextview.c	2006-02-20 17:08:54.691581240 +0100
@@ -3273,7 +3273,7 @@ incremental_validate_callback (gpointer 
   
   DV(g_print(G_STRLOC"\n"));
   
-  gtk_text_layout_validate (text_view->layout, 2000);
+  gtk_text_layout_validate (text_view->layout, 20000);
 
   gtk_text_view_update_adjustments (text_view);
   
--- gdk/x11/gdkasync.c.old	Thu Feb 23 11:30:46 2006
+++ gdk/x11/gdkasync.c	Thu Feb 23 11:48:14 2006
@@ -47,6 +47,11 @@ in this Software without prior written a
 #ifdef NEED_XIPROTO_H_FOR_XREPLY
 #include <X11/extensions/XIproto.h>
 #endif
+
+#if defined (sun) && defined (__SVR4)
+#define ANSICPP
+#endif
+
 #include <X11/Xlibint.h>
 #include "gdkasync.h"
 #include "gdkx.h"
--- gtk/gtktreeview.c.old	2008-11-24 07:35:35.000000000 +0100
+++ gtk/gtktreeview.c	2009-01-06 15:14:25.171875000 +0100
@@ -5459,6 +5459,9 @@ gtk_tree_view_enter_notify (GtkWidget   
   if (tree_view->priv->tree == NULL)
     return FALSE;
 
+  if (event->y == 0)
+    return FALSE;
+
   /* find the node internally */
   new_y = TREE_WINDOW_Y_TO_RBTREE_Y(tree_view, event->y);
   if (new_y < 0)
--- gtk/gtktreeview.c.orig	2009-01-12 11:49:09.000000000 +0100
+++ gtk/gtktreeview.c	2009-01-12 15:44:05.000000000 +0100
@@ -5461,6 +5461,12 @@ gtk_tree_view_enter_notify (GtkWidget   
   GtkRBNode *node;
   gint new_y;
 
+  if (event->mode == GDK_CROSSING_GRAB 
+      || event->mode == GDK_CROSSING_NORMAL
+      || event->mode == GDK_CROSSING_GTK_GRAB
+      || event->mode == GDK_CROSSING_GTK_UNGRAB)
+    return TRUE;
+
   /* Sanity check it */
   if (event->window != tree_view->priv->bin_window)
     return FALSE;
@@ -5487,7 +5493,10 @@ gtk_tree_view_leave_notify (GtkWidget   
 {
   GtkTreeView *tree_view;
 
-  if (event->mode == GDK_CROSSING_GRAB)
+  if (event->mode == GDK_CROSSING_GRAB 
+      || event->mode == GDK_CROSSING_NORMAL
+      || event->mode == GDK_CROSSING_GTK_GRAB
+      || event->mode == GDK_CROSSING_GTK_UNGRAB)
     return TRUE;
 
   tree_view = GTK_TREE_VIEW (widget);
--- gtk/gtktreemodel.c.old	2009-09-19 12:03:49.804000000 +0200
+++ gtk/gtktreemodel.c	2009-09-19 12:41:00.954000000 +0200
@@ -1512,8 +1512,11 @@ gtk_tree_model_row_has_child_toggled (Gt
 				      GtkTreeIter  *iter)
 {
   g_return_if_fail (GTK_IS_TREE_MODEL (tree_model));
-  g_return_if_fail (path != NULL);
-  g_return_if_fail (iter != NULL);
+
+  if (path == NULL)
+    return;
+  if (iter == NULL)
+    return;
 
   g_signal_emit (tree_model, tree_model_signals[ROW_HAS_CHILD_TOGGLED], 0, path, iter);
 }
--- gdk/gdkwindow.c.old	2009-12-08 16:13:05.000000000 +0100
+++ gdk/gdkwindow.c	2010-01-10 20:33:05.783000000 +0100
@@ -3858,7 +3858,7 @@ gdk_window_get_composite_drawable (GdkDr
 		     width, height);
 
   /* paint the backing stores */
-  if (implicit_paint)
+  if (implicit_paint && list != NULL)
     {
       GdkWindowPaint *paint = list->data;
 
*** gtk/gtktextview.c.orig	Wed Mar 24 14:47:16 2010
--- gtk/gtktextview.c	Wed Mar 24 14:47:19 2010
*************** gtk_text_view_check_cursor_blink (GtkTex
*** 4931,4937 ****
        text_view->cursor_visible &&
        GTK_WIDGET_HAS_FOCUS (text_view))
      {
!       if (cursor_blinks (text_view))
  	{
  	  if (text_view->blink_timeout == 0)
  	    {
--- 4931,4937 ----
        text_view->cursor_visible &&
        GTK_WIDGET_HAS_FOCUS (text_view))
      {
!       if (cursor_blinks (text_view) && gtk_widget_get_realized (text_view))
  	{
  	  if (text_view->blink_timeout == 0)
  	    {
--- gtk/gtkentry.c.old
+++ gtk/gtkentry.c
@@ -6668,8 +6668,11 @@ gtk_entry_set_buffer
   g_object_notify (obj, "invisible-char-set");
   g_object_thaw_notify (obj);

-  gtk_editable_set_position (GTK_EDITABLE (entry), 0);
-  gtk_entry_recompute (entry);
+  if (priv->buffer)
+    {
+      gtk_editable_set_position (GTK_EDITABLE (entry), 0);
+      gtk_entry_recompute (entry);
+    }
 }

 
--- gtk/gtktextview.c.orig	2010-09-28 16:24:33.000000000 +0200
+++ gtk/gtktextview.c	2010-09-28 17:13:53.000000000 +0200
@@ -6115,7 +6115,7 @@ typedef enum 
 /*
  * Move @start and @end to the boundaries of the selection unit (indicated by 
  * @granularity) which contained @start initially.
- * If the selction unit is SELECT_WORDS and @start is not contained in a word
+ * If the selection unit is SELECT_WORDS and @start is not contained in a word
  * the selection is extended to all the white spaces between the end of the 
  * word preceding @start and the start of the one following.
  */
@@ -6144,26 +6144,37 @@ extend_selection (GtkTextView *text_view
 	{
 	  GtkTextIter tmp;
 
-	  tmp = *start;
-	  if (gtk_text_iter_backward_visible_word_start (&tmp))
-	    gtk_text_iter_forward_visible_word_end (&tmp);
-
-	  if (gtk_text_iter_get_line (&tmp) == gtk_text_iter_get_line (start))
-	    *start = tmp;
-	  else
-	    gtk_text_iter_set_line_offset (start, 0);
-
-	  tmp = *end;
-	  if (!gtk_text_iter_forward_visible_word_end (&tmp))
-	    gtk_text_iter_forward_to_end (&tmp);
-
-	  if (gtk_text_iter_ends_word (&tmp))
-	    gtk_text_iter_backward_visible_word_start (&tmp);
-
-	  if (gtk_text_iter_get_line (&tmp) == gtk_text_iter_get_line (end))
-	    *end = tmp;
+	  if (gtk_text_iter_ends_line (start))
+	    {
+	      /* start is at an end of line: simply extend the
+	       * selection to include the end-of-line character(s).
+	       */   
+	      if (!gtk_text_iter_forward_line (end))
+		gtk_text_iter_forward_to_end (end);
+	    }
 	  else
-	    gtk_text_iter_forward_to_line_end (end);
+	    {  
+	      tmp = *start;
+	      if (gtk_text_iter_backward_visible_word_start (&tmp))
+		gtk_text_iter_forward_visible_word_end (&tmp);
+
+	      if (gtk_text_iter_get_line (&tmp) == gtk_text_iter_get_line (start))
+		*start = tmp;
+	      else
+		gtk_text_iter_set_line_offset (start, 0);
+
+	      tmp = *end;
+	      if (!gtk_text_iter_forward_visible_word_end (&tmp))
+		gtk_text_iter_forward_to_end (&tmp);
+
+	      if (gtk_text_iter_ends_word (&tmp))
+		gtk_text_iter_backward_visible_word_start (&tmp);
+
+	      if (gtk_text_iter_get_line (&tmp) == gtk_text_iter_get_line (end))
+		*end = tmp;
+	      else
+		gtk_text_iter_forward_to_line_end (end);
+	    }
 	}
     }
   else if (granularity == SELECT_LINES) 
@@ -6186,6 +6197,12 @@ extend_selection (GtkTextView *text_view
 	  if (!gtk_text_view_starts_display_line (text_view, end))
 	    gtk_text_view_forward_display_line_end (text_view, end);
 	}
+	
+      /* At this point end points at the end of a line:
+       * include the end-of-line character(s) in the selection. 
+       */
+      if (!gtk_text_iter_forward_line (end))
+	gtk_text_iter_forward_to_end (end);
     }
 }
  
--- gdk/x11/gdkdnd-x11.c.old	2011-04-10 22:36:59.140000000 +0200
+++ gdk/x11/gdkdnd-x11.c	2011-04-10 22:37:24.808000000 +0200
@@ -578,6 +578,7 @@ gdk_window_cache_new (GdkScreen *screen)
 
   g_free (children);
 
+#if 0
 #ifdef HAVE_XCOMPOSITE
   /*
    * Add the composite overlay window to the cache, as this can be a reasonable
@@ -593,6 +594,7 @@ gdk_window_cache_new (GdkScreen *screen)
       XCompositeReleaseOverlayWindow (xdisplay, GDK_WINDOW_XWINDOW (root_window));
     }
 #endif
+#endif
 
   return result;
 }
*** modules/engines/ms-windows/msw_style.c.old	2011-02-19 15:31:37.000000000 +0100
--- modules/engines/ms-windows/msw_style.c	2011-05-16 08:15:33.897461000 +0200
***************
*** 849,855 ****
    sys_color_to_gtk_color (XP_THEME_CLASS_TEXT, COLOR_GRAYTEXT,
  			  &style->fg[GTK_STATE_INSENSITIVE]);
    sys_color_to_gtk_color (XP_THEME_CLASS_BUTTON, COLOR_BTNTEXT,
!         		  &style->bg[GTK_STATE_ACTIVE]);
    sys_color_to_gtk_color (XP_THEME_CLASS_WINDOW, COLOR_WINDOWTEXT,
  			  &style->fg[GTK_STATE_PRELIGHT]);
  
--- 849,855 ----
    sys_color_to_gtk_color (XP_THEME_CLASS_TEXT, COLOR_GRAYTEXT,
  			  &style->fg[GTK_STATE_INSENSITIVE]);
    sys_color_to_gtk_color (XP_THEME_CLASS_BUTTON, COLOR_BTNTEXT,
!         		  &style->fg[GTK_STATE_ACTIVE]);
    sys_color_to_gtk_color (XP_THEME_CLASS_WINDOW, COLOR_WINDOWTEXT,
  			  &style->fg[GTK_STATE_PRELIGHT]);
  
***************
*** 2118,2123 ****
--- 2118,2124 ----
      }
    else if (detail && !strcmp (detail, "notebook") && GTK_IS_NOTEBOOK (widget))
      {
+       return;
        if (xp_theme_draw (window, XP_THEME_ELEMENT_TAB_PANE, style,
  			 x, y, width, height, state_type, area))
  	{
***************
*** 2347,2352 ****
--- 2348,2415 ----
      DrawEdge (hdc, &shadeRect, EDGE_RAISED, BF_SOFT | shadeFlag);
  }
  
+ static void
+ get_notebook_tab_position (GtkNotebook *notebook, gboolean *start, gboolean *end)
+ {
+   /* default value */
+   *start = TRUE;
+   *end = FALSE;
+ 
+   gboolean found_tabs = FALSE;
+   gint i, n_pages;
+   
+   n_pages = gtk_notebook_get_n_pages (notebook);
+   for (i = 0; i < n_pages; i++) {
+     GtkWidget *tab_child;
+     GtkWidget *tab_label;
+     gboolean expand;
+     GtkPackType pack_type;
+     
+     tab_child = gtk_notebook_get_nth_page (notebook, i);
+     
+     /* Skip invisible tabs */
+     tab_label = gtk_notebook_get_tab_label (notebook, tab_child);
+     if (!tab_label || !GTK_WIDGET_VISIBLE (tab_label))
+       continue;
+     /* This is the same what the notebook does internally. */
+     if (tab_label && !gtk_widget_get_child_visible (tab_label)) {
+       /* One child is hidden because scroll arrows are present.
+        * So both corners are rounded. */
+       *start = FALSE;
+       *end = FALSE;
+       return;
+     }
+     
+     gtk_notebook_query_tab_label_packing 
+       (notebook, tab_child,
+        &expand,
+        NULL, /* don't need fill */
+        &pack_type);
+     
+     if (!found_tabs) {
+       //  First tab found
+       found_tabs = TRUE;
+       if (gtk_notebook_get_current_page (notebook) == i) {
+         *start = TRUE;
+       } else {
+         *start = FALSE;
+       }
+     }
+     
+     if (gtk_notebook_get_current_page (notebook) == i) {
+       if (expand) {
+         *end = TRUE;
+       } else {
+         *end = FALSE;
+         return;
+       }
+     } else {
+       *end = FALSE; 
+       return;
+     }
+   }
+ }
+ 
  static gboolean
  draw_themed_tab_button (GtkStyle *style,
  			GdkWindow *window,
***************
*** 2356,2576 ****
  			gint width, gint height, gint gap_side)
  {
    GdkPixmap *pixmap = NULL;
-   gint border_width =
-     gtk_container_get_border_width (GTK_CONTAINER (notebook));
-   GtkWidget *widget = GTK_WIDGET (notebook);
    GdkRectangle draw_rect, clip_rect;
-   GdkPixbufRotation rotation = GDK_PIXBUF_ROTATE_NONE;
    cairo_t *cr;
! 
!   if (gap_side == GTK_POS_TOP)
!     {
!       int widget_right;
! 
!       if (state_type == GTK_STATE_NORMAL)
! 	{
! 	  draw_rect.x = x;
! 	  draw_rect.y = y;
! 	  draw_rect.width = width + 2;
! 	  draw_rect.height = height;
! 
! 	  clip_rect = draw_rect;
! 	  clip_rect.height--;
! 	}
!       else
! 	{
! 	  draw_rect.x = x + 2;
! 	  draw_rect.y = y;
! 	  draw_rect.width = width - 2;
! 	  draw_rect.height = height - 2;
! 	  clip_rect = draw_rect;
! 	}
! 
!       /* If we are currently drawing the right-most tab, and if that tab is the selected tab... */
!       widget_right = widget->allocation.x + widget->allocation.width - border_width - 2;
! 
!       if (draw_rect.x + draw_rect.width >= widget_right)
! 	{
! 	  draw_rect.width = clip_rect.width = widget_right - draw_rect.x;
! 	}
!     }
!   if (gap_side == GTK_POS_BOTTOM)
!     {
!       int widget_right;
! 
!       if (state_type == GTK_STATE_NORMAL)
! 	{
! 	  draw_rect.x = x;
! 	  draw_rect.y = y;
! 	  draw_rect.width = width + 2;
! 	  draw_rect.height = height;
! 
! 	  clip_rect = draw_rect;
! 	}
!       else
! 	{
! 	  draw_rect.x = x + 2;
! 	  draw_rect.y = y + 2;
! 	  draw_rect.width = width - 2;
! 	  draw_rect.height = height - 2;
! 	  clip_rect = draw_rect;
! 	}
! 
!       /* If we are currently drawing the right-most tab, and if that tab is the selected tab... */
!       widget_right = widget->allocation.x + widget->allocation.width - border_width - 2;
! 
!       if (draw_rect.x + draw_rect.width >= widget_right)
! 	{
! 	  draw_rect.width = clip_rect.width = widget_right - draw_rect.x;
! 	}
! 
!       rotation = GDK_PIXBUF_ROTATE_UPSIDEDOWN;
      }
!   else if (gap_side == GTK_POS_LEFT)
!     {
!       int widget_bottom;
! 
!       if (state_type == GTK_STATE_NORMAL)
! 	{
! 	  draw_rect.x = x;
! 	  draw_rect.y = y;
! 	  draw_rect.width = width;
! 	  draw_rect.height = height + 2;
! 
! 	  clip_rect = draw_rect;
! 	  clip_rect.width--;
! 	}
!       else
! 	{
! 	  draw_rect.x = x;
! 	  draw_rect.y = y + 2;
! 	  draw_rect.width = width - 2;
! 	  draw_rect.height = height - 2;
! 	  clip_rect = draw_rect;
! 	}
! 
!       /* If we are currently drawing the bottom-most tab, and if that tab is the selected tab... */
!       widget_bottom = widget->allocation.x + widget->allocation.height - border_width - 2;
  
!       if (draw_rect.y + draw_rect.height >= widget_bottom)
! 	{
! 	  draw_rect.height = clip_rect.height = widget_bottom - draw_rect.y;
! 	}
  
!       rotation = GDK_PIXBUF_ROTATE_COUNTERCLOCKWISE;
!     }
!   else if (gap_side == GTK_POS_RIGHT)
      {
!       int widget_bottom;
! 
!       if (state_type == GTK_STATE_NORMAL)
! 	{
! 	  draw_rect.x = x + 1;
! 	  draw_rect.y = y;
! 	  draw_rect.width = width;
! 	  draw_rect.height = height + 2;
! 
! 	  clip_rect = draw_rect;
! 	  clip_rect.width--;
! 	}
!       else
! 	{
! 	  draw_rect.x = x + 2;
! 	  draw_rect.y = y + 2;
! 	  draw_rect.width = width - 2;
! 	  draw_rect.height = height - 2;
! 	  clip_rect = draw_rect;
! 	}
! 
!       /* If we are currently drawing the bottom-most tab, and if that tab is the selected tab... */
!       widget_bottom = widget->allocation.x + widget->allocation.height - border_width - 2;
! 
!       if (draw_rect.y + draw_rect.height >= widget_bottom)
! 	{
! 	  draw_rect.height = clip_rect.height = widget_bottom - draw_rect.y;
! 	}
! 
!       rotation = GDK_PIXBUF_ROTATE_CLOCKWISE;
      }
  
!   if (gap_side == GTK_POS_TOP)
      {
!       if (!xp_theme_draw (window, XP_THEME_ELEMENT_TAB_ITEM, style,
! 			  draw_rect.x, draw_rect.y,
! 			  draw_rect.width, draw_rect.height,
! 			  state_type, &clip_rect))
  	{
  	  return FALSE;
  	}
      }
    else
      {
!       GdkPixbuf *pixbuf;
!       GdkPixbuf *rotated;
  
!       if (gap_side == GTK_POS_LEFT || gap_side == GTK_POS_RIGHT)
! 	{
! 	  pixmap = gdk_pixmap_new (window, clip_rect.height, clip_rect.width, -1);
! 
! 	  if (!xp_theme_draw (pixmap, XP_THEME_ELEMENT_TAB_ITEM, style,
! 			      draw_rect.y - clip_rect.y, draw_rect.x - clip_rect.x,
! 			      draw_rect.height, draw_rect.width, state_type, 0))
! 	    {
! 	      g_object_unref (pixmap);
! 	      return FALSE;
! 	    }
! 
! 	  pixbuf = gdk_pixbuf_get_from_drawable (NULL, pixmap, NULL, 0, 0, 0, 0,
! 						 clip_rect.height, clip_rect.width);
! 	  g_object_unref (pixmap);
! 	}
!       else
  	{
- 	  pixmap = gdk_pixmap_new (window, clip_rect.width, clip_rect.height, -1);
- 
- 	  if (!xp_theme_draw (pixmap, XP_THEME_ELEMENT_TAB_ITEM, style,
- 			      draw_rect.x - clip_rect.x, draw_rect.y - clip_rect.y,
- 			      draw_rect.width, draw_rect.height, state_type, 0))
- 	    {
- 	      g_object_unref (pixmap);
- 	      return FALSE;
- 	    }
- 
- 	  pixbuf = gdk_pixbuf_get_from_drawable (NULL, pixmap, NULL, 0, 0, 0, 0,
- 						 clip_rect.width, clip_rect.height);
  	  g_object_unref (pixmap);
  	}
  
!       rotated = gdk_pixbuf_rotate_simple (pixbuf, rotation);
!       g_object_unref (pixbuf);
!       pixbuf = rotated;
! 
!       // XXX - This is really hacky and evil.  When we're drawing the left-most tab
!       //       while it is active on a bottom-oriented notebook, there is one white
!       //       pixel at the top.  There may be a better solution than this if someone
!       //       has time to discover it.
!       if (gap_side == GTK_POS_BOTTOM && state_type == GTK_STATE_NORMAL
! 	  && x == widget->allocation.x)
! 	{
! 	  int rowstride = gdk_pixbuf_get_rowstride (pixbuf);
! 	  int n_channels = gdk_pixbuf_get_n_channels (pixbuf);
! 	  int psub = 0;
! 
! 	  guchar *pixels = gdk_pixbuf_get_pixels (pixbuf);
! 	  guchar *p = pixels + rowstride;
! 
! 	  for (psub = 0; psub < n_channels; psub++)
! 	    {
! 	      pixels[psub] = p[psub];
! 	    }
! 	}
  
!       cr = gdk_cairo_create (window);
!       gdk_cairo_set_source_pixbuf (cr, pixbuf, clip_rect.x, clip_rect.y);
!       cairo_paint (cr);
!       cairo_destroy (cr);
!       g_object_unref (pixbuf);
!     }
  
    return TRUE;
  }
--- 2419,2533 ----
  			gint width, gint height, gint gap_side)
  {
    GdkPixmap *pixmap = NULL;
    GdkRectangle draw_rect, clip_rect;
    cairo_t *cr;
!   gboolean start, stop;
!   XpThemeElement element;
!   GdkPixbuf *pixbuf;
!   GdkPixbuf *rotated;
! 
!   get_notebook_tab_position (notebook, &start, &stop);
!   if (start && stop) {
!     // Both edges of the notebook are covered by the item
!     element = XP_THEME_ELEMENT_TAB_ITEM_BOTH_EDGES;
!   } else if (start) {
!     // The start edge is covered by the item
!     element = XP_THEME_ELEMENT_TAB_ITEM_LEFT_EDGE;
!   } else if (stop) {
!     //  the stop edge is reached by the item
!     element = XP_THEME_ELEMENT_TAB_ITEM_RIGHT_EDGE;
!   } else {
!     //  no edge should be aligned with the tab
!     element = XP_THEME_ELEMENT_TAB_ITEM;
!   }
! 
!   if (state_type == GTK_STATE_ACTIVE) {
!     switch (gap_side) {
!     case GTK_POS_TOP:
!       y -= 1;
!       break;
!     case GTK_POS_BOTTOM:
!       y += 1;
!       break;
!     case GTK_POS_LEFT:
!       x -= 1;
!       break;
!     case GTK_POS_RIGHT:
!       x += 1;
!       break;
      }
!   }
  
!   draw_rect.x = x;
!   draw_rect.y = y;
!   draw_rect.width = width;
!   draw_rect.height = height;
!   clip_rect = draw_rect;
  
!   /* Simple case: tabs on top are just drawn as is */
!   if (gap_side == GTK_POS_TOP)
      {
!        return xp_theme_draw
! 	 (window, element, style,
! 	  draw_rect.x, draw_rect.y,
! 	  draw_rect.width, draw_rect.height,
! 	  state_type, &clip_rect);
      }
  
!   if (clip_rect.width <= 0 || clip_rect.height <= 0)
!     return TRUE;
!       
!   if (gap_side == GTK_POS_LEFT || gap_side == GTK_POS_RIGHT)
      {
!       pixmap = gdk_pixmap_new (window, clip_rect.height, clip_rect.width, -1);
!       
!       if (!xp_theme_draw (pixmap, element, style,
! 			  draw_rect.y - clip_rect.y, draw_rect.x - clip_rect.x,
! 			  draw_rect.height, draw_rect.width, state_type, 0))
  	{
+ 	  g_object_unref (pixmap);
  	  return FALSE;
  	}
+ 
+       pixbuf = gdk_pixbuf_get_from_drawable (NULL, pixmap, NULL, 0, 0, 0, 0,
+ 					     clip_rect.height, clip_rect.width);
+       g_object_unref (pixmap);
      }
    else
      {
!       pixmap = gdk_pixmap_new (window, clip_rect.width, clip_rect.height, -1);
  
!       if (!xp_theme_draw (pixmap, element, style,
! 			  draw_rect.x - clip_rect.x, draw_rect.y - clip_rect.y,
! 			  draw_rect.width, draw_rect.height, state_type, 0))
  	{
  	  g_object_unref (pixmap);
+ 	  return FALSE;
  	}
  
!       pixbuf = gdk_pixbuf_get_from_drawable (NULL, pixmap, NULL, 0, 0, 0, 0,
! 					     clip_rect.width, clip_rect.height);
!       g_object_unref (pixmap);
!     }
! 
!   if (pixbuf == NULL) return FALSE;
! 
!   if (gap_side == GTK_POS_BOTTOM || gap_side == GTK_POS_LEFT) {
!     rotated = gdk_pixbuf_flip (pixbuf, FALSE);
!     g_object_unref (pixbuf);
!     pixbuf = rotated;
!   }
!   if (gap_side == GTK_POS_LEFT || gap_side == GTK_POS_RIGHT) {
!     rotated = gdk_pixbuf_rotate_simple (pixbuf, GDK_PIXBUF_ROTATE_CLOCKWISE);
!     g_object_unref (pixbuf);
!     pixbuf = rotated;
!   }
  
!   cr = gdk_cairo_create (window);
!   gdk_cairo_set_source_pixbuf (cr, pixbuf, clip_rect.x, clip_rect.y);
!   cairo_paint (cr);
!   cairo_destroy (cr);
!   g_object_unref (pixbuf);
  
    return TRUE;
  }
***************
*** 2585,2591 ****
--- 2542,2550 ----
  		 const gchar *detail,
  		 gint x, gint y, gint width, gint height, gint gap_side)
  {
+ #if 0
    if (gap_side == GTK_POS_TOP || gap_side == GTK_POS_BOTTOM)
+ #endif
      {
        /* experimental tab-drawing code from mozilla */
        RECT rect;
***************
*** 2642,2648 ****
    if (widget && GTK_IS_NOTEBOOK (widget) && detail && !strcmp (detail, "tab"))
      {
        GtkNotebook *notebook = GTK_NOTEBOOK (widget);
- 
        /* Why this differs from gap_side, I have no idea.. */
        int real_gap_side = gtk_notebook_get_tab_pos (notebook);
  
--- 2601,2606 ----
***************
*** 2670,2709 ****
  	      gint y, gint width, gint height, GtkPositionType gap_side,
  	      gint gap_x, gint gap_width)
  {
!   if (GTK_IS_NOTEBOOK (widget) && detail && !strcmp (detail, "notebook"))
      {
        GtkNotebook *notebook = GTK_NOTEBOOK (widget);
        int side = gtk_notebook_get_tab_pos (notebook);
!       int x2 = x, y2 = y, w2 = width, h2 = height;
  
!       if (side == GTK_POS_TOP)
! 	{
! 	  x2 = x;
! 	  y2 = y - gtk_notebook_get_tab_vborder (notebook);
! 	  w2 = width;
! 	  h2 = height + gtk_notebook_get_tab_vborder (notebook) * 2;
! 	}
!       else if (side == GTK_POS_BOTTOM)
! 	{
! 	  x2 = x;
! 	  y2 = y;
! 	  w2 = width;
! 	  h2 = height + gtk_notebook_get_tab_vborder (notebook) * 2;
! 	}
!       else if (side == GTK_POS_LEFT)
! 	{
! 	  x2 = x - gtk_notebook_get_tab_hborder (notebook);
! 	  y2 = y;
! 	  w2 = width + gtk_notebook_get_tab_hborder (notebook);
! 	  h2 = height;
! 	}
!       else if (side == GTK_POS_RIGHT)
! 	{
! 	  x2 = x;
! 	  y2 = y;
! 	  w2 = width + gtk_notebook_get_tab_hborder (notebook) * 2;
! 	  h2 = height;
! 	}
  
        if (xp_theme_draw (window, XP_THEME_ELEMENT_TAB_PANE, style,
  			 x2, y2, w2, h2, state_type, area))
--- 2628,2657 ----
  	      gint y, gint width, gint height, GtkPositionType gap_side,
  	      gint gap_x, gint gap_width)
  {
!   if (detail && !strcmp (detail, "notebook"))
      {
        GtkNotebook *notebook = GTK_NOTEBOOK (widget);
        int side = gtk_notebook_get_tab_pos (notebook);
!       int x2, y2, w2, h2;
  
!       x2 = x;
!       y2 = y;
!       w2 = width + style->xthickness;
!       h2 = height + style->ythickness;
! 
!       switch (side) {
!       case GTK_POS_TOP:
!         y2 -= 1;
!         break;
!       case GTK_POS_BOTTOM:
!         break;
!       case GTK_POS_LEFT:
!         x2 -= 1;
!         break;
!       case GTK_POS_RIGHT:
!         w2 += 1;
!         break;
!       }
  
        if (xp_theme_draw (window, XP_THEME_ELEMENT_TAB_PANE, style,
  			 x2, y2, w2, h2, state_type, area))
*** modules/engines/ms-windows/xp_theme.c.old	2011-02-19 15:31:37.000000000 +0100
--- modules/engines/ms-windows/xp_theme.c	2011-05-16 00:12:17.436523400 +0200
***************
*** 111,126 ****
  };
  
  static const short element_part_map[XP_THEME_ELEMENT__SIZEOF] = {
!   BP_CHECKBOX,
!   BP_CHECKBOX,
!   BP_CHECKBOX,
!   BP_PUSHBUTTON,
!   HP_HEADERITEM,
    CP_DROPDOWNBUTTON,
    TABP_BODY,
!   TABP_TABITEM,
!   TABP_TABITEMLEFTEDGE,
!   TABP_TABITEMRIGHTEDGE,
    TABP_PANE,
    SBP_THUMBBTNHORZ,
    SBP_THUMBBTNVERT,
--- 111,127 ----
  };
  
  static const short element_part_map[XP_THEME_ELEMENT__SIZEOF] = {
!   BP_CHECKBOX, // PRESSED_CHECKBOX
!   BP_CHECKBOX, // CHECKBOX
!   BP_CHECKBOX, // INCONSISTENT_CHECKBOX
!   BP_PUSHBUTTON, // BUTTON
!   HP_HEADERITEM, // LIST_HEADER
    CP_DROPDOWNBUTTON,
    TABP_BODY,
!   TABP_TABITEM,             // TAB_ITEM
!   TABP_TABITEMLEFTEDGE,     // TAB_ITEM_LEFT_EDGE
!   TABP_TABITEMRIGHTEDGE,    // TAB_ITEM_RIGHT_EDGE
!   TABP_TABITEMBOTHEDGE,     // TAB_ITEM_BOTH_EDGES
    TABP_PANE,
    SBP_THUMBBTNHORZ,
    SBP_THUMBBTNVERT,
***************
*** 408,413 ****
--- 409,415 ----
      case XP_THEME_ELEMENT_TAB_ITEM:
      case XP_THEME_ELEMENT_TAB_ITEM_LEFT_EDGE:
      case XP_THEME_ELEMENT_TAB_ITEM_RIGHT_EDGE:
+     case XP_THEME_ELEMENT_TAB_ITEM_BOTH_EDGES:
      case XP_THEME_ELEMENT_TAB_PANE:
        klazz = XP_THEME_CLASS_TAB;
        break;
***************
*** 536,541 ****
--- 538,544 ----
  
      case XP_THEME_ELEMENT_TAB_ITEM_LEFT_EDGE:
      case XP_THEME_ELEMENT_TAB_ITEM_RIGHT_EDGE:
+     case XP_THEME_ELEMENT_TAB_ITEM_BOTH_EDGES:
      case XP_THEME_ELEMENT_TAB_ITEM:
        switch (state)
  	{
***************
*** 844,864 ****
        break;
  
      case XP_THEME_ELEMENT_LINE_H:
!       switch (state)
! 	{
! 	  /* LHS_FLAT, LHS_RAISED, LHS_SUNKEN */
! 	  ret = LHS_RAISED;
! 	  break;
! 	}
        break;
  
      case XP_THEME_ELEMENT_LINE_V:
!       switch (state)
! 	{
! 	  /* LVS_FLAT, LVS_RAISED, LVS_SUNKEN */
! 	  ret = LVS_RAISED;
! 	  break;
! 	}
        break;
  
      case XP_THEME_ELEMENT_SCALE_TROUGH_H:
--- 847,859 ----
        break;
  
      case XP_THEME_ELEMENT_LINE_H:
!       /* LHS_FLAT, LHS_RAISED, LHS_SUNKEN */
!       ret = LHS_RAISED;
        break;
  
      case XP_THEME_ELEMENT_LINE_V:
!       /* LVS_FLAT, LVS_RAISED, LVS_SUNKEN */
!       ret = LVS_RAISED;
        break;
  
      case XP_THEME_ELEMENT_SCALE_TROUGH_H:
*** modules/engines/ms-windows/xp_theme.h.old	2011-02-19 15:31:37.000000000 +0100
--- modules/engines/ms-windows/xp_theme.h	2011-05-16 00:11:54.692382800 +0200
***************
*** 59,64 ****
--- 59,65 ----
    XP_THEME_ELEMENT_TAB_ITEM,
    XP_THEME_ELEMENT_TAB_ITEM_LEFT_EDGE,
    XP_THEME_ELEMENT_TAB_ITEM_RIGHT_EDGE,
+   XP_THEME_ELEMENT_TAB_ITEM_BOTH_EDGES,
    XP_THEME_ELEMENT_TAB_PANE,
    XP_THEME_ELEMENT_SCROLLBAR_H,
    XP_THEME_ELEMENT_SCROLLBAR_V,
