2005-09-13	Nicolas Setton  <setton@adacore.com>

	* gdk/win32/gdkevents-win32.c: Backport patch suggested for #158459.
	Fixes E902-004.

2005-06-17	Arnaud Charlet	<charlet@adacore.com>

	* gdk/win32/gdkdrawable-win32.c: Remove one use of GDI_CALL to
	avoid generating too many Gtk+ warnings.
	Part of E609-003.

2005-03-24	Arnaud Charlet	<charlet@adacore.com>

	* gtk/gtkbutton.c, gtk/gtkmain.c, gtk/gtkmenushell.c,
	gtk/gtkwidget.c, gtk/gtkwidget.h, gdk/gdkevents.h,
	gdk/win32/gdkevents-win32.c: Backport patch suggested for PR 107320

2005-01-07	Arnaud Charlet	<charlet@adacore.com>

	* gdk/win32/gdkselection-win32.c (_gdk_selection_property_store): Fix
	computation of string length.

2003-11-27	Arnaud Charlet	<charlet@adacore.com>

	* gtk/gtktextview.c (incremental_validate_callback): Increase amount
	of characters validated at each call, this gives a better behavior
	when loading big files.

	* gtk/gtktextbtree.c, gtk/gtktextiter.c: Remove some function calls
	when assertions are disabled.

	* gtk/gtktextlayout.c: Use local buffer to avoid dynamic memory
	allocation.

2002-11-25	Arnaud Charlet	<charlet@adacore.com>

	* gdk/win32/Makefile.in: Remove gdk-win32res.lo dependency,
	since we do not want to use the default Gtk+ icon.

2003-03-27	Arnaud Charlet <charlet@adacore.com>

	* gdk/win32/gdkwindow-win32.c: Bring parent window on top when
	destroying a modal window. Fixes unexpected lost focus.

2002-09-12	Florent Duguet	<duguet@adacore.com>

	* gdk/win32/gdkevents-win32.c: Force an update when paint message
	is received, otherwise windows in background are not immediately
	refreshed when moving a modal window on top of them.
	Add handling of WM_NCPAINT message to refresh some areas when a window
	from another application is moved on top of the current app.

--- gtk/gtktextview.c	2003/11/22 12:54:08	1.2
+++ gtk/gtktextview.c	2003/11/27 17:54:03
@@ -3150,7 +3150,7 @@ incremental_validate_callback (gpointer 
   
   DV(g_print(G_STRLOC"\n"));
   
-  gtk_text_layout_validate (text_view->layout, 2000);
+  gtk_text_layout_validate (text_view->layout, 20000);
 
   gtk_text_view_update_adjustments (text_view);
   
--- gtk/gtktextbtree.c	2003/11/22 00:11:14	1.1
+++ gtk/gtktextbtree.c	2003/11/22 00:40:42
@@ -3149,13 +3149,9 @@ ensure_end_iter_line (GtkTextBTree *tree
 {
   if (tree->end_iter_line_stamp != tree->chars_changed_stamp)
     {
-      int n_lines;
       int real_line;
 
-      /* n_lines is without the magic line at the end */
-      n_lines = _gtk_text_btree_line_count (tree);
- 
-      g_assert (n_lines >= 1);
+      g_assert (_gtk_text_btree_line_count (tree) >= 1);
 
       tree->end_iter_line = _gtk_text_btree_get_line_no_last (tree, -1, &real_line);
       
--- gtk/gtktextiter.c	2003/11/21 23:46:35	1.1
+++ gtk/gtktextiter.c	2003/11/22 00:07:39
@@ -150,6 +150,11 @@ iter_set_from_segment (GtkTextRealIter *
    truly computed lazily; often we don't need to do the full make_real
    work. This ensures the btree and line are valid, but doesn't
    update the segments. */
+
+#ifdef G_DISABLE_ASSERT
+#define gtk_text_iter_make_surreal(iter) ((GtkTextRealIter*)iter)
+
+#else
 static GtkTextRealIter*
 gtk_text_iter_make_surreal (const GtkTextIter *_iter)
 {
@@ -188,6 +193,7 @@ gtk_text_iter_make_surreal (const GtkTex
 
   return iter;
 }
+#endif
 
 static GtkTextRealIter*
 gtk_text_iter_make_real (const GtkTextIter *_iter)
@@ -385,15 +391,15 @@ is_segment_start (GtkTextRealIter *real)
   return real->segment_byte_offset == 0 || real->segment_char_offset == 0;
 }
 
-#if 1
+#ifdef G_DISABLE_ASSERT
+#define check_invariants(iter)
+#else
 static void
 check_invariants (const GtkTextIter *iter)
 {
   if (gtk_debug_flags & GTK_DEBUG_TEXT)
     _gtk_text_iter_check (iter);
 }
-#else
-#define check_invariants (x)
 #endif
 
 /**
--- gtk/gtktextlayout.c.orig	2004-03-14 00:28:14.000000000 +0100
+++ gtk/gtktextlayout.c	2004-10-19 14:34:24.000000000 +0100
@@ -1783,12 +1783,15 @@
                                   GtkTextLine   *line,
                                   gboolean       size_only)
 {
+#define TEXT_CACHE_SIZE 256
+  static gchar cached_text[TEXT_CACHE_SIZE];
+
   GtkTextLayoutPrivate *priv = GTK_TEXT_LAYOUT_GET_PRIVATE (layout);
   GtkTextLineDisplay *display;
   GtkTextLineSegment *seg;
   GtkTextIter iter;
   GtkTextAttributes *style;
-  gchar *text;
+  gchar *text = cached_text;
   PangoAttrList *attrs;
   gint text_allocated, layout_byte_offset, buffer_byte_offset;
   PangoRectangle extents;
@@ -1845,7 +1848,9 @@
   /* Allocate space for flat text for buffer
    */
   text_allocated = _gtk_text_line_byte_count (line);
-  text = g_malloc (text_allocated);
+
+  if (text_allocated > TEXT_CACHE_SIZE)
+    text = g_malloc (text_allocated);
 
   attrs = pango_attr_list_new ();
 
@@ -2007,7 +2012,15 @@
 	      if (layout->preedit_len > 0)
 		{
 		  text_allocated += layout->preedit_len;
-		  text = g_realloc (text, text_allocated);
+
+		  if (text_allocated > TEXT_CACHE_SIZE)
+		    if (text == cached_text)
+		      {
+			text = g_malloc (text_allocated);
+			memcpy (text, cached_text, text_allocated - layout->preedit_len);
+		      }
+		    else
+		      text = g_realloc (text, text_allocated);
 
 		  style = get_style (layout, &iter);
 		  add_preedit_attrs (layout, style, attrs, layout_byte_offset, size_only);
@@ -2115,7 +2128,8 @@
   if (layout->wrap_loop_count == 0)
     invalidate_cached_style (layout);
 
-  g_free (text);
+  if (text != cached_text)
+    g_free (text);
   pango_attr_list_unref (attrs);
 
   layout->one_display_cache = display;
--- gdk/win32/Makefile.in.old	2004-10-19 14:20:42.000000000 +0100
+++ gdk/win32/Makefile.in	2004-10-19 14:21:00.000000000 +0100
@@ -346,7 +346,7 @@
 	gdkwin32.h
 
 
-libgdk_win32_la_LIBADD = rc/gdk-win32res.lo
+libgdk_win32_la_LIBADD =
 subdir = gdk/win32
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
@@ -355,7 +355,7 @@
 LTLIBRARIES = $(noinst_LTLIBRARIES)
 
 libgdk_win32_la_LDFLAGS =
-libgdk_win32_la_DEPENDENCIES = rc/gdk-win32res.lo
+libgdk_win32_la_DEPENDENCIES =
 am_libgdk_win32_la_OBJECTS = gdkcolor-win32.lo gdkcursor-win32.lo \
 	gdkdisplay-win32.lo gdkdnd-win32.lo gdkdrawable-win32.lo \
 	gdkevents-win32.lo gdkfont-win32.lo gdkgc-win32.lo \
--- gdk/win32/gdkevents-win32.c.orig	2004-09-03 02:30:03.000000000 +0100
+++ gdk/win32/gdkevents-win32.c	2004-10-19 14:38:35.000000000 +0100
@@ -2036,6 +2036,12 @@
   _gdk_window_process_expose (window, update_region);
   gdk_region_destroy (update_region);
 
+  /* Force a process_updates to refresh visible windows
+   * when receiving a paint message. */
+
+  if (!GDK_WINDOW_DESTROYED (window) && gdk_window_is_visible (window))
+    gdk_window_process_updates (window, FALSE);
+
   DeleteObject (hrgn);
 }
 
@@ -2862,6 +2868,35 @@
       *ret_valp = 1;
       break;
 
+    case WM_NCPAINT:
+      if (msg->wParam < 1)
+	break;
+
+      {
+      HRGN hrgn;
+
+      hrgn = CreateRectRgn (0, 0, 0, 0);
+      if (GetUpdateRgn (msg->hwnd, hrgn, FALSE) == ERROR)
+	{
+	  WIN32_GDI_FAILED ("GetUpdateRgn");
+	  break;
+	}
+
+      {
+        GdkRegion *update_region = _gdk_win32_hrgn_to_region (hrgn);
+
+	_gdk_windowing_window_get_offsets (window, &xoffset, &yoffset);
+	gdk_region_offset (update_region, xoffset, yoffset);
+
+	_gdk_window_process_expose (window, update_region);
+	gdk_region_destroy (update_region);
+
+	DeleteObject (hrgn);
+	return_val = FALSE;
+      }
+      }
+      break;
+
     case WM_PAINT:
       handle_wm_paint (msg, window, FALSE, NULL);
       break;
--- gdk/win32/gdkwindow-win32.c	2003/03/27 14:43:01	1.1
+++ gdk/win32/gdkwindow-win32.c	2003/04/13 09:22:48
@@ -742,6 +742,15 @@
   GDK_NOTE (MISC, g_print ("_gdk_windowing_window_destroy %p\n",
 			   GDK_WINDOW_HWND (window)));
 
+  if (private->modal_hint)
+    {
+      HWND parent = (HWND) GetWindowLong
+	(GDK_WINDOW_HWND (window), GWL_HWNDPARENT);
+
+      if ((long)parent > 1 && !BringWindowToTop (parent))
+	WIN32_API_FAILED ("BringWindowToTop");
+    }
+
   if (private->extension_events != 0)
     _gdk_input_window_destroy (window);
 
--- gdk/win32/gdkselection-win32.c.old	2005-01-07 15:06:43.000000000 +0100
+++ gdk/win32/gdkselection-win32.c	2005-01-07 15:06:48.000000000 +0100
@@ -158,7 +158,7 @@ _gdk_selection_property_store (GdkWindow
 	  return;
 	}
       else
-	prop->length = strlen (prop->data + 1);
+	prop->length = strlen (prop->data) + 1;
     }
   else
     {
--- gtk/gtkbutton.c.orig	2004-11-16 06:30:37.000000000 +0100
+++ gtk/gtkbutton.c	2005-03-23 16:19:59.000000000 +0100
@@ -106,6 +106,8 @@
 				       GdkEventButton   *event);
 static gint gtk_button_button_release (GtkWidget        *widget,
 				       GdkEventButton   *event);
+static gint gtk_button_grab_broken    (GtkWidget        *widget,
+				       GdkEventAny      *event);
 static gint gtk_button_key_release    (GtkWidget        *widget,
 				       GdkEventKey      *event);
 static gint gtk_button_enter_notify   (GtkWidget        *widget,
@@ -190,6 +192,7 @@
   widget_class->expose_event = gtk_button_expose;
   widget_class->button_press_event = gtk_button_button_press;
   widget_class->button_release_event = gtk_button_button_release;
+  widget_class->grab_broken_event = gtk_button_grab_broken;
   widget_class->key_release_event = gtk_button_key_release;
   widget_class->enter_notify_event = gtk_button_enter_notify;
   widget_class->leave_notify_event = gtk_button_leave_notify;
@@ -1138,6 +1141,29 @@
 }
 
 static gboolean
+gtk_button_grab_broken (GtkWidget   *widget,
+			GdkEventAny *event)
+{
+  GtkButton *button = GTK_BUTTON (widget);
+  gboolean save_in;
+  
+  /* Simulate a button release without the pointer in the button */
+  if (button->button_down)
+    {
+      save_in = button->in_button;
+      button->in_button = FALSE;
+      gtk_button_released (button);
+      if (save_in != button->in_button)
+	{
+	  button->in_button = save_in;
+	  gtk_button_update_state (button);
+	}
+    }
+
+  return TRUE;
+}
+
+static gboolean
 gtk_button_key_release (GtkWidget   *widget,
 			GdkEventKey *event)
 {
--- gtk/gtkmain.c.orig	2004-08-03 23:22:03.000000000 +0100
+++ gtk/gtkmain.c	2005-03-23 16:20:01.000000000 +0100
@@ -1558,6 +1558,7 @@
     case GDK_CLIENT_EVENT:
     case GDK_VISIBILITY_NOTIFY:
     case GDK_WINDOW_STATE:
+    case GDK_GRAB_BROKEN:
       gtk_widget_event (event_widget, event);
       break;
 
--- gtk/gtkmenushell.c.orig	2004-06-01 23:41:42.000000000 +0100
+++ gtk/gtkmenushell.c	2005-03-24 07:54:36.000000000 +0100
@@ -124,6 +124,8 @@
 					      GdkEventCrossing  *event);
 static gint gtk_menu_shell_leave_notify      (GtkWidget         *widget,
 					      GdkEventCrossing  *event);
+static gint gtk_menu_shell_grab_broken       (GtkWidget         *widget,
+					      GdkEventButton    *event);
 static void gtk_menu_shell_add               (GtkContainer      *container,
 					      GtkWidget         *widget);
 static void gtk_menu_shell_remove            (GtkContainer      *container,
@@ -204,6 +206,7 @@
   widget_class->realize = gtk_menu_shell_realize;
   widget_class->button_press_event = gtk_menu_shell_button_press;
   widget_class->button_release_event = gtk_menu_shell_button_release;
+  widget_class->grab_broken_event = gtk_menu_shell_grab_broken;
   widget_class->key_press_event = gtk_menu_shell_key_press;
   widget_class->enter_notify_event = gtk_menu_shell_enter_notify;
   widget_class->leave_notify_event = gtk_menu_shell_leave_notify;
@@ -557,6 +560,25 @@
 }
 
 static gint
+gtk_menu_shell_grab_broken (GtkWidget      *widget,
+			    GdkEventButton *event)
+{
+  GtkMenuShell *menu_shell;
+
+  g_return_val_if_fail (GTK_IS_MENU_SHELL (widget), FALSE);
+  g_return_val_if_fail (event != NULL, FALSE);
+
+  menu_shell = GTK_MENU_SHELL (widget);
+  if (menu_shell->active)
+    {
+      gtk_menu_shell_deactivate (menu_shell);
+      g_signal_emit (menu_shell, menu_shell_signals[SELECTION_DONE], 0);
+    }
+
+  return TRUE;
+}
+
+static gint
 gtk_menu_shell_key_press (GtkWidget	*widget,
 			  GdkEventKey *event)
 {
--- gtk/gtkwidget.c.orig	2004-10-12 16:16:01.000000000 +0100
+++ gtk/gtkwidget.c	2005-03-23 16:20:01.000000000 +0100
@@ -119,6 +119,7 @@
   ACCEL_CLOSURES_CHANGED,
   SCREEN_CHANGED,
   CAN_ACTIVATE_ACCEL,
+  GRAB_BROKEN,
   LAST_SIGNAL
 };
 
@@ -395,6 +396,7 @@
   klass->drag_data_received = NULL;
   klass->screen_changed = NULL;
   klass->can_activate_accel = gtk_widget_real_can_activate_accel;
+  klass->grab_broken_event = NULL;
 
   klass->show_help = gtk_widget_real_show_help;
   
@@ -1282,6 +1284,15 @@
 		  _gtk_marshal_BOOLEAN__BOXED,
 		  G_TYPE_BOOLEAN, 1,
 		  GDK_TYPE_EVENT | G_SIGNAL_TYPE_STATIC_SCOPE);
+  widget_signals[GRAB_BROKEN] =
+    g_signal_new ("grab_broken_event",
+		  G_TYPE_FROM_CLASS (gobject_class),
+		  G_SIGNAL_RUN_LAST,
+		  G_STRUCT_OFFSET (GtkWidgetClass, grab_broken_event),
+		  _gtk_boolean_handled_accumulator, NULL,
+		  _gtk_marshal_BOOLEAN__BOXED,
+		  G_TYPE_BOOLEAN, 1,
+		  GDK_TYPE_EVENT | G_SIGNAL_TYPE_STATIC_SCOPE);
 /**
  * GtkWidget::popup-menu
  * @widget: the object which received the signal
@@ -3555,6 +3566,9 @@
 	case GDK_VISIBILITY_NOTIFY:
 	  signal_num = VISIBILITY_NOTIFY_EVENT;
 	  break;
+	case GDK_GRAB_BROKEN:
+	  signal_num = GRAB_BROKEN;
+	  break;
 	default:
 	  g_warning ("gtk_widget_event(): unhandled event type: %d", event->type);
 	  signal_num = -1;
--- gtk/gtkwidget.h.orig	2005-03-24 08:30:26.000000000 +0100
+++ gtk/gtkwidget.h	2005-03-23 16:20:01.000000000 +0100
@@ -406,8 +406,11 @@
   gboolean     (*can_activate_accel) (GtkWidget *widget,
                                       guint      signal_id);
 
+  /* Sent when a grab is broken. */
+  gboolean (*grab_broken_event) (GtkWidget	     *widget,
+                                 GdkEventAny         *event);
+
   /* Padding for future expansion */
-  void (*_gtk_reserved2) (void);
   void (*_gtk_reserved3) (void);
   void (*_gtk_reserved4) (void);
   void (*_gtk_reserved5) (void);
--- gdk/gdkevents.h.orig	2003-08-11 00:37:29.000000000 +0100
+++ gdk/gdkevents.h	2005-03-23 16:49:36.000000000 +0100
@@ -1,3 +1,4 @@
+
 #ifndef __GDK_EVENTS_H__
 #define __GDK_EVENTS_H__
 
@@ -118,7 +119,9 @@
   GDK_NO_EXPOSE		= 30,
   GDK_SCROLL            = 31,
   GDK_WINDOW_STATE      = 32,
-  GDK_SETTING           = 33
+  GDK_SETTING           = 33,
+  GDK_OWNER_CHANGE      = 34,
+  GDK_GRAB_BROKEN       = 35
 } GdkEventType;
 
 /* Event masks. (Used to select what types of events a window
--- gdk/win32/gdkevents-win32.c.orig	2005-01-06 11:01:07.000000000 +0100
+++ gdk/win32/gdkevents-win32.c	2005-03-23 16:20:01.000000000 +0100
@@ -2908,8 +2908,25 @@
 	 }
        break;
 
-    case WM_SETFOCUS:
     case WM_KILLFOCUS:
+      if (p_grab_window != NULL && !GDK_WINDOW_DESTROYED (p_grab_window))
+	{
+	  event = gdk_event_new (GDK_GRAB_BROKEN);
+	  event->any.window = p_grab_window;
+
+          append_event (display, event);
+	}
+      if (k_grab_window != NULL && !GDK_WINDOW_DESTROYED (k_grab_window) 
+	  && k_grab_window != p_grab_window)
+	{
+	  event = gdk_event_new (GDK_GRAB_BROKEN);
+	  event->any.window = k_grab_window;
+
+          append_event (display, event);
+	}
+
+      /* fallthrough */
+    case WM_SETFOCUS:
       if (k_grab_window != NULL && !k_grab_owner_events)
 	break;
 
--- gdk/win32/gdkdrawable-win32.c.old	2005-06-16 16:41:30.000000000 +0100
+++ gdk/win32/gdkdrawable-win32.c	2005-06-16 16:42:03.000000000 +0100
@@ -1583,8 +1583,8 @@
 	}
       
       if (ok)
-	GDI_CALL (BitBlt, (hdc, xdest, ydest, width, height,
-			   srcdc, xsrc, ysrc, rop2_to_rop3 (gcwin32->rop2)));
+	BitBlt (hdc, xdest, ydest, width, height,
+		srcdc, xsrc, ysrc, rop2_to_rop3 (gcwin32->rop2));
       
       /* Restore source's color table if necessary */
       if (ok && newtable_size > 0 && oldtable_size > 0)
*** gdk/win32/gdkevents-win32.c.original	Tue Sep 13 11:03:37 2005
--- gdk/win32/gdkevents-win32.c	Tue Sep 13 11:05:16 2005
***************
*** 3284,3290 ****
  	  maxw = rect.right - rect.left;
  	  maxh = rect.bottom - rect.top;
  	  mmi->ptMaxTrackSize.x = maxw > 0 && maxw < G_MAXSHORT ? maxw : G_MAXSHORT;
! 	  mmi->ptMaxTrackSize.y = maxh > 0 && maxh < G_MAXSHORT ? maxw : G_MAXSHORT;
  	}
  
        if (impl->hint_flags & (GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE))
--- 3284,3290 ----
  	  maxw = rect.right - rect.left;
  	  maxh = rect.bottom - rect.top;
  	  mmi->ptMaxTrackSize.x = maxw > 0 && maxw < G_MAXSHORT ? maxw : G_MAXSHORT;
! 	  mmi->ptMaxTrackSize.y = maxh > 0 && maxh < G_MAXSHORT ? maxh : G_MAXSHORT;
  	}
  
        if (impl->hint_flags & (GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE))
