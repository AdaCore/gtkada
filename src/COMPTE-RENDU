(Legende : -  a faire    * done)

Date : 30/06/1998

* Mapping des noms de fonction : on supprime le gtk_ et aussi le nom de la widget.
  seule exception : pour gtk_*_new, qui devient Gtk_New
* Les commentaires se feront en anglais.
* On n'implemente que les fonctions qui sont correctement documentees.
* Tous : Pour tester le binding, on va refaire le test_gtk.
* Ne pas mettre les fonctions ou les macros C qui sont la pour emuler
  la programmation OO.
* Faire attention a la portabilite.
* On oublie le Inline des differentes fonctions du mapping pour le moment,
  mais on n'est pas tout a fait sur. (en plus la compilation est plus longue).

* Joel : Regarder comment passer la ligne de commande a gtk_init, et comment
          recuperer la ligne de commande epuree apres gtk_init
* Joel : Faire les GtkButtons
* Joel : Jeter un oeil au mapping de gdk

* Manu : Liberation de la memoire pour les callback.
* Manu : Faire les GtkBox
* Manu : Se renseigner pour l'utilisation des Inline pour les fonctions du binging
 

Date : 03/07/1998

* Nom des packages :  Gtk.<Nom_Du_Widget>    ex/ Gtk.Widget Gtk.Container Gtk.Button
  On ne met pas tout l'arbre de l'heritage dans le nom.

* Joel : fait le skelette de testgtk
* Joel : Rajoute des \ dans les commentaire "mapping" si ceux-ci tiennent sur
         plus d'une ligne.
* Tous : Les procedures qui emettent des signaux (ex gtk_button_clicked). On
         les implemente toutes.
* Tous : Utiliser cvs update pour mettre a jour (et pas cvs checkout)
* Tous : choix du mode pour les parametres : 
         "in" vs "in out" : on met ce qui 'logiquement' convient le mieux.
* Tous : On ne peut pas faire de type enumere pour les signaux (ie Clicked au lieu
         de "clicked") car les nouveaux widget doivent pouvoir creer de nouveaux
         signaux comme ils veulent.
* Tous : Pour les fonctions C qui sont importees, on met "in" ou "out" suivant
         les cas, ya pas de regle. Adopter en fonction des passages de parametre entre
         C et Ada.
* Joel : je vire Gtk.Types, Gtk_True avec et je mets To_Boolean dans 
         la partie private de gtk.
          mettre Inline (To_Boolean)
* Tous : Passer le type Gtk.Object dans un package a part : package Gtk.Object
* Tous : Pour les types, on les nomme Gtk_<Nom-du-widget>.
         Pour les noms de proc/fonction, on vire tout le preambule, et on
         ne met que la partie utile (ex/ gtk_button_set_mode devient Set_Mode).
         L'exception : Quand le nom donne un mot reserve de Ada95, on
         met Gtk_ devant. (Ex/ gtk_button_new devient Gtk_New).
* Manu : Dans le callback, il faudrait trouver un moyen de transformer une
         widget en une widget de plus haut niveau. Par ex, si on sait que c'est
         un bouton, il faudrait pouvoir le convertir en bouton.
* Joel : Dans Gtk_Toggle_Buttons :
         Changer Get_State pour Is_Selected qui renvoie un Boolean
         Set_State pour Set_State (To_Selected : Boolean) pour eliminer
            l'utilsation du type enumere
* Joel : Mettre un gros commentaire la ou j'ai mis les extern pour la gestion
         de la ligne de commande. (en fait, on cree plutot un fichier misc-gnat.c)
* Tous : implementation de fonctions C :
         Faire une fichier commun misc.c qui contienne pour le moment
            #include "misc-manu.c"
            #include "misc-joel.c"
         Solution temporaire, pour ensuite tout regrouper soit de temps
         en temps (tous les week-ends?) soit a la fin.
* Joel : Finir Gtk.Widget et Gtk.Container.
* Joel : Faire les widget de facon a creer Gtk.Menu_Item


Date : 08/07/1998

* Joel : Update du Makefile avec le gtk-config
* Joel : Faire les marge pour remettre a jour tous les fichiers. Manu fera juste un ftp ensuite :-)
* Manu : Utiliser les memes noms de parametres que dans gtk
* Tous : Regrouper les gktenums dans Gtk.ads
* Manu : Gtk_Color_Selection_Dialog herite de Gtk_Window.
* Joel : Creer un type abstract Gtk_Root pour le cas des objects qui n'heritent pas de Gtk_Object.
* Joel : Respecter les types abstracts quand il y en a (lire la doc de gtk pour savoir)
* Joel : Gtk.Object est considere au meme titre que les autres, donc on le met dans un fichier 
         a part entiere. Il doit heriter de Gtk_Root.

Date : 13/07/1998

* Joel : Marquer d'une '*' toutes les taches terminees.
- Manu : Terminer les widgets restantes.
- Manu : Revoir Gtk.Toolbar
* Joel : Commencer a voir Gdk.
* tous : Gtk_New reste un procedure pour le moment.
* tous : Utiliser generate.pl pour generer les widgets. Parait qu'on gagne
         du temps.
- Joel : Parler a OA a propos d'un eventuel message dans les news ou 
         alors si il faut alerter la presse ou pas.
- tous : produire une version alpha pour le 20 juillet.
- Manu : Voir comment faire une lib statique [LOW PRIORITY]
* Manu : Essayer de reflechir a un script qui verifie les types enumeres.
- Manu : Demander a quelqu'un comment passer un type enumere au C.
- tous : coder les widgets de l'autre dans testgtk.
- Joel : passer le type Object en abstract.
* Manu : changer generate.pl de sorte que les types qui n'ont pas de new
         soient declares en abstract.
* Manu : Je recopie tel-quels tes idees :
<<Une premiere idee (non teste) serait de modifier gtk_new. A chaque fois
qu'on cree un widget, on insere son type (no au sens e gtk) et l
le type object correspondant dans une htable... Ca permet de ne chercher la con
version
qwue sur les types qui sont effectivement present au niveau du programme, et ca
 permet d'intergrer facilement de nouveaux iwidgets, puisque c'est dynamique.
Ca ne devrait pas trop ralentir (par rapport a tous les appels de fonctions fai
t au niveau de gtk, un de plus ou de moins....)

Pour ce qui est de get_type, on l'importe dans le Gtk_New mais on ne le
declare pas dans les specs.
>>


Reunion du 17 Juillet 1997

* Manu : Rajouter un test dans Gtk.Signal pour qu'on puisse passer null.
         Retirer les "void callbacks"...
- Joel : Regarder le probleme des flags, et essayer de trouver une solution
         elegante.
         Ensuite, il faudra l'implementer.
* Manu : Regarder le pb des callbacks : il faut pouvoir acceder directement
         a l'objet lui meme dans le callback et non a une copie. C'est
         important en cas de destroy par ex.
* Manu : Regarder le gros pb des callback.
  Joel : P*****, ca va marcher oui!
- Joel : Regarder du cote des libtools pour faire une lib dynamique
* Joel : Modifier le script mapping.pl
    > s/\s+/ /;  # pour supprimer les blancs multiples.
    > s/ (\*+)/$1 / ; # pour attacher les etoiles au type
    > puis la fonction originale
    > > if (/^(\S+)\s+(g[td]k_\S+)\s+\((.*)/)
- Joel : Aller voir les fichier .defs de guile-gtk
         (home page GTK, aller voir la FAQ rubrique sur les bindings).
* Joel : comment faire pour passer un GdkBitmap**.

         
