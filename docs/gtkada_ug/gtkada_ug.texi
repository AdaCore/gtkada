\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename gtkada.info
@settitle GtkAda User's Guide
@syncodeindex fn cp

@titlepage

@set GtkAdaVersion 1.2.5

@title GtkAda User's Guide
@subtitle Version @value{GtkAdaVersion}
@subtitle Document revision level $Revision$
@subtitle Date: $Date$
@author E. Briot, J. Brobecker, A. Charlet, P. Durif

@page
@vskip 0pt plus 1filll

Copyright @copyright{} 1998-1999, Emmanuel Briot, Joel Brobecker, Arnaud Charlet

This document may be copied, in whole or in part, in any form or by any
means, as is or with alterations, provided that (1) alterations are clearly
marked as alterations and (2) this copyright notice is included
unmodified in any copy.

@end titlepage

@ifinfo
@node Top, Introduction, (dir), (dir)
@top GtkAda User's Guide

GtkAda User's Guide

GtkAda, the Ada 95 graphical toolkit

Version @value{GtkAdaVersion}

Date: $Date$

Copyright @copyright{} 1998-1999, Emmanuel Briot, Joel Brobecker, Arnaud Charlet

This document may be copied, in whole or in part, in any form or by any
means, as is or with alterations, provided that (1) alterations are clearly
marked as alterations and (2) this copyright notice is included
unmodified in any copy.

@menu
* Introduction::
* Getting started with GtkAda::
* Hierarchical composition of a window::
* Signal handling::
* Start an application with GtkAda::
* General GTK documentation::
* Description of the GDK hierarchy::
* Description of the Glib hierarchy::
* Resource files::
* Creating and Binding new widgets::
* Threads::
* How to report bugs::
* Object-oriented features::
* Support for Glade the Gtk GUI builder::
* Bibliography::

@detailmenu
 --- The Detailed Node Listing ---

Getting started with GtkAda

* How to build and install GtkAda::
* Organization of the GtkAda package::
* How to compile an application with GtkAda::
* Architecture of the toolkit::
* Widgets Hierarchy::

General GTK documentation

* Package Gtk.Main - high level routines::
* Package Gtk.Handlers - connecting callbacks::
* Package Gtk.Tooltips::
* Package Gtk.Adjustment::
* Package Gtk.Widget::
* Package Gtk.Label::
* Package Gtk.Scrollbar::
* Package Gtk.Drawing_Area::
* Package Gtk.Text::
* Package Gtk.Container::
* Package Gtk.Table::
* Package Gtk.Scrolled_Window::
* Package Gtk.Notebook::
* Package Gtk.Box::
* Package Gtk.Button::
* Package Gtk.Toggle_Button::
* Package Gtk.Check_Button::
* Package Gtk.Event_Box::
* Package Gtk.Window::
* Package Gtk.File_Selection::
* Package Gtk.Enums::

Description of the GDK hierarchy

* Package Gdk.Color::
* Package Gdk.Point::
* Package Gdk.Window::
* Package Gdk.Drawable::
* Package Gdk.GC::
* Package Gdk.Font::
* Draw in a widget::

Object-oriented features
* Converting your applications to the new tagged type scheme::
* Using tagged types to extend Gtk widgets::
* Creating new widgets in Ada::

@end detailmenu
@end menu
@end ifinfo

@c --------------------------------------------------------------------
@node Introduction
@chapter Introduction: What is GtkAda ?
@c --------------------------------------------------------------------

@noindent
GtkAda is a high-level portable graphical toolkit, based on the gtk+
toolkit, one of the official GNU toolkit. It makes it easy to create
portable user interfaces for multiple platforms, including most
platforms that have a X11 server, and Win32 platforms.

Although it is based on a C library, GtkAda uses some advanced Ada95
features like tagged types, generic packages, access to subprograms,
exceptions, etc@dots{} to make it easier to use and design interfaces.
For efficiency reasons, it does not use controlled types, but takes care
of all the memory management for you in other ways.

As a result, this library provides a @i{secure}, @i{easy to use} and
@i{extensible} toolkit.

Compared to the C library, GtkAda provides type safety (especially in the
callbacks area), and object-oriented programming. As opposed to common
knowledge, it requires @i{less} type casting than with in C.
Its efficiency is about the same as the C library through the use of inline
subprograms.

GtkAda comes with a complete integration to the graphical interface
builder @code{Glade}@footnote{Glade was written by Damon Chaplin}. This
makes it even easier to develop interfaces, since you just have to click
to create a window and all the dialogs. Ada code can then be generated
with a single click.

GtkAda also has a full support for OpenGL, and comes with a very thin
binding to the OpenGL (@code{Mesa}) libraries.

The following Internet sites will always contain the latest new and
packages for @code{GtkAda}, @code{gtk+} and @code{Glade}.

     @uref{http://gtkada.eu.org}

     @uref{http://www.gtk.org}

     @uref{http://glade.pn.org}
     

The scheme used for GtkAda's version numbers is the following: the major
version number follows gtk+ (e.g 1.2 or 1.3). Thus, stable versions of
GtkAda will have even major numbers, and development versions will have
odd version numbers. The minor version numbers depends on GtkAda's
release number.

This documentation is distributed with GtkAda @b{version
@value{GtkAdaVersion}}.  Every widget from @w{gtk+ 1.2} has been
implemented, and the test program found in the gtk release has been
re-implemented in Ada (have a look at the @code{testgtk/} directory in the
distribution).

This binding was tested on the following systems:
@itemize @bullet
@item Linux/x86
@item Solaris/sparc
@item Solaris/x86
@item Dec Unix 4.0b
@item SGI IRIX 6.5
@item HP/UX 10.20
@item HP/UX 11.00
@item NT 4.0
@item AiX 4.3.2
@item SCO UnixWare 7.1
@end itemize

with the latest version of the @code{GNAT} compiler, developed by
Ada Core Technologies (see @uref{http://www.gnat.com}).

If you manage to use it on other systems (which should probably be
straightforward - just recompile GtkAda), please let us know so that
we can add to the above list.

This version of GtkAda is compatible with @code{gtk+} up to @b{version
1.2.6}. This release is no longer compatible with older versions of gtk+
(up to 1.0). If you really need to use such an old version, please
consider downloading GtkAda 0.2.1 (but be aware that your code will
never work with recent versions, since the API has been completely
rewritten since then).

This version of GtkAda is compatible with @code{Glade} @b{version
0.5.5}.  Due to some modification in the output format of Glade, this
release will not work with older versions. It is also not guaranteed to
work with more recent versions. Please update your version of Glade.

This document does not describe all the widgets available in GtkAda, nor
does it try to explain all the subprograms. Instead, we recommend that you
download the gtk+ documentation from the gtk+ web site.

Most of the documentation for GtkAda is found in the Ada sources themselves,
in the spec files, whose extension is @file{.ads}.

No complete example is provided in this documentation. Instead, please
refer to the examples that you can find in the @file{testgtk/} and
@file{examples/} directory in the GtkAda distribution, since these are
more up-to-date (and more extensive).
They are heavily commented, and are likely to contain a lot of
information that you might find interesting.


@c --------------------------------------------------------------------
@node Getting started with GtkAda
@chapter Getting started with GtkAda
@c --------------------------------------------------------------------

@noindent
This chapter described how to start a new GtkAda application. It explains
the basic features of the binding, and shows how to compile and run your
application.

It also gives a brief overview of the extensive widget hierarchy available
in GtkAda.

@menu
* How to build and install GtkAda::
* Organization of the GtkAda package::
* How to compile an application with GtkAda::
* Architecture of the toolkit::
* Widgets Hierarchy::
@end menu

@c ---------------------------------------------------------------------
@node How to build and install GtkAda
@section How to build and install GtkAda
@c ---------------------------------------------------------------------

@noindent
This section explains how to build and install GtkAda on your machine.
It is Unix-oriented, since GtkAda is distributed in binary format on
Windows machines, and comes with all the dependent packages, including
the gtk+ libraries and @code{Glade}.

On Unix systems, you need to first install the gtk+ libraries. Download
the compatible packages from the gtk+ web site, and make sure that
the @code{gtk-config} script is in your @var{PATH} environment variable.

Optionally, you can also install the @code{Glade} interface builder. Get
the compatible package from the Glade web site, compile and install it.

You can then get the latest version of GtkAda from the web site.
Untar and uncompress the package, then simply do the following
steps:
@example
   > ./configure
   > make
   > make install
@end example

As usual with the @code{configure} script, you can specify where you want
to install the GtkAda libraries by using the @code{--prefix} switch.

If you have some OpenGL libraries installed on your system, you can make
sure that @code{configure} finds them by specifying the
@code{--with-GL-prefix} switch on the command line. @code{configure}
should be able to automatically detect the libraries however.

You then have to make sure that the system will be able to find the
dynamic libraries if your application uses them. Typically, you would do
one of the following:
@itemize @bullet
@item run @code{ldconfig} if you installed GtkAda in one of the standard
  location and you are super-user on your machine
@item edit @code{/etc/ld.conf} if you are super-user but did not install
  GtkAda in one of the standard location. Add the path that contains
  libgtkada.so (by default @file{/usr/local/lib} or @file{$prefix/lib}.
@item modify your @code{LD_LIBRARY_PATH} environment variable if you are
  not super-user. You should simply add the path to libgtkada.
@end itemize

@c ----------------------------------------------------------------------
@node Organization of the GtkAda package
@section Organization of the GtkAda package
@c ----------------------------------------------------------------------

In addition to the full sources, the GtkAda package contains a lot of
heavily commented examples. If you haven't visited those examples, we
really recommend that you look at them and try to understand them, since
they contain some examples of code that you might find interesting for
your own application.

@itemize @bullet

@item @file{testgtk/} directory:

This directory contains an application that tests all the widgets in GtkAda.
It gives you a quick overview of what can be found in the toolkit, as well
as some detailed information on the widgets and their parameters.

All the demos are associated with a contextual help that points to its
aspects that are worth studying.

It also contains an OpenGL demo if your application was compiled with
support for OpenGL.

@item @file{examples/} directory:

This directory contains some small examples, unrelated to testgtk.  For
instance, this is were you will find some sample XML files for
@code{Gate} and @code{Dgate}, as well as some new widgets created
directly in Ada, or examples on how to created your own callback
marshallers.

@item @file{docs/} directory:

It contains the html, info and @TeX{} versions of the documentation you
are currently reading. It also contains a subdirectory with some slides
that were used to present GtkAda at various shows.

@end itemize

@c ----------------------------------------------------------------------
@node How to compile an application with GtkAda
@section How to compile an application with GtkAda
@c ----------------------------------------------------------------------

@subsection Unix systems

@noindent
On Unix systems, a script called @code{gtkada-config} is automatically
created when you build GtkAda. This script is copied in a subdirectory
@file{bin/} of the installation directory.

The easiest and recommended way to build a GtkAda application is to
use the @code{gnatmake} program distributed with GNAT, that takes care of
all the dependencies for you. Use the @code{gtkada-config} to specify
where GtkAda and gtk+ libraries have been installed.

@example
   > gnatmake <main-file> `gtkada-config`
@end example

Note the use of back-ticks around gtkada-config, which force the shell to
evaluate the script and put the output on the command line.

The script @code{gtkada-config} understands the following command line
switches (chosen to be compatible with the ones set by @code{gtk-config}):

@itemize @bullet
@item @code{--cflags}: Output only the compiler flags, i.e the  include
  directories where the GtkAda spec files are found. This should be used
  if you only want to compile your files, but do not want to bind or link
  them.
@item @code{--libs}: Output only the switches for the linker. This lists
  the directories where all the GtkAda, gtk+, and dependant libraries are
  found. For instance, if GtkAda was compiled with support for OpenGL,
  the OpenGL libraries will automatically be present.
@item @code{--static}: Forces the libraries to be static libraries instead
  of dynamic ones.
@end itemize

@subsection Windows systems

Things are somewhat easier on windows systems. You don't have access to the
@code{gtkada-config} script. However, the good news is that you also don't
have to specify which libraries to use or where to find them.

The only thing you should specify on the @code{gnatmake} command line is
where the GtkAda spec files are found, as in:

@smallexample
   > gnatmake <main-file> -Ic:\GtkAda\lib
@end smallexample

if GtkAda was installed in @file{c:\GtkAda}.

No static libraries are provided currently, so you can't create a static
version of your application and you will have to use the dynamic libraries.

@c ---------------------------------------------------------------------
@node Architecture of the toolkit
@section Architecture of the toolkit
@c ---------------------------------------------------------------------

@noindent
The gtk+ toolkit has been designed from the beginning to be portable.
It is made of three libraries, @code{gtk}, @code{gdk} and @code{glib}.

@code{Glib} is a non-graphical library, that includes support for lists,
h-tables, threads, etc@dots{} It is a highly optimized,
platform-independent library. Since most of its contents is already
available in Ada (or in the @file{GNAT.*} hierarchy in the GNAT
distribution, GtkAda does not include a binding to it, except for a few
required packages. These are the @file{Glib.*} packages in the GtkAda
distribution.

@code{Gdk} is the platform-dependant part of gtk+. Its implementation is
completly different on win32 systems and X11 systems, although the
interface is of course the same. It provides a set of functions to draw
lines, rectangles and pixmaps on the screen, manipulate
colors, etc@dots{} It has a complete equivalent in GtkAda, through the
@file{Gdk.*} packages.

@code{Gtk} is the top level library. It is platform independant, and
does all its drawing through calls to Gdk. This is where the high-level
widgets are defined. It also includes support for callbacks. Its
equivalent in the GtkAda libraries is the @file{Gtk.*} packages. It is
made of a fully object-oriented hierarchy of widgets (see @ref{Widgets
Hierarchy}).

Since your application only calls GtkAda, it is fully portable, and can
be recompile as-is on other platforms.

@example
+---------------------------------------------+
|             Your Application                |
+---------------------------------------------+
|                 GtkAda                      |
|               +-----------------------------+
|               |            GTK              |
|       +-------+-----------------------------+
|       |           GDK                       |
+-------+--------------+--+-------------------+
|          GLIB        |  | X-Window / Win32  |
+----------------------+  +-------------------+
@end example

Although the packages have been evolving a lot since the first versions
of GtkAda, the specs are stabilizing now. We will try as much as possible
to provide backward compatibility whenever possible.

Since GtkAda is based on gtk+, we have tried to stay as close as possible
from it, while using high-level features of the Ada95 language. It is
thus relatively easy to convert from C to Ada, and the gtk+ documentation
is completly reusable (and should be reused !)

We have tried to adopt a consistent naming scheme for Ada identifiers:
@itemize @bullet

@item The widget names are the same as in C, except that an underscore
sign (_) is used to separate words, e.g
@smallexample
Gtk_Button   Gtk_Color_Selection_Dialog
@end smallexample

@item Because of a clash between Ada keywords and widget names, there
are two exceptions to the above general rule:
@smallexample
Gtk.GEntry.Gtk_Entry   Gtk.GRange.Gtk_Range
@end smallexample

@item The function names are the same as in  C, ignoring the leading
@code{gtk_} and the widget name, e.g
@smallexample
gtk_misc_set_padding        @result{}  Gtk.Misc.Set_Padding
gtk_toggle_button_set_state @result{}  Gtk.Toggle_Button.Set_State
@end smallexample

@item Most enum types have been grouped in the @file{gtk-enums.ads} file

@item Some features have been implemented as generic packages. These
are the timeout functions (see Gtk.Main.Timeout), the idle functions
(see Gtk.Main.Idle), and the data that can be attached to any object
(see Gtk.Object.User_Data). Type safety is ensured through this
generic packages.

@item Callbacks were the most difficult thing to interface with. These
are extremely powerful and versatile, since the callbacks can have any
number of arguments, can return values, or not,etc@dots{} These are once
again implemented as generic packages, that require more explanation
(@pxref{Signal handling}).

@end itemize

@cartouche
@b{WARNING:} all the generic functions allocate some memory for internal
structures, and call internal functions. This memory is freed by gtk
itself, by calling some Ada functions. Therefore the generic packages
have to be instanciated at library level, not inside a subprogram, so
that the functions are still defined when gtk needs to free the memory.
@end cartouche


@c ----------------------------------------------------------------------
@node Widgets Hierarchy
@section Widgets Hierarchy
@c ----------------------------------------------------------------------

@noindent
All widgets in @code{GtkAda} are implemented as tagged types. They all have
a common ancestor, called @code{Gtk.Object.Gtk_Object}. All visual objects
have a common ancestor called @code{Gtk.Widget.Gtk_Widget}.

The following table described the list of objects, and their inheritance
tree. As usual with tagged types, all the primitive subprograms defined
for a type are also known for all of its children. This is a very
powerful way to create new widgets, as will be explained in
@ref{Creating and Binding new widgets}.

Although gtk+ was written in C, its design is object-oriented, and thus
GtkAda has the same structure. The following rules have been applied to
convert from C names to Ada names: a widget @code{Gtk_XXX} is defined in
the Ada package @code{Gtk.XXX}, in the file @file{gtk-xxx.ads}. This
follows the GNAT convention for file names.  For instance, the
@code{Gtk_Text} widget is defined in the package @code{Gtk.Text}, in the
file @file{gtk-text.ads}.

Note also that most of the documentation for GtkAda is found in the spec
files themselves.

It is important to be familiar with this hierarchy. It is then easier to
know how to build and organize your windows. Most widgets are demonstrated
in the @file{testgtk/} directory in the GtkAda distribution.

@need 15
@smallexample
Gtk_Object
  \__ Gtk_Data
        \__ Gtk_Tooltips
        \__ Gtk_Adjustment
  \__ Gtk_Widget  @i{(Visual widgets)}
        \__ Gtk_Calendar
        \__ Gtk_Container  @i{(Widgets that have children)}
        |     \__ Gtk_Bin  @i{(Widgets that have a single child)}
        |     |     \__ Gtk_Alignment
        |     |     \__ Gtk_Event_Box
        |     |     \__ Gtk_Frame
        |     |     |     \__ Gtk_Aspect_Frame
        |     |     \__ Gtk_Handle_Box
        |     |     \__ Gtk_Invisible
        |     |     \__ Gtk_Item
        |     |     |     \__ Gtk_List_Item
        |     |     |     \__ Gtk_Menu_Item
        |     |     |     |     \__ Gtk_Check_Menu_Item
        |     |     |     |     |     \__ Gtk_Radio_Menu_Item
        |     |     |     |     \__ Gtk_Tearoff_Menu_Item
        |     |     |     \__ Gtk_Tree_Item
        |     |     \__ Gtk_Viewport
        |     |     \__ Gtk_Window  @i{(Have an independent window)}
        |     |     |     \__ Gtk_Color_Selection_Dialog
        |     |     |     \__ Gtk_Dialog
        |     |     |     |     \__ Gtk_Input_Dialog
        |     |     |     \__ Gtk_File_Selection
        |     |     |     \__ Gtk_Font_Selection_Dialog
        |     |     |     \__ Gtk_Plug
        |     \__ Gtk_Box  @i{(Widgets that have one or more children)}
        |     |     \__ Gtk_Button_Box
        |     |     |     \__ Gtk_Vbutton_Box
        |     |     |     \__ Gtk_Hbutton_Box
        |     |     \__ Gtk_Color_Selection
        |     |     \__ Gtk_Combo
        |     |     \__ Gtk_Gamma_Curve
        |     |     \__ Gtk_Status_Bar
        |     \__ Gtk_Button @i{(Widgets that you can click)}
        |     |     \__ Gtk_Option_Menu
        |     |     \__ Gtk_Toggle_Button
        |     |          \__ Gtk_Check_Button
        |     |                 \__ Gtk_Radio_Button
        |     \__ Gtk_Clist
        |     |     \__ Gtk_Ctree
        |     \__ Gtk_Fixed
        |     \__ Gtk_Layout
        |     \__ Gtk_List
        |     \__ Gtk_Menu_Shell
        |     |     \__ Gtk_Menu
        |     |     \__ Gtk_Menu_Bar
        |     \__ Gtk_Notebook
        |     |     \__ Gtk_Font_Selection
        |     \__ Gtk_Packer
        |     \__ Gtk_Paned
        |     \__ Gtk_Scrolled_Window
        |     \__ Gtk_Socket
        |     \__ Gtk_Toolbar
        |     \__ Gtk_Table
        |     \__ Gtk_Tree
        \__ Gtk_Drawing_Area
        |     \__ Gtk_Curve
        \__ Gtk_Editable
        |     \__ Gtk_Entry
        |     |     \__ Gtk_Spin_Button
        |     \__ Gtk_Text
        \__ Gtk_Misc
        |     \__ Gtk_Arrow
        |     \__ Gtk_Image
        |     \__ Gtk_Label
        |     |     \__ Gtk_Accel_Label
        |     |     \__ Gtk_Tips_Query
        |     \__ Gtk_Pixmap
        \__ Gtk_Preview
        \__ Gtk_Progress
        |     \__ Gtk_Progress_Bar
        \__ Gtk_Range
        |     \__ Gtk_Scale
        |     \__ Gtk_Scrollbar
        \__ Gtk_Ruler
        \__ Gtk_Separator
@end smallexample

@c ----------------------------------------------------------------------
@node Hierarchical composition of a window
@chapter Hierarchical composition of a window
@c ----------------------------------------------------------------------

@noindent
Interfaces in GtkAda are build through layers, as in Motif.
For instance, a typical dialog is basically a Gtk_Window, that in turns
contains a Gtk_Box, itself divided into two boxes and a Gtk_Separator,
and so on.

@c @iftex
@c @image{boxes, 15cm}
@c @end iftex

Altough this may seem more complicated than setting absolute positions
for children, this is the simplest way to automatically handle the
resizing of windows. Each container that makes a layer knows how it
should behave when it is resized, and how it should move its children.
Thus almost everything is handled automatically, and you don't have
anything to do to support resizing.

If you really insist on moving the children at a specific position, look
at the @code{Gtk_Fixed} widget and its demo in @file{testgtk/}. But you
really should not use this container, since you then have to do
everything by hand.

All the containers are demonstrated in @file{testgtk/}, in the GtkAda
distribution. This should help you understand all the parameters
associated with the containers. It is very important to master these
containers, since this ease the building of interfaces a lot if you
use the appropriate one.

If you look at the widget hierarchy (@pxref{Widgets Hierarchy}),
you can see that a Gtk_Window inherits from Gtk_Bin, and thus can have
only one child. In most cases, the child of a Gtk_Window will thus
be a Gtk_Box, which can have any number of children.

Some widgets in GtkAda itself are build with this strategy, from the
very basic @code{Gtk_Button} to the more advanced
@code{Gtk_File_Selection}.


@smallexample
A Gtk_Button contains a Gtk_Label by default, that displays the text in
the button (like "OK" or "Cancel").

However, it is easy to put a pixmap in a button instead. When you
create the button, do not specify any label. Thus, no child will be
added, and you can give your own. See @file{testgtk/create_pixmap.adb}
for an example on how to do that.
@end smallexample


@c ----------------------------------------------------------------------
@node Signal handling
@chapter Signal handling
@c ----------------------------------------------------------------------

@noindent
A signal is @samp{emited} by a widget when an action is performed by the
user on this widget. If the widget has one or more procedures attached
to this signal, they are then executed.
Such procedure will be called @code{callback} in this document.

To associate a callback to a widget, you have to connect this callback to
the specific widget, specifying which signal will be handled. This is
done with the @code{Connect} function.

Depending on their type, the widgets can emit zero (e.g @code{Gtk_Label}),
one or several different signals.

A signal is identified by a string, e.g
@itemize @bullet
@item "clicked"
@item "destroy"
@item "delete_event"
@item "configure_event"
@item "expose_event"
@end itemize

For a specific widget, you can connect several callbacks on the same signal.
They will be executed in the order in which they have been connected.

One single callback can be connected several times on the same widget and even
on different widgets.

The choice made by GtkAda to use generics may look complicated but is
actually simple to use and more important, ensures type checking.

For example, you can connect to a @code{Gtk_Button} an action to
execute each time the button is clicked (signal @code{"clicked"}).
Here is how to do it:
@example
@c @group
@c @cartouche
@b{declare}
   Button : Gtk.Button.Gtk_Button;
   Cb_Id  : Glib.Guint;

@b{begin}
   Gtk.Button.Gtk_New (Button => Button, Label => "Load");
   Cb_Id := Callbacks.Button_Callback.Connect (
      Obj  => Button,                     --  the emitting widget
      Name => "clicked",                  --  the generated signal
      Func => Callbacks.Load'Access);     --  the signal handler
@b{end};
@c @end cartouche
@c @end group
@end example

The package @code{Button_Callback} is an instanciation of the
package @code{Gtk.Signal.Void_Callback}
with the type @code{Gtk.Button.Gtk_Button}.

This package defines an access type to a procedure
@code{Button_Callback.Callback} and the corresponding connect function
@code{Button_Callback.Connect}.

The callbacks provided to this function have to respect the
@code{Button_Callback.Callback} type. Below is an example of how to declare
this package.

@example
@c @group
@c @cartouche
@b{with} Gtk.Signal;
@b{with} Gtk.Button;

@b{package} Callbacks @b{is}
   --  Define callbacks that apply on the widget that detected the
   --  corresponding signal.
   --  These callbacks have only one parameter: the widget itself

   @b{package} Button_Callback @b{is} @b{new} Gtk.Signal.Void_Callback
     (Widget_Type => Gtk.Button.Gtk_Button_Record);

   --  Which is equivalent to:
   --     package Button_Callback is
   --
   --        type Callback is access procedure
   --           (Widget : access Gtk.Button.Gtk_Button_Record);
   --        --  Definition of the Callback type
   --
   --        function Connect
   --          (Obj    : access Gtk.Button.Gtk_Button_Record'Class;
   --           Name   : in String;
   --           Func   : in Callback;
   --           After  : in Boolean := False)
   --           return Guint;
   --         --  Connect a callback to a button
   --
   --     end Button_Callback;

   @b{procedure} Load (Widget : @b{access} Gtk.Button.Gtk_Button_Record);
   --  The callback procedure

@b{end} Callbacks;
@c @end cartouche
@c @end group
@end example

@code{Callbacks.Load} is a procedure that can be used to handle a signal
since its profile conforms with @code{Button_Callback.Callback}.

Note that @code{Callbacks} must be declared at the library level
to ensure its lifetime and the presence of its variables during the execution
of the application. This is needed so that GtkAda can take care of freeing
memory.

Although GtkAda tries to check whether you gave enough arguments to your
callback handlers, it is of course easier if you know what gtk+ expects!
The easiest way to find out is to look at the C header files. Each
widget is described in its own C file, and has two C structures
associated with it. One of them is the "class" structure, and contains a
serie of pointers to functions. Each of these functions has the same
name as the signal name, and the arguments are the one that are expected
in the handlers.

For instance, consider the following extract from gtkbutton.h:
@example
@b{struct} _GtkButtonClass
@{
  GtkBinClass        parent_class;
  
  @b{void} (* pressed)  (GtkButton *button);
  @b{void} (* released) (GtkButton *button);
  @b{void} (* clicked)  (GtkButton *button);
  @b{void} (* enter)    (GtkButton *button);
  @b{void} (* leave)    (GtkButton *button);
@};
@end example

This means that the Gtk_Button widget redefines five new signals, called
respectively @code{"pressed"}, @code{"release"}, ...
Each of them expects a handler looking like:

@example
   procedure Pressed_Handler (Button : access Gtk_Button_Record;
                              Data   : ...);
@end example

The type of Data is given by one of the generic parameters to the
packages in Gtk.Signal.

For more information on how signals work, we recommand having a look at
the book [1].


@node Start an application with GtkAda
@chapter Start an application with GtkAda

You need to perform some initializations to start a GtkAda application:
@example
@c @group
@c @cartouche
--  predefined units of the library
@b{with} Gtk.Rc;
@b{with} Gtk.Main;
@b{with} Gtk.Enums;
@b{with} Gtk.Window;
...
--  My units
@b{with} Callbacks;
...
@b{procedure} Application is
   @b{procedure} Create_Window @b{is} ...

@b{begin}
   --  Set the locale specific datas (e.g time and date format)
   Gtk.Main.Set_Locale;

   --  Initializes GtkAda
   Gtk.Main.Init;

   --  Load the resources
   Gtk.Rc.Parse ("application.rc");

   --  Create the main window
   Create_Window;

   --  Signal handling loop
   Gtk.Main.Main;
@b{end} Application;
@c @end cartouche
@c @end group
@end example

the @code{Create_Window} procedure looks like

@example
@c @group
@c @cartouche
   @b{procedure} Create_Window @b{is}
      Main_Window : Gtk.Window.Gtk_Window;
      ...
   @b{begin}
      Gtk.Window.Gtk_New
        (Window   => Main_Window,
         The_Type => Gtk.Enums.Window_Toplevel);

      --  From Gtk.Widget:
      Gtk.Window.Set_Title (Window => Main_Window, Title  => "Editor");

      --  Construct the window and connect various callbacks

      ...
      Gtk.Window.Show_All (Main_Window);
   @b{end} Create_Window;
@c @end cartouche
@c @end group
@end example

@node General GTK documentation
@chapter General GTK documentation

This section describes briefly how to use the GTK toolset. This is largely
inspired from the GTK+ documentation. It is recommended that you read this
documentation for all general GTK topics.

The GTK toolkit is based on two lower level layers: GDK and Glib.
It is sometimes needed to call these layers directly. @xref{Description of the GDK hierarchy} for a brief description of these packages.

Each widget is declared in a separate package.  The file, package and
type names can be automatically retrieved from one another. For example,
the type @code{Gtk_Text} is defined in the package @code{Gtk.Text} which
is defined in the file @code{gtk-text.ads}.

You may want to look at the sources themselves to find informations on a
specific widget.

@menu
* Package Gtk.Main - high level routines::
* Package Gtk.Handlers - connecting callbacks::
* Package Gtk.Tooltips::
* Package Gtk.Adjustment::
* Package Gtk.Widget::
* Package Gtk.Label::
* Package Gtk.Scrollbar::
* Package Gtk.Drawing_Area::
* Package Gtk.Text::
* Package Gtk.Container::
* Package Gtk.Table::
* Package Gtk.Scrolled_Window::
* Package Gtk.Notebook::
* Package Gtk.Box::
* Package Gtk.Button::
* Package Gtk.Toggle_Button::
* Package Gtk.Check_Button::
* Package Gtk.Event_Box::
* Package Gtk.Window::
* Package Gtk.File_Selection::
* Package Gtk.Enums::
@end menu

@node Package Gtk.Main - high level routines
@section Package Gtk.Main - high level routines

These procedures are described in the order in which they should be called:

@itemize @bullet
@item
@code{Set_Locale} must be called first. It sets the various datas specific to
your location, e.g time, date, decimal formats.
@example
procedure Set_Locale;
@end example

@item
@code{Init} initializes the Gtk @var{engine}. Among other things, it
parses the arguments provided on the command line.
@example
procedure Init;
@end example

@item
The signal handling loop: call it once the interface has been set-up.
@example
procedure Main;
@end example

@item
To interrupt the signal handling loop. Usually called in a callback to stop
the application.
@example
procedure Main_Quit;
@end example
@end itemize

@c ----------------------------------------------------------------------
@node Package Gtk.Handlers - connecting callbacks
@section Package Gtk.Handlers - connecting callbacks
@c ----------------------------------------------------------------------

@noindent
This section describes three of the generic packages provided by
@code{Gtk.Signal}.
You can connect as many callback per signal and widgets as needed.
For a given widget and signal, the various callbacks will be executed
in the order in which they have been connected.

On the other hand, a same callback routine can be connected to several
widgets and signals.
The @code{Connect} function returns an integer (@code{Glib.Guint}) that
identifies the connection, allowing you to destroy it later by giving
this identifier and the appropriate widget.
It is also possible to destroy all the connections to a widget.

The first package (@code{Void_Callback}) provides a way to create callbacks
that have no specific parameter other than the emitting widget:
@example
@c @group
@c @cartouche
@b{generic}
   @b{type} Base_Type @b{is} new Gtk.Object.Gtk_Object_Record @b{with} @b{private};

@b{package} Void_Callback @b{is}

   @b{type} Callback @b{is} @b{access} @b{procedure} (Widget : @b{access} Base_Type);

   @b{function} Connect
     (Obj    : @b{access} Base_Type'Class;
      Name   : @b{in} String;
      Func   : @b{in} Callback;
      After  : @b{in} Boolean := False)
      @b{return} Guint;
@b{end} Void_Callback;
@c @end cartouche
@c @end group
@end example

The callback procedure that can be connected with the @code{Connect} function
must follow the profile defined by the @code{Callback} type.
The object parameter will be the widget that emitted the signal.
For the @code{Connect} function, the parameters are:

@itemize @bullet
@item [Obj] The widget associated with the signal,
@item [Name] The signal name (@code{"clicked", "destroy", "delete_event"}, @dots{}),
@item [Func] A pointer to the callback routine,
@item [After] Indicates whether the callback should be executed before or after
 the widget's automatic class behavior.
@end itemize

The second package (@code{Callback}) whose callbacks accept an additional
data dynamically allocated during the call to @code{Connect} and whose
initial value is set by the @code{Func_Data} parameter

@example
@c @group
@c @cartouche
@b{generic}
   @b{type} Base_Type @b{is new} Gtk.Object.Gtk_Object_Record @b{with private};

   @b{type} Data_Type (<>) @b{is private};
   --  The type of the data for the callback
   --  This type need not be an access type (as opposed as what
   --  happens in C). A new access is created by the connect function.

@b{package} Callback @b{is}

   @b{type} Callback @b{is access procedure}
     (Widget : @b{access} Base_Type;
      Data   : @b{in} Data_Type);
   --  Callback function for Signal_Connect below

   @b{function} Connect
     (Obj       : @b{access} Base_Type'@b{Class};
      Name      : @b{in} String;
      Func      : @b{in} Callback;
      Func_Data : @b{in} Data_Type;
      After     : @b{in} Boolean := False)
      @b{return} Guint;
@b{end} Callback;
@c @end cartouche
@c @end group
@end example

The last package @code{Object_Callback}
provides callbacks that can be connected to any kind of widget.
(the @code{Obj} parameter can be any kind of object),
but the callback parameter, as for previous packages will still have to
be the same as the one specified during the instanciation.

At run time, the callback will get the widget parameter
@code{Slot_Object} that has been given to @code{Connect}.

This is for example useful when you need to handle a button click
depending on the window that contains the button instead of the button itself.

@example
@c @group
@c @cartouche
@b{generic}
   @b{type} Base_Type @b{is new} Gtk.Object.Gtk_Object_Record @b{with private};

@b{package} Object_Callback @b{is}
   @b{type} Callback @b{is access procedure} (Object : @b{access} Base_Type);

   @b{function} Connect
     (Obj         : @b{access} Gtk.Object.Gtk_Object_Record'@b{Class};
      Name        : @b{in} String;
      Func        : @b{in} Callback;
      Slot_Object : @b{access} Base_Type'@b{Class};
      After       : @b{in} Boolean := False)
      @b{return} Guint;
@b{end} Object_Callback;
@c @end cartouche
@c @end group
@end example

Here a sample code extracted from a text editor that corresponds to the
text loading operation.
The @code{Callbacks.Load} procedure is a callback executed when the user
clicks on the ``Load'' button. This callback will create the file selection
window (@code{Gtk_File_Selection}) and make it modal to force the user to
select a file before continuing to work.
When the user clicks on the ``Ok'' button of the file selection window,
the @code{Callbacks.Ok} procedure is called with the parameter selection
window.

@smallexample
@b{with} Gtk.Button;
@b{package} Callbacks @b{is}

   @b{procedure} Load (Widget : @b{in out} Gtk.Button.Gtk_Button);
   --  Callback for the ``Load'' button of the text editor

@b{end} Callbacks;

@b{with} Gtk.Signal, Gtk.Window, Gtk.Main;
@b{with} Gtk.Widget, Gtk.File_Selection, Glib;
@b{with} Editor;

@b{package body} Callbacks @b{is}

   @b{package} Files_Cb @b{is new} Gtk.Signal.Object_Callback
     (Gtk.File_Selection.Gtk_File_Selection);

   --  A callback of type File_Cb.Callback corresponding to the
   --  Cancel button of the file selection window.

   @b{procedure} Cancel
     (Files : @b{access} Gtk.File_Selection.Gtk_File_Selection_Record) @b{is}
   @b{begin}
      --  Hide the file selection window

      Gtk.File_Selection.Hide (Files);

      --  This window is no longer modal

      Gtk.Main.Grab_Remove (Files);
   @b{end} Cancel;

   -- A callback of type File_Cb.Callback corresponding to the ``OK''
   -- button of the file selection window.

   @b{procedure} Ok
     (Files : @b{access} Gtk.File_Selection.Gtk_File_Selection_Record) @b{is}
   @b{begin}
      Editor.Load (Gtk.File_Selection.Get_Filename (Files));
      Gtk.File_Selection.Hide (Files);
      Gtk.Main.Grab_Remove (Files);
   @b{end} Ok;

   -- Internal procedure to initialize a Gtk_File_Selection

   @b{procedure} Initialize_File_Selection
     (Files : @b{access} Gtk.File_Selection.Gtk_File_Selection_Record;
      Label : String;
      OK_CB : Files_Cb.Callback)
   @b{is}
      Cb_Id : Glib.Guint;
   @b{begin}
      Gtk.File_Selection.Gtk_New (Files, Label);

      --  Hide the create/remove buttons

      Gtk.File_Selection.Hide_Fileop_Buttons (Files);
      Cb_Id := Files_Cb.Connect (
         Obj         => Gtk.File_Selection.Get_Ok_Button (Files),
         --  The signal applies to the OK button

         Name        => "clicked", -- Event to detect
         Func        => OK_CB,     -- Callback procedure
         Slot_Object => Files);    -- Parameter given to the callback

      Cb_Id := Files_Cb.Connect (
         Obj         => Gtk.File_Selection.Get_Cancel_Button (Files),
         Name        => "clicked",
         Func        => Cancel'access,
         Slot_Object => Files);
   @b{end} Initialize_File_Selection;

   -- The file selection window

   Input_File_Sel : Gtk.File_Selection.Gtk_File_Selection;
   Input_File_Sel_Existe : Boolean := False;

   -- The ``Load'' callback body

   @b{procedure} Load (Widget : @b{access} Gtk.Button.Gtk_Button_Record) @b{is}
   @b{begin}
      @b{if not} Input_File_Sel_Existe @b{then}
         Initialize_File_Selection
           (Input_File_Sel, "File to load ?", OK'Access);
         Input_File_Sel_Existe := True;
      @b{end if};

      Gtk.Main.Grab_Add (Input_File_Sel);

      --  Show the file selection window

      Gtk.File_Selection.Show (Input_File_Sel);
   @b{end} Load;

@b{end} Callbacks;
@c @end cartouche
@c @end group
@end smallexample

Two procedures to destroy a specific or any connection.

@example
@c @group
@c @cartouche
@b{procedure} Disconnect
  (Object     : @b{access} Gtk.Object.Gtk_Object_Record'@b{Class};
   Handler_Id : @b{in} Guint);

@b{procedure} Handlers_Destroy
  (Obj : @b{access} Object.Gtk_Object_Record'@b{Class});
@c @end cartouche
@c @end group
@end example

@c ----------------------------------------------------------------------
@node Package Gtk.Tooltips
@section Package Gtk.Tooltips
@c ----------------------------------------------------------------------

@example
@c @group
@c @cartouche
@b{type} Gtk_Tooltips_Record @b{is new} Gtk.Data.Gtk_Data_Record @b{with private};
@b{type} Gtk_Tooltips @b{is access all} Gtk_Tooltips_Record'@b{Class};
@c @end cartouche
@c @end group
@end example

The message hint that pops up in a little window when the mouse stay
on a widget long enough without moving.

@node Package Gtk.Adjustment
@section Package Gtk.Adjustment
@example
@c @group
@c @cartouche
@b{type} Gtk_Adjustment_Record @b{is new} Data.Gtk_Data_Record @b{with private};
@b{type} Gtk_Adjustment @b{is access all} Gtk_Adjustment_Record'@b{Class};
@c @end cartouche
@c @end group
@end example

These objects allow you to create a link between a scrollbar and a
scrollable widget (text, scrolled_window).

@node Package Gtk.Widget
@section Package Gtk.Widget
@example
@c @group
@c @cartouche
@b{type} Gtk_Widget_Record @b{is new} Object.Gtk_Object_Record @b{with null record};
@b{type} Gtk_Widget @b{is access all} Gtk_Widget_Record'@b{Class};
@c @end cartouche
@c @end group
@end example

Root of the widget tree. Here are a few useful primitives that are inherited
by all the widgets.

@itemize @bullet
@item Destroy the widget
@example
@c @group
@c @cartouche
@b{procedure} Destroy (Widget : @b{access} Gtk_Widget_Record);
@c @end cartouche
@c @end group
@end example

@item The Widget can be referenced in a resource file under a specified name

@example
@c @group
@c @cartouche
@b{procedure} Set_Name
  (Widget : @b{access} Gtk_Widget_Record; Name : in String);
@c @end cartouche
@c @end group
@end example

@item The @code{Widget} is displayed

@example
@c @group
@c @cartouche
@b{procedure} Show (Widget : @b{access} Gtk_Widget_Record);
@c @end cartouche
@c @end group
@end example

@item The @code{Widget} and its child widgets are displayed

@example
@c @group
@c @cartouche
@b{procedure} Show_All (Widget : @b{access} Gtk_Widget_Record);
@c @end cartouche
@c @end group
@end example

@item Hide the @code{Widget}.

@example
@c @group
@c @cartouche
@b{procedure} Hide (Widget : @b{access} Gtk_Widget_Record);
@c @end cartouche
@c @end group
@end example

@item To manipulate the color tables (see, e.g @code{Gdk.Color.White})

@example
@c @group
@c @cartouche
@b{function} Get_Colormap (Widget : @b{access} Gtk_Widget_Record)
  @b{return} Gdk_Colormap;

@b{function} Get_Default_Colormap @b{return} Gdk_Colormap;

@b{procedure} Set_Default_Colormap
  (Widget : @b{access} Gtk_Widget_Record; Cmap : Gdk_Colormap);
@c @end cartouche
@c @end group
@end example

@item To (de)associate a Gdk_Window to a widget:
@example
@c @group
@c @cartouche
@b{procedure} Realize (Widget : @b{access} Gtk_Widget_Record);
@b{procedure} Unrealize (Widget : @b{access} Gtk_Widget_Record);
@b{function}  Realized_Is_Set (Widget : @b{access} Gtk_Widget_Record'@b{Class})
  @b{return} Boolean;
@c @end cartouche
@c @end group
@end example

You need to use @code{Realize} when for example you want to insert text in a
@code{Gtk_Text} before calling @code{Show}.

@item To make a widget (un)sensitive so that it won't generate any signal:
@example
@c @group
@c @cartouche
@b{procedure} Set_Sensitive
  (Widget    : @b{access} Gtk_Widget_Record;
   Sensitive : @b{in} Boolean := True);
@c @end cartouche
@c @end group
@end example
@code{Set_Sensitive} can be used to temporarily disable a button or a
container. When it is not sensitive, its visual aspect changes.

@item To know whether a widget has no parent (usually a main window):
@example
@c @group
@c @cartouche
@b{function} Toplevel_Is_Set (Widget : @b{access} Gtk_Widget_Record'@b{Class})
  @b{return} Boolean;
@c @end cartouche
@c @end group
@end example

@item To get the parent widget:
@example
@c @group
@c @cartouche
@b{function} Get_Parent (Widget : @b{access} Gtk_Widget_Record)
  @b{return} Gtk_Widget;
@c @end cartouche
@c @end group
@end example

@item To get the low level window (@code{Gdk_Window}) associated with a widget:
@example
@c @group
@c @cartouche
@b{function} Get_Window (Widget : @b{access} Gtk_Widget_Record)
  @b{return} Gdk.Window.Gdk_Window;
@c @end cartouche
@c @end group
@end example

@end itemize

@node Package Gtk.Label
@section Package Gtk.Label
@example
@c @group
@c @cartouche
@b{type} Gtk_Label_Record @b{is new} Misc.Gtk_Misc_Record @b{with private};
@b{type} Gtk_Label @b{is access} all Gtk_Label_Record'@b{Class};
@c @end cartouche
@c @end group
@end example

To display and then modify a simple string.
A @code{Gtk_Label} can emit no signal (see @code{Event_Box} if you want to
connect a signal)

Create a new label
@example
@c @group
@c @cartouche
@b{procedure} Gtk_New (Label : @b{out} Gtk_Label; Str : @b{in} String);
@c @end cartouche
@c @end group
@end example

Change the label string
@example
@c @group
@c @cartouche
@b{procedure} Set_Text (Label : @b{access} Gtk_Label_Record; Str : @b{in} String);
@c @end cartouche
@c @end group
@end example

@node Package Gtk.Scrollbar
@section Package Gtk.Scrollbar
@example
@c @group
@c @cartouche
@b{type} Gtk_Scrollbar_Record @b{is new} Gtk.GRange.Gtk_Range_Record @b{with private};
@b{type} Gtk_Scrollbar @b{is access all} Gtk_Scrollbar_Record'@b{Class};
@c @end cartouche
@c @end group
@end example

Horizontal or vertical scrollbars that can be associated with the
@code{Widget} you want to scroll using
@code{Adjustment} (see, eg @code{Gtk.Text.Get_Vadj}).

@example
@c @group
@c @cartouche
@b{procedure} Gtk_New_Hscrollbar
  (Widget     : @b{out} Gtk_Scrollbar;
   Adjustment : @b{in} Gtk.Adjustment.Gtk_Adjustment);

@b{procedure} Gtk_New_Vscrollbar
  (Widget     : @b{out} Gtk_Scrollbar;
   Adjustment : @b{in} Gtk.Adjustment.Gtk_Adjustment);
@c @end cartouche
@c @end group
@end example

@node Package Gtk.Drawing_Area
@section Package Gtk.Drawing_Area
@example
@c @group
@c @cartouche
@b{type} Gtk_Drawing_Area_Record @b{is new} Gtk.Widget.Gtk_Widget_Record
  @b{with private};
@b{type} Gtk_Drawing_Area @b{is access all} Gtk_Drawing_Area_Record'@b{Class};

@b{procedure} Gtk_New (Widget : @b{out} Gtk_Drawing_Area);
@b{procedure} Size
  (Darea  : @b{access} Gtk_Drawing_Area_Record;
   Width  : @b{in} Glib.Gint;
   Height : @b{in} Glib.Gint);
@c @end cartouche
@c @end group
@end example

You can get the @code{Gdk_Window} associated with a widget to draw in it
using the GDK primitives of @code{Gdk_Drawable} which is a @code{subtype}
of @code{Gdk_Window}, see the GDK section.

This window exists only when the widget is actually realized, e.g after the
call to @code{Realize} or @code{Show} of the @code{Gtk_Drawing_Area}.

It is possible to draw in the initialization procedure after the procedure
@code{Show} or when the @code{Gtk.Main.Main} loop is running,
on the @code{"configure_event"} signal.

A @code{Gtk_Drawing_Area} is a very low level object,
in particular when it is hidden by another window and then exposed, it
is not redrawn automatically. It is up to the application to handle the
expose event, by connecting a callback on the
@code{"expose_event"} signal.

@node Package Gtk.Text
@section Package Gtk.Text
To manipulate text.
@example
@c @group
@c @cartouche
@b{type} Gtk_Text_Record @b{is new}
  Gtk.Editable.Gtk_Editable_Record @b{with private};
@b{type} Gtk_Text @b{is access} all Gtk_Text_Record'@b{Class};
@c @end cartouche
@c @end group
@end example

End of line are marked by a @code{Ascii.LF}.  When the application
modifies the text (using, e.g @code{Insert}), it can first freeze it
(@code{Freeze}) to prevent any change from the user and any automatic
update of the display, then unfreeze it (@code{Thaw}) to allow the user
to interact again.

@example
@c @group
@c @cartouche
@b{procedure} Gtk_New
  (Widget : @b{out} Gtk_Text;
   Hadj   : @b{access} Gtk.Adjustment.Gtk_Adjustment_Record'@b{Class}
     := Gtk.Adjustment.Null_Adjustment;
   Vadj   : @b{access} Gtk.Adjustment.Gtk_Adjustment_Record'@b{Class}
     := Gtk.Adjustment.Null_Adjustment);

@b{procedure} Freeze (Text : @b{access} Gtk_Text_Record);

@b{procedure} Thaw (Text : @b{access} Gtk_Text_Record);

@b{function} Get_Hadj (Widget : @b{access} Gtk_Text_Record)
  @b{return} Gtk.Adjustment.Gtk_Adjustment;

@b{function} Get_Vadj (Widget : @b{access} Gtk_Text_Record)
  @b{return} Gtk.Adjustment.Gtk_Adjustment;

@b{function} Get_Length (Text : @b{in} Gtk_Text) @b{return} Guint;

@b{procedure} Insert
  (Text   : @b{access} Gtk_Text_Record;
   Font   : @b{in} Gdk.Font.Gdk_Font'@b{Class};
   Fore   : @b{in} Gdk.Color.Gdk_Color;
   Back   : @b{in} Gdk.Color.Gdk_Color;
   Chars  : @b{in} String;
   Length : @b{in} Gint);
@c @end cartouche
@c @end group
@end example

By default, the text shown is not modifiable by the user. To change this,
use the @code{Set_Editable} procedure:
@example
@c @group
@c @cartouche
@b{procedure} Set_Editable
  (Text : @b{access} Gtk_Text_Record; Editable : @b{in} Boolean);
@c @end cartouche
@c @end group
@end example

To avoid cutting words at the end of a line:
@example
@c @group
@c @cartouche
@b{procedure} Set_Word_Wrap
  (Text      : @b{access} Gtk_Text_Record;
   Word_Wrap : @b{in} Boolean);
@c @end cartouche
@c @end group
@end example

Also inherits primitives from @code{Gtk.Editable.Gtk_Editable}:
@itemize @bullet

@item Destroy a text section
@example
@c @group
@c @cartouche
@b{procedure} Delete_Text
  (Editable  : @b{access} Gtk_Editable_Record;
   Start_Pos : @b{in} Gint;
   End_Pos   : @b{in} Gint);   --  e.g Glib.Gint (Get_Length (...))
@c @end cartouche
@c @end group
@end example

@item Get the current postion of the cursor
@example
@b{function} Get_Current_Pos (Widget : access Gtk_Editable_Record)
  return Guint;
@end example
@end itemize

@node Package Gtk.Container
@section Package Gtk.Container
@example
@c @group
@c @cartouche
@b{type} Gtk_Container_Record @b{is new}
  Gtk.Widget.Gtk_Widget_Record @b{with private};
@b{type} Gtk_Container @b{is access all} Gtk_Container_Record'@b{Class};
@c @end cartouche
@c @end group
@end example

General notion that permits to create a hierarchical structure of widgets, such
as @code{Gtk_Box, Gtk_Table, Gtk_EventBox}, @dots{}

To add/remove a widget in a @code{Gtk_Container}:

@example
@c @group
@c @cartouche
@b{procedure} Add
  (Container : @b{access} Gtk_Container_Record;
   Widget    : @b{access} Gtk.Widget.Gtk_Widget_Record'@b{Class});

@b{procedure} Remove
  (Container : @b{access} Gtk_Container_Record;
   Widget    : @b{access} Gtk.Widget.Gtk_Widget_Record'@b{Class});
@c @end cartouche
@c @end group
@end example

The @b{procedure}s @code{Pack_Start} and @code{Pack_End} of @code{Gtk_Box} and
@code{Attach} of @code{Gtk_Table} let you add widgets and specify their
position.

To set the width of the border around the @code{Gtk_Container}:
@example
@c @group
@c @cartouche
@b{procedure} Border_Width
  (Container    : @b{access} Gtk_Container_Record;
   Border_Width : @b{in} Gint);
@c @end cartouche
@c @end group
@end example

@node Package Gtk.Table
@section Package Gtk.Table
@example
@c @group
@c @cartouche
@b{type} Gtk_Table_Record @b{is new} Gtk.Container.Gtk_Container_Record
  @b{with private};
@b{type} Gtk_Table @b{is access all} Gtk_Table_Record'@b{Class};
@c @end cartouche
@c @end group
@end example

To group widgets in a table. The same widget can cover several boxes of the
table. The size of the boxes depends on what they contain.

@example
@c @group
@c @cartouche
@b{procedure} Gtk_New
  (Widget      : @b{out} Gtk_Table;
   Rows        : @b{in} Glib.Gint;
   Columns     : @b{in} Glib.Gint;
   Homogeneous : @b{in} Boolean);
@c @end cartouche
@c @end group
@end example

If @code{Homogeneous} is True, all the boxes will have the same size, determined
by the largest widget and the longest widget.
Otherwise, the width of a column (resp. heigh of a row) will be determined
by the largest widget of the column.

To attach a widget to a table
@example
@c @group
@c @cartouche
@b{procedure} Attach
  (Table         : @b{access} Gtk_Table_Record;
   Child         : @b{access} Gtk.Widget.Gtk_Widget_Record'@b{Class};
   Left_Attach   : @b{in} Gint;
   Right_Attach  : @b{in} Gint;
   Top_Attach    : @b{in} Gint;
   Bottom_Attach : @b{in} Gint;
   Xoptions      : @b{in} Gtk_Attach_Options;
   Yoptions      : @b{in} Gtk_Attach_Options;
   Xpadding      : @b{in} Gint;
   Ypadding      : @b{in} Gint);

@b{procedure} Attach_Defaults
  (Table         : @b{access} Gtk_Table_Record;
   Widget        : @b{access} Gtk.Widget.Gtk_Widget_Record'@b{Class};
   Left_Attach   : @b{in} Gint;
   Right_Attach  : @b{in} Gint;
   Top_Attach    : @b{in} Gint;
   Bottom_Attach : @b{in} Gint);
@c @end cartouche
@c @end group
@end example

Attach the widget @code{Child} to the position indicated by
@code{Left_Attach, Right_Attach, Top_Attach} and
@code{Bottom_Attach}.
These indexes start from 0 to the number of column or rows specified at
table creation. The origin (0, 0) of the frontiers is located in upper left.

@example
@c @group
@c @cartouche
    0          1          2
   0+----------+----------+
    |          |          |
   1+----------+----------+
    |          |          |
   2+----------+----------+
@c @end cartouche
@c @end group
@end example

The values of @code{Xoptions} and @code{Yoptions} can be a logical @var{or} of
several values:
@itemize @bullet
@item [Gtk.Enums.Expand] The table will use all the remaining space in the
 window.
@item [Gtk.Enums.Shrink] If the widget has less space than needed, it will
 shrink instead of disappearing.
@item [Gtk.Enums.Fill] The widget takes the whole space that has been allocated
 for it.
@end itemize

@code{Xpadding} and @code{Ypadding} give the widths in pixels of the
 free space reserved around the widget.

For the @code{Attach_Defaults} procedure, the default values of @code{Xoptions}
and @code{Yoptions} are equals to @code{Expand or Fill} and those of
@code{Xpadding} and @code{Ypadding} are 0.

@node Package Gtk.Scrolled_Window
@section Package Gtk.Scrolled_Window
@example
@c @group
@c @cartouche
@b{type} Gtk_Scrolled_Window_Record @b{is new} Container.Gtk_Container_Record
  @b{with private};
@b{type} Gtk_Scrolled_Window @b{is access all} Gtk_Scrolled_Window_Record'@b{Class};
@c @end cartouche
@c @end group
@end example

To create a scrollable zone in which you can put any kind of widget, like
e.g a table of buttons.
If the window is too small, all the widgets won't be visible, but they will
remain accessible using the scrollbars.
@example
@c @group
@c @cartouche
@b{procedure} Gtk_New
  (Scrolled_Window :    @b{out} Gtk_Scrolled_Window;
   Hadjustment     : @b{access} Adjustment.Gtk_Adjustment_Record'@b{Class}
     := Adjustment.Null_Adjustment;
   Vadjustment     : @b{access} Adjustment.Gtk_Adjustment_Record'@b{Class}
     := Adjustment.Null_Adjustment);
@c @end cartouche
@c @end group
@end example

Create a @code{Gtk_Scrolled_Window} by optionally specifying adjustment rules.

To get the adjustment rules (to attach scrollbars).
@example
@c @group
@c @cartouche
@b{function} Get_Hadjustment
  (Scrolled_Window : @b{access} Gtk_Scrolled_Window_Record)
   @b{return} Adjustment.Gtk_Adjustment;

@b{function} Get_Vadjustment
  (Scrolled_Window : @b{access} Gtk_Scrolled_Window_Record)
   @b{return} Adjustment.Gtk_Adjustment;
@c @end cartouche
@c @end group
@end example

@node Package Gtk.Notebook
@section Package Gtk.Notebook
@example
@c @group
@c @cartouche
@b{type} Gtk_Notebook_Record @b{is new} Gtk.Container.Gtk_Container_Record
  @b{with private};
@b{type} Gtk_Notebook @b{is access all} Gtk_Notebook_Record'@b{Class};
@c @end cartouche
@c @end group
@end example

The NoteBook Widget is a collection of @var{pages} that overlap each other,
each page containing different information.
This widget has become more common lately in GUI programming,
and it is a good way to show blocks of similar information that warrant
separation in their display. 

@node Package Gtk.Box
@section Package Gtk.Box
@example
@c @group
@c @cartouche
@b{type} Gtk_Box_Record @b{is new}
  Gtk.Container.Gtk_Container_Record @b{with private};
@b{type} Gtk_Box @b{is access all} Gtk_Box_Record'@b{Class};
@b{subtype} Gtk_Vbox @b{is} Gtk_Box;
@b{subtype} Gtk_Hbox @b{is} Gtk_Box;
@c @end cartouche
@c @end group
@end example

Horizontal (@code{Gtk_New_Hbox}) and vertical (@code{Gtk_New_Vbox}) boxes
that can contain several widgets.
you can add widgets from

@itemize @bullet
@item the left to the right starting from the beginning (@code{Pack_Start})
@item the right to the left, starting from the end (@code{Pack_End})
@end itemize

@example
@c @group
@c @cartouche
@b{procedure} Gtk_New_Vbox
  (Box         : @b{in} out Gtk_Box;
   Homogeneous : @b{in}  Boolean;
   Spacing     : @b{in}  Gint);
@b{procedure} Initialize_Vbox
  (Box         : @b{access} Gtk_Box_Record'Class;
   Homogeneous : @b{in}  Boolean;
   Spacing     : @b{in}  Gint);

@b{procedure} Gtk_New_Hbox
  (Box         : @b{in} out Gtk_Box;
   Homogeneous : @b{in}  Boolean;
   Spacing     : @b{in}  Gint);
@b{procedure} Initialize_Hbox
  (Box         : @b{access} Gtk_Box_Record'Class;
   Homogeneous : @b{in}  Boolean;
   Spacing     : @b{in}  Gint);

@b{procedure} Pack_Start
  (In_Box  : @b{access} Gtk_Box_Record;
   Child   : @b{access} Gtk.Widget.Gtk_Widget_Record'@b{Class};
   Expand  : @b{in} Boolean := True;
   Fill    : @b{in} Boolean := True;
   Padding : @b{in} Gint    := 0);

@b{procedure} Pack_End
  (In_Box  : @b{access} Gtk_Box_Record;
   Child   : @b{access} Gtk.Widget.Gtk_Widget_Record'@b{Class};
   Expand  : @b{in} Boolean := True;
   Fill    : @b{in} Boolean := True;
   Padding : @b{in} Gint    := 0);
@c @end cartouche
@c @end group
@end example

@xref{Package Gtk.Table}

@node Package Gtk.Button
@section Package Gtk.Button
@example
@c @group
@c @cartouche
@b{type} Gtk_Button_Record @b{is new} Bin.Gtk_Bin_Record @b{with private};
@b{type} Gtk_Button @b{is access all} Gtk_Button_Record'@b{Class};
@c @end cartouche
@c @end group
@end example

A simple button with a label and signals (e.g @code{clicked}).

@node Package Gtk.Toggle_Button
@section Package Gtk.Toggle_Button
@example
@c @group
@c @cartouche
@b{type} Gtk_Toggle_Button_Record @b{is new} Gtk.Button.Gtk_Button_Record
  @b{with private};
@b{type} Gtk_Toggle_Button @b{is access all} Gtk_Toggle_Button_Record'@b{Class};
@c @end cartouche
@c @end group
@end example

Toggle buttons are very similar to normal buttons, except they will always
be in one of two states, alternated by a click. They may be depressed,
and when you click again, they will pop back up.  Click again, and they will
pop back down.

@node Package Gtk.Check_Button
@section Package Gtk.Check_Button
@example
@c @group
@c @cartouche
@b{type} Gtk_Check_Button_Record @b{is new}
  Toggle_Button.Gtk_Toggle_Button_Record @b{with private};
@b{type} Gtk_Check_Button @b{is access all} Gtk_Check_Button_Record'@b{Class};
@c @end cartouche
@c @end group
@end example

Check buttons inherit many properties and @b{function}s from the the toggle
buttons above, but look a little different.
Rather than being buttons with text inside them, they are small squares with
the text to the right of them. These are often seen for toggling
options on and off in applications. 

@node Package Gtk.Event_Box
@section Package Gtk.Event_Box
@example
@c @group
@c @cartouche
@b{type} Gtk_Event_Box_Record @b{is new} Gtk.Bin.Gtk_Bin_Record @b{with private};
@b{type} Gtk_Event_Box @b{is access all} Gtk_Event_Box_Record'@b{Class};
@c @end cartouche
@c @end group
@end example

To associate a callback or clip a widget that is not able to do it, like
labels for example. Note that this container can have only one child.

@example
@c @group
@c @cartouche
@b{procedure} Gtk_New (Widget : @b{out} Gtk_Event_Box);
@c @end cartouche
@c @end group
@end example

This widget is a child of @code{Gtk_Container} and inherits in particular of:

@example
@c @group
@c @cartouche
@b{procedure} Add (Container : @b{access} Gtk_Container_Record;
               Widget    : @b{access} Gtk.Widget.Gtk_Widget_Record'@b{Class});
@c @end cartouche
@c @end group
@end example

@node Package Gtk.Window
@section Package Gtk.Window
@example
@c @group
@c @cartouche
@b{type} Gtk_Window_Record @b{is new} Bin.Gtk_Bin_Record @b{with private};
@b{type} Gtk_Window @b{is access all} Gtk_Window_Record'@b{Class};
@c @end cartouche
@c @end group
@end example

The base window, emits the signals @code{"destroy", "delete_event"}.

@node Package Gtk.File_Selection
@section Package Gtk.File_Selection
@example
@c @group
@c @cartouche
@b{type} Gtk_File_Selection_Record is new Gtk.Window.Gtk_Window_Record
  with private;
@b{type} Gtk_File_Selection is @b{access} all Gtk_File_Selection_Record'@b{Class};
@c @end cartouche
@c @end group
@end example

To select a file in the directories tree. Nothing special to know about
it, just use it!
There are three buttons @code{Ok, Cancel and Help}.
You can modify these buttons (e.g change the labels, connect callbacks, @dots{})
with the various @code{Get_..._Button} @b{function}s.

@example
@c @group
@c @cartouche
@b{procedure} Gtk_New
  (File_Selection : @b{out} Gtk_File_Selection; Title : @b{in} String);
@c @end cartouche
@c @end group
@end example

To associate a callback with the buttons of the file selector:
@example
@c @group
@c @cartouche
@b{function} Get_Ok_Button
  (File_Selection : @b{access} Gtk_File_Selection_Record)
   @b{return} Gtk.Button.Gtk_Button;

@b{function} Get_Cancel_Button
  (File_Selection : @b{access} Gtk_File_Selection_Record)
   @b{return} Gtk.Button.Gtk_Button;
@c @end cartouche
@c @end group
@end example

To consult or set the filename:
@example
@c @group
@c @cartouche
@b{function} Get_Filename
  (File_Selection : @b{access} Gtk_File_Selection_Record)
   @b{return} String;

@b{procedure} Set_Filename
  (File_Selection : @b{access} Gtk_File_Selection_Record;
   Filename : @b{in} String);
@c @end cartouche
@c @end group
@end example

To hide the file manipulation buttons (destruction, @dots{}):

@example
@c @group
@c @cartouche
@b{procedure} Hide_Fileop_Buttons
  (File_Selection : @b{access} Gtk_File_Selection_Record);
@c @end cartouche
@c @end group
@end example

@node Package Gtk.Enums
@section Package Gtk.Enums
This package defines all the enumerated @b{type}s used by the GTK hierarchy.

@node Description of the GDK hierarchy
@chapter Description of the GDK hierarchy
GTK is based on a lower level layer called GDK that contains some simple
drawing and window primitives.

@menu
* Package Gdk.Color::
* Package Gdk.Point::
* Package Gdk.Window::
* Package Gdk.Drawable::
* Package Gdk.GC::
* Package Gdk.Font::
* Draw in a widget::
@end menu

@node Package Gdk.Color
@section Package Gdk.Color
Color types and table of colors:
@example
@c @group
@c @cartouche
@b{type} Gdk_Color @b{is private};
@b{type} Gdk_Colormap @b{is new} Root_Type @b{with private};
@c @end cartouche
@c @end group
@end example

Allows one to get black and white colors by asking the
@code{Gdk_Colormap} of a widget:
@example
@c @group
@c @cartouche
@b{function} White (Colormap : @b{in} Gdk_Colormap) @b{return} Gdk_Color;
@b{function} Black (Colormap : @b{in} Gdk_Colormap) @b{return} Gdk_Color;
Wrong_Color : @b{exception};
@c @end cartouche
@c @end group
@end example

See for example @code{Get_Default_Colormap}.

You can of course create your own colors (provided your screen can
display them), by calling the following functions :

@example
@b{declare}
   Color : Gdk_Color;
   Name  : String := "brown";  --  the name of the color to be created
@b{begin}
   --  First, create a color from its name
   Color := Gdk.Color.Parse (Name);
   Gdk.Color.Alloc (Gtk.Widget.Get_Default_Colormap, Color);

   --  Or create a color from its values
   Gdk.Color.Set_Rgb (Color,
                      Red   => 20000, 
                      Green => 20000,
                      Blue  => 65500);
   Gdk.Color.Alloc (Gtk.Widget.Get_Default_Colormap, Color);
@b{end}; 
@end example

@node Package Gdk.Point
@section Package Gdk.Point
@example
@c @group
@c @cartouche
@b{type} Gdk_Point @b{is private};
@c @end cartouche
@c @end group
@end example

Used to describe polygons.

@example
@c @group
@c @cartouche
@b{type} Gdk_Points_Array @b{is array} (Positive @b{range} <>) @b{of} Gdk_Point;

@b{function} Get_X (Point : @b{in} Gdk_Point) @b{return} Glib.Gint16;
@b{function} Get_Y (Point : @b{in} Gdk_Point) @b{return} Glib.Gint16;
@b{procedure} Set_X (Point : @b{in out} Gdk_Point; X : Glib.Gint16);
@b{procedure} Set_Y (Point : @b{in out} Gdk_Point; Y : Glib.Gint16);
@c @end cartouche
@c @end group
@end example
 
@node Package Gdk.Window
@section Package Gdk.Window
@example
@c @group
@c @cartouche
@b{type} Gdk_Window @b{is new} Root_Type @b{with private};
@c @end cartouche
@c @end group
@end example

To clear a window (e.g before drawing ):
@example
@c @group
@c @cartouche
@b{procedure} Clear (Window : @b{in out} Gdk_Window);
@c @end cartouche
@c @end group
@end example
 
@node Package Gdk.Drawable
@section Package Gdk.Drawable
@example
@c @group
@c @cartouche
@b{subtype} Gdk_Drawable @b{is} Gdk.Window.Gdk_Window;
@c @end cartouche
@c @end group
@end example

@example
@c @group
@c @cartouche
   @b{procedure} Draw_Rectangle (Drawable : @b{in} Gdk_Drawable'@b{Class};
                             Gc       : @b{in} Gdk.GC.Gdk_GC'@b{Class};
                             Filled   : @b{in} Boolean := False;
                             X        : @b{in} Gint;
                             Y        : @b{in} Gint;
                             Width    : @b{in} Gint;
                             Height   : @b{in} Gint);
 
   @b{procedure} Draw_Point (Drawable : @b{in} Gdk_Drawable'@b{Class};
                         Gc       : @b{in} Gdk.GC.Gdk_GC'@b{Class};
                         X        : @b{in} Gint;
                         Y        : @b{in} Gint);
 
   @b{procedure} Draw_Line (Drawable : @b{in} Gdk_Drawable'@b{Class};
 
   @b{procedure} Draw_Line (Drawable : @b{in} Gdk_Drawable'@b{Class};
                        Gc       : @b{in} Gdk.GC.Gdk_GC'@b{Class};
                        X1       : @b{in} Gint;
                        Y1       : @b{in} Gint;
                        X2       : @b{in} Gint;
                        Y2       : @b{in} Gint);
 
   @b{procedure} Draw_Arc (Drawable : @b{in} Gdk_Drawable'@b{Class};
                       Gc       : @b{in} Gdk.GC.Gdk_GC'@b{Class};
                       Filled   : @b{in} Boolean := False;
                       X        : @b{in} Gint;
                       Y        : @b{in} Gint;
                       Width    : @b{in} Gint;
                       Height   : @b{in} Gint;
                       Angle1   : @b{in} Gint;
                       Angle2   : @b{in} Gint);
 
   @b{procedure} Draw_Polygon (Drawable : @b{in} Gdk_Drawable'@b{Class};
                           Gc       : @b{in} Gdk.GC.Gdk_GC'@b{Class};
                           Filled   : @b{in} Boolean;
                           Points   : @b{in} Gdk.Point.Gdk_Points_Array);
   @b{procedure} Draw_Text
     (Drawable    : @b{in} Gdk_Drawable'@b{Class};
      Font        : @b{in} Gdk.Font.Gdk_Font;
      Gc          : @b{in} Gdk.GC.Gdk_GC;
      X           : @b{in} Glib.Gint;
      Y           : @b{in} Glib.Gint;
      Text        : @b{in} String);
@c @end cartouche
@c @end group
@end example

for all the procedures (in particular @code{Draw_Arc}), the parameters are:
@itemize @bullet
 
@item [X, Y] Position of the point or of the upper left corner or the rectangle.
 
@item [Width, Height] Width and height of the rectangle or of the rectangle
containing an ellipse.
 
@item [Angle1]  Starting angle of the arc in 1/64th degrees.
 
@item [Angle2]  Ending angle relative to Angle1 in 1/64th degrees.

@item [Font]  A font, that can be loaded using @code{Gdk.Font.Load}.
              For example:
@example
@c @group
@c @cartouche
   Gdk.Font.Load
     (Font, "-adobe-courier-medium-i-*-*-15-*-*-*-*-*-*-*");
@c @end cartouche
@c @end group
@end example
@end itemize

@node Package Gdk.GC
@section Package Gdk.GC
A @code{Gdk_GC} is a graphic context that must be associated, during its
creation, with a @code{Gdk_Window}, and which is needed for each drawing
primitive of @code{Gdk_Drawable}.
A @code{Gdk_GC} let you, for example, set the colors to use for a drawing.

@example
@c @group
@c @cartouche
   @b{type} Gdk_GC @b{is new} Root_Type @b{with private};
 
   @b{procedure} Gdk_New (GC     :    @b{out} Gdk_GC;
                      Window : @b{in}     Gdk.Window.Gdk_Window'@b{Class});
 
   @b{procedure} Destroy (GC : @b{in out} Gdk_GC);
 
   @b{procedure} Set_Foreground (GC    : @b{in out} Gdk_GC;
                             Color : @b{in}     Gdk.Color.Gdk_Color);
 
   @b{procedure} Set_Background (GC    : @b{in out} Gdk_GC;
                             Color : @b{in}     Gdk.Color.Gdk_Color);
 
   @b{procedure} Set_Font (GC   : @b{in out} Gdk_GC;
                       Font : @b{in}     Gdk.Font.Gdk_Font'@b{Class});
@c @end cartouche
@c @end group
@end example
 
@node Package Gdk.Font
@section Package Gdk.Font
A font describes the graphical aspect of the characters, their size,
kind, @dots{}.

Under @code{X11}, each font has a name of the form:
@example
@c @group
@c @cartouche
"-adobe-courier-medium-i-*-*-15-*-*-*-*-*-*-*"
@c @end cartouche
@c @end group
@end example

The X command @code{xfontsel} lets you select a font and build its associated
name automatically.
 
@example
@c @group
@c @cartouche
   @b{type} Gdk_Font @b{is new} Root_Type @b{with private};
 
   @b{procedure} Load
     (Font      :    @b{out} Gdk_Font;
      Font_Name : @b{in}     String);
 
   @b{procedure} Fontset_Load
     (Font         :   @b{out} Gdk_Font;
      Fontset_Name : @b{in}    String);
 
   @b{function} Id (Font : @b{in} Gdk_Font) @b{return} Gint;
 
   @b{function} "=" (Fonta, Fontb : @b{in} Gdk_Font) @b{return} Boolean;
 
   @b{function} String_Width
     (Font : @b{in} Gdk_Font;
      Str  : @b{in} String) @b{return} Gint;
 
   @b{function} Text_Width
     (Font : @b{in} Gdk_Font;
      Text : @b{in} String) @b{return} Gint;
 
   @b{function} Char_Width
     (Font : @b{in} Gdk_Font;
      Char : @b{in} Character) @b{return} Gint;
 
   @b{function} String_Measure
     (Font : @b{in} Gdk_Font;
      Str  : @b{in} String) @b{return} Gint;
 
   @b{function} Text_Measure
     (Font : @b{in} Gdk_Font;
      Text : @b{in} String) @b{return} Gint;
 
   @b{function} Char_Measure
     (Font : @b{in} Gdk_Font;
      Char : @b{in} Character) @b{return} Gint;
@c @end cartouche
@c @end group
@end example

@code{Width} gives the sum of the characters' widths,
@code{Measure} gives a value similar to @code{Width} except that it takes
into account the attributes of the font (e.g @code{italic}).

@node Draw in a widget
@section Draw in a widget

To select a drawing area, use a @code{Gtk_Drawing_Area} widget.
The drawing procedures apply to the Gdk window
(see @code{Gdk_Window} and @code{Gdk_Drawable}) of the
@code{Gtk_Drawing_Area} widget via a graphic context (see @code{Gtk_Gc}).

Typically the code will look like:

@example
@c @group
@c @cartouche
@b{with} Glib;
@b{with} Gdk.Window;
@b{with} Gdk.Drawable;
@b{with} Gdk.GC;
@b{with} Gdk.Font;

@b{procedure} Draw (Drawing : @b{in} @b{out} Gtk.Drawing_Area.Gtk_Drawing_Area) @b{is}
   Gdkw : Gdk.Window.Gdk_Window;
   GC   : Gdk.GC.Gdk_GC;
   Font : Gdk.Font.Gdk_Font;
   @b{use} @b{type} Glib.Gint;

@b{begin}
   -- Get the Gdk window

   Gdkw := Gtk.Drawing_Area.Get_Window (Drawing) ;

   -- Clear the window

   GDK.Window.Clear (Gdkw) ;

   -- Create a graphic context associated with this window

   Gdk.GC.Gdk_New (GC, Gdkw);

   -- Draw a line in this window

   Gdk.Drawable.Draw_Line
     (Drawable => Gdkw,
      GC => GC,
      X1 =>   0, Y1 =>   0,
      X2 => 100, Y2 => 100);

   -- Draw an arc

   Gdk.Drawable.Draw_Arc
     (Drawable => Gdkw,
      Gc       => gc,
      Filled   => True,
      X        => 100,
      Y        => 100,
      Width    => 200,
      Height   => 100,
      Angle1   => 0 * 64,
      Angle2   => 270 * 64);

   -- Ask for a given font

   Gdk.Font.Load (Font, "-adobe-courier-medium-i-*-*-15-*-*-*-*-*-*-*");
   Gdk.Drawable.Draw_Text
     (Drawable    => Gdkw,
      Font        => Font,
      Gc          => gc,
      X           => 50,
      Y           => 50,
      Text        => "Hello World");
   Gdk.Font.Destroy (Font);
   Gdk.GC.Destroy (GC);
@b{end} Draw;
@c @end cartouche
@c @end group
@end example

@node Description of the Glib hierarchy
@chapter Description of the Glib hierarchy

Glib is the low-level layer and provides various @b{type}s such as
@code{Gint, Guint}, @dots{}.

It also provides access to lists and double-linked lists. Some functions
in GtkAda return lists of Widgets or lists of integer, so it might be
useful to know how to traverse the list.

Here are the functions available (note that the packages in Glib are
generics that you need to instanciate first).

@example
@b{function} First (List : @b{in out} Glist);
@b{function} Next (List : @b{in} Glist) @b{return} Glist;
@b{function} Last (List : @b{in} Glist) @b{return} Glist;
@end example

These three functions allow you to traverse the list: get the first
element, then loop while the current element is different from Last.
For instance, here is how you would get the selection in a
@code{Gtk_List} widget:

@example
@b{declare}
   @b{use type} Widget_List.Glist;
   Selection : Widget_List.Glist := Gtk.List.Get_Selection (Widget);
   Current   : Widget_List.Glist := Widget_List.First (Selection);
   Item      : Gtk_Widget;
@b{begin}
   @b{while} Current /= Widget_List.Last (Selection) @b{loop}
       Item := Widget_List.Get_Data (Current);
       --  use Item however you want
       Current := Widget_List.Next (Current);
   @b{end loop};
@b{end};
@end example   


@c Glib.XML

@node Resource files
@chapter Resource files

Resource files let you parametrize the aspect of the widgets of a GtkAda
application without having to recompile it.

A resource file needs to be loaded (@code{Gtk.Rc.Parse}) @var{before} setting
the corresponding window.

In this file, it is possible to specify the visual characteristics of the
widgets (colors, fonts, @dots{}).
Under X, the @code{xfontsel} command allows you to easily select a font.
The FontSelection widget is also a simple way to select fonts.

Here is an example of a resource file:
@example
# application.rc
#
# resource file for "Application"

# Buttons style
style "button"
@{
# BackGround Colors
#                  Red  Green  Blue
  bg[PRELIGHT] = @{ 0.0,  0.75, 0.0 @} # Green when the mouse is on
                                     # the button
  bg[ACTIVE]   = @{ 0.75, 0.0,  0.0 @} # Red on click
# ForeGround Colors
#                  Red  Green  Blue
  fg[PRELIGHT] = @{ 1.0,  1.0,  1.0 @} # White when the mouse is on
                                     # the button
  fg[ACTIVE]   = @{ 1.0,  1.0,  1.0 @} # White on click
@}

# All the buttons will have the style "button"
widget_class "*GtkButton*" style "button"

# Text style
style "text"
@{
  font = "-adobe-courier-medium-r-normal-*-15-*-*-*-*-*-*-*"
  text[NORMAL] = @{ 0.0, 0.0, 0.0 @} # black
  fg[NORMAL]   = @{ 0.0, 0.0, 0.0 @} # black
  base[NORMAL] = @{ 1.0, 1.0, 1.0 @} # white : background color
@}

# All Gtk_Text will have the "text" style
widget_class "*GtkText" style "text"
@end example


@node Creating and Binding new widgets
@chapter Creating and Binding new widgets

New since version 0.6, GtkAda has now a basic support for creating new
widgets directly in Ada (although you can't create your own signals
yet, we are still working on it).

Since GtkAda has an object oriented conception (well, at least you can
program by extension), it is easy, if you want to associate your
own data with a widget, to create your own type. See the
examples below. You should also have a look at the @code{testgtk/}
 directory.

We provide a Perl script to help you create a binding to a C widget
(this is the script we have used ourselves).  This will not fully
automate the process, although it should really speed things up. You
will probably need less than 15 min to create a new binding once you
will get used to the way GtkAda works. Note that your C file should have
the same format as the one used by Gtk+ itself, as far as indentation
and style are concerned.

Here are the steps to create a new binding:

@itemize @bullet
@item Give the @code{generate.pl} script the C header file

@item The perl script should ask you for every field in the C structure if
you want to create a function to make it accessible from Ada. Answer
@var{y} or @var{n} (the default value is @var{n}, just press ENTER).

@example
@c @group
@c @cartouche
$ perl generate.pl ../include/gtk/gtkbutton.h > temporary
  Create a function for the field child (of type GtkWidget*) [n]?
  Create a function for the field in_button (of type guint) [n]?
  Create a function for the field button_down (of type guint) [n]?
@c @end cartouche
@c @end group
@end example

@item If you answered yes to at least one of the above questions, create a
new C file, and move the C part of the @var{temporary} file created by
generate.pl to this C file.

@item Do a gnatchop on the @var{temporary} file created by generate.pl, after
deleting the C part from above.

@example
@c @group
@c @cartouche
$ gnatchop temporary
@c @end cartouche
@c @end group
@end example

This should create two Ada files (specification and body)

@item Edit these two files if needed (to change some parameters
  from Gint to Boolean for instance). It can be a little bit tricky
  when one of your functions returns a GList* or a GSList*. Please have
  a look at gtk-combo.ads for examples how to do this.
@end itemize

@node Threads
@chapter Threads

The 1.2 series of Gtk+ are now thread safe. The
usage of tasks inside programs using this toolkit should not cause any
problem provided that you protect your Gtk calls with Gdk.Threads.Enter/
Leave and that your windowing system (e.g X) is thread-safe.

We recommend however that you read the section related to this topic in the
GTK+ documentation.

@node How to report bugs
@chapter How to report bugs

This library is still considered beta code, and it is thus likely that
you will  find bugs.  We  have tried to  test it as much  as possible,
essentially  by  converting  the  testgtk.c  file  found  in  the  gtk
distribution.   We   have  been  able   to  rewrite  nearly   all  the
tests. Please have a look at the  testgtk, which can give you a lot of
examples of how to use this toolkit.

For more general questions about gtk itself, please ask your questions
to the  gtk  mailing list. The  authors of  this toolkit  are far from
being specialists of gtk, as it was one of our first projects with gtk.

There are two kinds of problems you can encounter:
@itemize @bullet
@item If the gtk library itself was compiled with warnings turned on, you
may get some  warnings messages,  mainly because of types problems.
These warnings should not appear, as we have tried to be as type safe
as possible  in this package. To know exactly where the problem is,
compile your program with debug information, run gdb, and set a
breakpoint on the function @code{g_log}. Then run your program as usual,
using the @code{run} command. Then send us the result of the @code{where}
command. Here is a summary:

@example
@c @group
@c @cartouche
$ gnatmake -f -g <your_program_name> `gtkada-config`
$ gdb <your_program_name>
(gdb) break main
(gdb) run
(gdb) break g_log
(gdb) continue
....
(gdb) where
@c @end cartouche
@c @end group
@end example

@item In  some  (hopefully) rare cases,   you can even get a  segmentation
fault within gtk.  That means there is definitly something wrong either
in your program or in the toolkit.  Please check your program carefully,
and if you think this is a problem in GtkAda itself, send us an e-mail.
@end itemize

To report errors, if you are a supported user of GNAT, send a mail to
@uref{mailto:report@@gnat.com}, otherwise send a mail to the authors
(@uref{mailto:gtkada@@ada.eu.org}) explaining exactly what your
are  doing,  what  is  the  expected  result  and  what  you  actually
get. Please include the required sources to reproduce the problem, in
a  format usable  by @code{gnatchop}  (basically, insert  all  the required
sources at  the end of  the mail). Please  try to provide a  subset of
your sources as small as possible.

Of course, we will  welcome any patch   you can provide, so  that this
toolkit is as useful as possible.

@node Object-oriented features
@chapter Object-oriented features

GtkAda has been designed from the beginning to provide a full Object
oriented layer over gtk+. This means that features such as type
extension, dynamic dispatching, ... are made available through the
standard Ada language.

This section will describe both how things work and how you can extend
existing widgets or even create your own.

@menu
* General description of the tagged types::
* Converting your applications to the new tagged type scheme::
* Using tagged types to extend Gtk widgets::
* Creating new widgets in Ada::
@end menu

@node General description of the tagged types
@section General description of the tagged types

@subsection Why should I use object-oriented programing ?
Every widget in GtkAda is a tagged type, which has a number of
primitive subprograms, that are known by all its children.

This means that, as opposed to what you see in C code, you don't have
(well most of the time you don't) to explictly cast types, and even
when you have to, Ada always makes sure that the conversion is valid.

Thus your programs are much safer, and most errors are found at compile
time, as is usually the case with Ada.

For instance, if you create a table, put some widgets in it, and then,
later in your program, try to access these widgets, then you do not need
to know beforehand what their type is, when and by whom they were
created, ... You simply ask for the children of the table, and you get
in return a tagged type that contains all the information you need. You
can even use dynamic dispatching without ever having to cast to a known
type.

This makes GtkAda a very powerful tool for designing graphical interfaces.

If you think one of the standard widgets is nice, but would be even
better if it was drawing itself in a slighlty different way, of if it could
contain some other data that you need in your application, there is a very
simple way to do it: just create a new type that extends the
current one (see the section @xref{Using tagged types to extend Gtk widgets}
below.

Maybe you want to create your own brand new widget, that knows how to draw
itself, how to react to events, ... and you want to be able to reuse it
anytime you need ? Once again, using the standard Ada features, you can
simply create a new tagged type and teach it how to interact with the user.
See the section @xref{Creating new widgets in Ada} below.

@subsection Type conversions from C widgets to Ada widgets

There are basically three kinds of widgets that you can use with GtkAda:
@itemize @bullet
@item @i{Ada widgets}:
These are widgets that are written directly in Ada, using the object
oriented features of GtkAda
@item @i{Standard widgets}:
These are the widgets that are part of the standard gtk+ and GtkAda
distributions. This include all the basic widgets you need to build
advanced interfaces.
@item @i{imported C widgets}
These are widgets that were created in C, and for which you (or someone else)
created an Ada binding. This is most probably the kind of widgets you will
have if you want to use third party widgets.
@end itemize

GtkAda will always be able to find and/or create a valid tagged type in
the first case, no matter if you explicitly created the widget or if it
was created automatically by gtk+. For instance, if you created a widget
in Ada, put it in a table, and later on extracted it from the table, then you
will still have the same widget.

The second case above is twofold: if the widget was explictly created by you,
or at least by GtkAda, then it will always be and remain associated with a
correct Ada type.

However, if the widget was created implicitly (for instance every time you
create a Gtk_Button, a Gtk_Label is also created for the text displayed), then
GtkAda is not, by default, able to create the corresponding Ada type. Instead,
it will create a Gtk_Widget, and you will thus have to do some Uncheck_Cast
to convert it back to the type you want and expect.

In the third case (imported C widgets), GtkAda is not, by default, able to
create the corresponding Ada type.

The solution we suggest to solve these two issues is to 'with' the
@b{Gtk.Type_Conversion} unit. In that case, every standard widget, no matter who
created them, will always be correctly converted to an appropriate Ada type.
So, basically, if you put the following in your main unit:

@example
@b{with} Gtk.Type_Conversion;

@b{begin}
   Gtk.Main.Init;
   Gtk.Type_Conversion.Init;
   ...
@b{end}
@end example

then you can safely get the children of any widget (table, boxes, ...) and be
sure you have the right Ada type. You won't need to explictly convert your
widget to something else.

However, 'with'ing this unit means that your application will depend on every
package of GtkAda, which is a little bit heavier, and explains why this is not
the default. We do recommend to use it if it is not extremely important for you
whether your application depends on all the packages of GtkAda.

The case of imported C widgets is a little bit trickier. Since GtkAda does not
know anything about them when it is build, it can't convert magically the C
widgets to Ada widgets. This is your job to teach GtkAda how to do the
conversion.

We thus provide a 'hook' function, that you need to modify. This function is
defined in the package @b{Gtk.Type_Conversion}. It is a function that takes
a string with the name of the C widget (ex/ "GtkButton"), and expects a newly
allocated pointer in return. If you don't know this type either, simply
return @b{null}.

@node Converting your applications to the new tagged type scheme
@section Converting your applications to the new tagged type scheme

GtkAda 0.6 is an almost complete rewrite of GtkAda. Whereas widgets
used to be record types, they now are implemented as access types.
This change has two benefits:
@itemize @bullet
@item It is now clearer, when you pass an object to a function or as
  an argument to a callback, that you are still working with the
  widget you created before.
@item Most important, it is now possible to extend existing types directly
  in Ada (see the section below).
@end itemize

Your existing code might have to be modified a little though (sorry
about that, this is for the better!).
@itemize @bullet
@item Although @code{Gtk_New} now creates access types (and allocate memory for
  them), you do not have to free this memory yourself. This is
  automatically taken care of by gtk itself, which is one of the
  strong points of the new scheme.
@item The only part of your code that is actually modified are the
  callbacks. The changes should be easy to handle (We did it
  for testgtk itself :-).
  When instanciating a callback generic, the first parameter should be
  modified like this:

@example
@c @group
@c @cartouche
package My_Cb is new Signal.Void_Callback (Gtk_Widget_Record);
                                                     ^^^^^^^
@c @end cartouche
@c @end group
@end example

  Then you have to modify the spec of the subprogram iself:

@example
@c @group
@c @cartouche
@b{procedure} My_Func (Button : @b{access} Gtk.Button.Gtk_Button_Record;
                   Data   : @b{in} Gint);
@c @end cartouche
@c @end group
@end example

  Note that the first parameter is an anonymous access to a record
  type, and the second parameter is an "in" parameter.
@end itemize

The last things that have changed in this new version of the toolkit are some
of the names of the parameters in the subprograms. This
is part of a major cleanup we are doing so that things can be more
homogeneous within GtkAda.

@node Using tagged types to extend Gtk widgets
@section Using tagged types to extend Gtk widgets

Since version 0.6 of this toolkit, it is possible to associate your
own data with existing widgets, simply by creating new types. This
section will show you a simple example, but you should rather read the
source code in testgtk/ where we used this feature instead of using
@code{user_data} as in the C version.

@example
@c @group
@c @cartouche
@b{type} My_Button_Record @b{is new} Gtk_Button_Record @b{with record}
    --  whatever data you want to associate with your button
@b{end record};
@b{type} My_Button @b{is access all} My_Button_Record'@b{Class};
@c @end cartouche
@c @end group
@end example

With the above statements, your new type is defined. Every function
available for @code{Gtk_Button} is also available for @code{My_Button}.
Of course, as with every tagged type in Ada, you can create your own
primitive functions, with the following prototype:

@example
@c @group
@c @cartouche
@b{procedure} My_Primitive_Func (Myb : @b{access} My_Button_Record);
@c @end cartouche
@c @end group
@end example

To instanciate an object of type @code{My_Button} in your application, do
the following:

@example
@c @group
@c @cartouche
@b{declare}
   Myb : My_Button;
@b{begin}
   Myb := @b{new} My_Button_Record;
   Initialize (Myb);   --  from Gtk.Button
@b{end};
@c @end cartouche
@c @end group
@end example

The first line creates the Ada type, whereas the @code{Initialize} call
actually creates the C widget and associates it with the Ada type.

@node Creating new widgets in Ada
@section Creating new widgets in Ada

With GtkAda, you can now create widgets directly in Ada. These new
widgets can be used directly, as if they were part of gtk itself.

Creating new widgets is a way to create reuseable components. You can
apply to them the same functions as would for any other widget, such as
Show, Hide, ...

This section will present how to create two types of widgets, composite
widgets and widgets created from scratch. Two examples are provided with
GtkAda, in the directories @file{examples/composite_widget} and
@file{examples/base_widget}. Please also refer to the gtk+ tutorial,
that describes the basic mechanisms that you need to know to create
a widget (even if the Ada code is really different from the C code...)

@menu
* Creating composite widgets::
* Creating widgets from scratch::
@end menu

@node Creating composite widgets
@subsection Creating composite widgets

A composite widget is a widget that does not do much by itself. This is
more a collection of subwidgets, grouped into a more general entity.
For instance, among the standard widgets, @code{Gtk_File_Selection}
and @code{Gtk_Font_Selection} belong to this category.

The good news is that there is nothing special to know. Just create a
new tagged type, that extends one of the standard widgets (or even another
of your own widgets), provide a @code{Gtk_New} function that allocates
memory for this widget, and call the @code{Initialize} function that does
the actual creation of the widget and the subwidgets.
There is only one thing to do: @code{Initialize} should the call the
parent class's @code{Initialize} function, to create the underlying C
widget.

The example directory @file{examples/composite_widget} reimplements the
@code{Gtk_Dialog} widget as was written in C by the creators of gtk+.

@node Creating widgets from scratch
@subsection Creating widgets from scratch

First, an important note: please do not read this if this is your first
time using GtkAda, or if you don't really understand the signal mechanism.
Creating a nice and working widget really takes a lot of messing with the
low level signals.

Creating a widget from scratch is what you want to do if your widget should
be drawn in a special way, should create and emit new signals, ...
The example we give in @file{examples/base_widget} is a small target, on
which the user can click, and that sends one of two signals "bullseye" or
"missed" depending on where the user has clicked.

Once again, the only two functions that you must create are @code{Gtk_New}
and @code{Initialize}.
This time, @code{Initialize} has to do two things:

@example
   Parent_Package.Initialize (Widget);

   --  The above line calls the Initialize function from the parent.
   --  This creates the underlying C widget, which we are going to
   --  modify with the following call:

   Gtk.Object.Initialize_Class_Record
       (Widget, Signals, Class_Record);
   --  This initializes the "class record" for the widget and
   --  creates the signals.
@end example

In the above example, the new part is the second call. It takes three
arguments:
@itemize @bullet
@item Widget
This is the widget that you want to initialize
@item Signals
This is an array of string access that contains the name of the signals
you want to create. For instance, you could create Signals with
@example
   Signals      : Gtk.Object.Signal_Array (0 .. 1) :=
     (0 => @b{new} String'("bullseye" & Ascii.NUL),
      1 => @b{new} String'("missed" & Ascii.NUL));
@end example
This will create two signals, named "bullseye" and "missed", whose callbacks
do not take any argument (apart from the usual user's data). This is the only
restriction from GtkAda compared to gtk+: all the callbacks are created
automatically, but you can not specify additionnal parameters that are sent
automatically by GtkAda.

@item Class_Record
Every widget in C is associated with two records. The first one, which exists
only once per widget type, is the "class record". It contains the list of
signals that are known by this widget type, the list of default callbacks for
the signals, ...; the second record is an "instance record", which contains
each instance specific data.
In GtkAda, the "instance record" is simply your tagged type and its fields.
The call to @code{Initialize_Class_Record} is provided to initialize the
"class record". As we said, there should be only one such record per widget
type. This parameter "Class_Record" will point to this records, once it is
created, and will be reused for every instanciation of the widget.

@end itemize

Then of course @code{Initialize} should set up some signal handlers for
the functions you want to redefine.
Three signals are especially useful:

@itemize @bullet

@item "size_request"

This callback is passed one parameter, as in :
@example
   @b{procedure} Size_Request
      (Widget      : @b{access} My_Widget_Record;
       Requisition : @b{in out} Gtk.Widget.Gtk_Requisition);
@end example
This function should modify Requisition to specify what would be the
ideal size of the widget. This might not be the exact size that will be
set, since some containers might decide to enlarge or to shrink it.

@item "size_allocate"

This callback is called every time the widget is moved in its parent
window, or is resize. It is passed one paramater, as in :
@example
   @b{procedure} Size_Allocate
      (Widget     : @b{access} My_Widget_Record;
       Allocation : @b{in out} Gtk.Widget.Gtk_Allocation)
@end example
This function should take the responsability to move the widget, using
for instance @code{Gdk.Window.Move_Resize}.

@item "expose_event"

This callback is called every time the widget needs to be redrawn.
It is passed one parameter, the area that is necessary to be redrawn (to
speed things up, you don't need to redraw the whole widget, just this
area).

@end itemize


@node Support for Glade the Gtk GUI builder
@chapter Support for Glade, the Gtk GUI builder

GtkAda now comes with a support for the GUI builder Glade (this is not
the glade released with Gnat for distributed systems).
Not all widgets are supported yet, but we eventually hope to have all
of them. If you really need one, it is easy to add the two required
functions @dots{} (and to send us patches...)

We actually provide two versions: a dynamic one and a static one. In
both cases, you first need to get and install glade (http://glade.pn.org).
Then start a new project (or edit an old one). It is easy enough to use,
simply select the widget you want to add to your interface, and click!

Note that we only recommend to use version 0.5.5 of Glade, as some previous
versions are not compatible. Using this version, you can directly create Ada
files from Glade by selecting Ada95 as the language in the project options.
By doing so, you will tell Glade to call gate internally when using the
"Write Source Code" functionality.

@itemize @bullet
@item DGATE (Dynamic Glade Ada Translator and Evaluator) is the dynamic
version of our support. This is an Ada program that takes the XML file
in argument. It also provides default callbacks for your application, we
recommand using it while you are trying to design your interface.

@item GATE is the static version of our support. This tool
takes the XML file in argument and generates a set of Ada files that,
when compiled, will recreate the interface you just designed with Glade.
@end itemize

The most important files created by Gate are called
@code{<widget_name>-callbacks.adb}.
They contain stubs for all the callbacks related to a top level widget
you declared in Glade.

Note that you can easily go back to Glade any time, modify your interface,
and have GATE re-generate a set of files. All your modifications will be
kept in the new files. For that, GATE creates a directory @code{.gate/} in the
current directory. Please do not delete it if you want GATE to be able to
keep your changes from one version to the next.

Also note that to be able to keep track of your modifications, gate
relies on @code{patch} and @code{diff} being available on your system.
If you don't have a working set of @code{diff/patch}, @code{configure}
will simply replace them by null operations.

GATE and DGATE currently don't support all widgets and properties available
under Glade. To help you identify which widgets are not supported, GATE will
generate a comment in the @code{create_<widget>.adb} file that looks like:

@smallexample
   --  WARNING: Unsupported widget GtkImage (image1)
@end smallexample

Which means that while generating the file, GATE detected an unsupported
widget (in this case GtkImage) whose name is image1.
If you get such warnings, your file may or may not compile properly, but
you won't get the complete widget hierarchy at run time.

Feel free to send us (see "How to report bugs") the XML file that
causes this problem. We don't guarantee a rapid fix for each particular
problem, but receiving real examples of missing functionnalities will
certainly help implementing them faster.

Similarly, DGATE generates a warning to the standard output when encountering
an unsupported widget:

@smallexample
GtkAda-WARNING **: Unsupported widget GtkImage (image1)
@end smallexample

Here is the list of widgets that are currently not supported by GATE/DGATE.

@itemize @bullet
@item Gtk_Accel_Label
@item Gtk_Color_Selection
@item Gtk_Ctree
@item Gtk_Curve
@item Gtk_Fixed
@item Gtk_Font_Selection
@item Gtk_Font_Selection_Dialog
@item Gtk_Gamma_Curve
@item Gtk_Handle_Box
@item Gtk_Image
@item Gtk_Invisible
@item Gtk_Layout
@item Gtk_Packer
@item Gtk_Pixmap
@item Gtk_Plug
@item Gtk_Preview_Info
@item Gtk_Radio_Menu_Item
@item Gtk_Socket
@item Gtk_Tearoff_Menu_Item
@item Gtk_Tips_Query
@item Gtk_Tooltips
@end itemize

@c --------------------------------------------------------------
@node Bibliography
@chapter Bibliography

We recommand the following documents. Most of them were written with C
in mind, but should be easily adapted most of the time after you read
the rest of this document.

@itemize @bullet
@item [1] "Gtk+/Gome Application Development" -- Havoc Pennington
This book, by one of the main authors of the the GNOME environment,
describes in detail some of the inner mechanism of gtk+, including the
signal handling, and a complete description of all the widgets and all
the events found in @code{Gdk.Event}.

It is worth noting that this book has been published under the Open
Publication License. You can get an electronic copy of it at
@url{http://www.opencontent.org/}.
@end itemize

@printindex cp
@contents

@bye
