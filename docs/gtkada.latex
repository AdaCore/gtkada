\documentstyle[a4wide,epsf,boxedminipage,eepic]{article}
\parindent .0cm
\title{GtkAda User's Guide}
\date{\today}
\author{Emmanuel Briot, joel Brobecker, Arnaud Charlet, Philippe Durif}
\begin{document}
\maketitle

\section{Introduction}
The home page for GtkAda is\\

     \verb;http://ada.eu.org/gtkada/;\\

The home page for gtk is\\

     \verb;http://www.gtk.org;\\

This home page will always contain the latest news for this binding.\\

This is GtkAda version 0.6-beta. This package is an Ada95 binding for
the Gimp Toolkit, which means this is a set of packages to allow you
to easily create some graphical interfaces under X11, using Ada95 as a
programming language.\\

This is a beta version. If you have been using previous versions of
GtkAda, please note that this version (0.6) is an almost complete
rewrite of GtkAda, and so you might encounter problems that you did
not have before (see below for a list of changes). Nevertheless,
testgtk is still fully working, so this version should be pretty stable.\\

Almost every widget from gtk 1.2 has been implemented, and the test
program found in the gtk release has been reimplemented in Ada (have a
look at the testgtk/ directory).\\

These functions were tested on the following systems:
\begin{itemize}
\item Linux version 2.0.35
\item SunOS 5.5.1
\item Dec Unix 4.0b
\end{itemize}
using the following compilers:
\begin{itemize}
\item Gnat 3.11p
\item Gnat 3.11b2
\end{itemize}

and the following versions of gtk:
\begin{itemize}
\item Gtk 1.1.16
\item Gtk 1.2.0
\end{itemize}

Although versions up to 0.2.1 were compatible with Gtk-1.0, this one is
Gtk-1.1 (or Gtk-1.2) specific. If you are looking for a binding to
Gtk-1.0, please consider downloading GtkAda 0.2.1.\\

If you manage to use it on other systems (which should probably be
straightforward - just recompile GtkAda), please let us know so that
we can add to the above list.\\

This documentation is largely inspired from the Gtk+ documentation written
by Ian Main.\\

GtkAda uses extensively the object oriented programming capabilities,
access to subprograms, exceptions and genericity (in particular to define
and handle callbacks) provided by Ada 95.
As a result, this library provides a secure, easy to use and extensible
toolset.\\

A complete example of the use of GtkAda is provided at the end of this document.

\section{Getting started with GtkAda}

\subsection{How to build and install GtkAda}

To build and install GtkAda, simply do the following steps:
\begin{itemize}
\item ./configure
\item make
\item make install
\end{itemize}

You then have to make sure that the dynamic library \verb:libgtkada:
is known by your system, by typically running \verb:ldconfig:,
editing \verb:/etc/ld.conf: or add the path that contains libgtkada
(by default \verb:/usr/local/lib:, or \verb:$prefix/lib: if you specified
the \verb:--prefix: option during the configure step) to your 
\verb:LD_LIBRARY_PATH:

\subsection{How to compile an application with GtkAda}

A script, \verb:gtkada-config:, is provided to simplify the build of an
application:
\begin{quote}\begin{verbatim}
gnatmake <main-file> `gtkada-config`
\end{verbatim}\end{quote}

\section{Contents}

The almost full set of widget that comes with Gtk 1.2 have been bound,
and you should be able to use all of them from your Ada program.\\

Although it is not quite complete yet, the Gdk binding (the low level
layer) will probably not evolve soon, unless some people (why not
you?) send us patches, or at least ask for specific functions.\\

It is important to know that only a subset of the gdk binding has
actually been tested, and therefore errors are still likely to appear.\\

The specs have been evolving a lot since version 0.5, but things
should really stabilize now. We hope that the changes in the next
versions will not break your code, but we certainly can not guaranty
anything.\\

We have tried to adopt a consistent naming scheme for Ada identifiers:
\begin{itemize}
\item The widget names are the same as in C, excepted that an underscore
sign (\_) is used to separate words, e.g\\

\begin{quote}\begin{verbatim}
Gtk_Button   Gtk_Color_Selection_Dialog
\end{verbatim}\end{quote}

\item The function names are the  same as in  C, ignoring the leading
\verb:gtk_: and the widget name, e.g

\begin{quote}\begin{verbatim}
gtk_misc_set_padding        ->  Set_Padding
gtk_toggle_button_set_state ->  Set_State
\end{verbatim}\end{quote}

\item All the enum types have been grouped in the gtk-enums.ads file

\item The only tricky part is for the callbacks, the timeout functions,
the idle functions, and the data that can be attached to every
Object. In these cases, we have used generic package to provide type
safety. Please have a look at the files in testgtk to see how these
functions are implemented.
\end{itemize}

{\bf WARNING:} all the generic functions allocate some memory for
internal structures. This  memory is freed  by gtk itself,  by calling
some Ada functions. Therefore the generic packages  have to be instanciated
at library level, not  inside a subprogram,  so that the functions are
still defined when gtk needs to free the memory.

\section{Hierarchical composition of a window}

Typically, a window is created in which one can insert a box containing
either:
\begin{itemize}
\item Atomic components such as Button, Text, Label, \ldots
\item Other boxes recursively.
\end{itemize}

Each component is a widget (Window Gadget), even the windows.

\section{Signal handling}

A signal is {\em generated} by a widget when an action is performed by the
user on this widget. If the widget has one or more procedures associated
to this signal, they are then executed.
Such procedure will be called {\em callback} in the following.\\

To associate a callback to a widget, you have to connect this callback to
the specific widget specifying which signal will be handled. This is
done with the \verb:Connect: function.\\

Depending on their type, the widgets can emit zero (e.g \verb:Gtk_Label:),
one or several different signals.\\

A signal is identified by a string, e.g
\verb:"clicked":, \verb:"destroy":, \verb:"delete_event":.\\

For a specific widget, you can connect several callbacks on the same signal.
They will be executed in the order in which they have been connected.\\

One single callback can be connected several times on the same widget and even
on different widgets.\\

The choice made by GtkAda to use generics may look complicated but is
actually simple to use and more important, ensures type checking.\\

For example, you can connect on a \verb:Gtk_Button: an action to
execute each time the button is clicked (signal \verb:"clicked":).
Here is how to do it:
\begin{quote}\begin{verbatim}
   Button : Gtk.Button.Gtk_Button;
   Cb_Id  : Glib.Guint;

begin
   Gtk.Button.Gtk_New (Widget => Button, Label => "Load");
   Cb_Id := Callbacks.Button_Callback.Connect (
      Obj  => Button,                     --  the emitting widget
      Name => "clicked",                  --  the generated signal
      Func => Callbacks.Load'Access);     --  the signal handler
\end{verbatim}\end{quote}

The package \verb:Button_Callback: is an instanciation of the
package \verb:Gtk.Signal.Void_Callback:
with the type \verb:Gtk.Button.Gtk_Button:.\\

This package defines an access type to a procedure
\verb:Button_Callback.Callback: and the corresponding connect function:
\verb:Button_Callback.Connect:.\\

The callbacks provided to this function have to respect the
\verb:Button_Callback.Callback: type.\\

\begin{quote}\begin{verbatim}
with Gtk.Signal;
with Gtk.Button;

package Callbacks is
   --  Define callbacks that apply on the widget that detected the
   --  corresponding signal.
   --  These callbacks have only one parameter: the widget itself

   package Button_Callback is new Gtk.Signal.Void_Callback
     (Widget_Type => Gtk.Button.Gtk_Button_Record);

   --  Which is equivalent to:
   --     package Button_Callback is
   --
   --        type Callback is access procedure
   --           (Widget : access Gtk.Button.Gtk_Button_Record);
   --        --  Definition of the Callback type
   --
   --        function Connect
   --          (Obj    : access Gtk.Button.Gtk_Button_Record'Class;
   --           Name   : in String;
   --           Func   : in Callback;
   --           After  : in Boolean := False)
   --           return Guint;
   --         --  Connect a callback to a button
   --
   --     end Button_Callback;

   procedure Load (Widget : access Gtk.Button.Gtk_Button_Record);
   --  The callback procedure

end Callbacks;
\end{verbatim}\end{quote}

\verb:Callbacks.Load: is a procedure that can be used to handle a signal
since its profile conforms with \verb:Button_Callback.Callback:.\\

Note that \verb:Callbacks.Load: must be declared at the library level
to ensure its lifetime and the presence of its variables during the execution
of the application.

\section{Start an application with GtkAda}

You need to perform some initializations to start a GtkAda application:
\begin{quote}\begin{verbatim}
--  predefined units of the library
with Gtk.Rc;
with Gtk.Main;
with Gtk.Enums;
with Gtk.Window;
...
--  My units
with Callbacks;
...
procedure Application is
   procedure Create_Window is ...

begin
   --  Set the locale specific datas (e.g time and date format)
   Gtk.Main.Set_Locale;

   --  Initializes GtkAda
   Gtk.Main.Init;

   --  Load the resources
   Gtk.Rc.Parse ("application.rc");

   --  Create the main window
   Create_Window;

   --  Signal handling loop
   Gtk.Main.Main;
end Application;
\end{verbatim}\end{quote}
the \verb:Create_Window: procedure looks like:
\begin{quote}\begin{verbatim}
   procedure Create_Window is
      Main_Window : Gtk.Window.Gtk_Window;
      ...
   begin
      Gtk.Window.Gtk_New
        (Window   => Main_Window,
         The_Type => Gtk.Enums.Window_Toplevel);

      --  From Gtk.Widget:
      Gtk.Window.Set_Title (Window => Main_Window, Title  => "Editor");

      --  Construct the window and connect various callbacks

      ...
      Gtk.Window.Show_All (Main_Window);
   end Create_Window;
\end{verbatim}\end{quote}

\section{Resource files}

Resource files let you parametrize the aspect of the widgets of a GtkAda
application without having to recompile it.
The file \verb:"application.rc": of the previous example is a resource file.\\

A resource file needs to be loaded (\verb:Gtk.Rc.Parse:) before setting
the corresponding window.\\

In this file, it is possible to specify the visual characteristics of the
widgets (colors, fonts, \ldots).
Under X, the \verb:xfontsel: command allows you to select easily a font.
The FontSelection widget is also a simple way to select fonts.\\

Here is an example of a resource file:
\begin{quote}\begin{verbatim}
# application.rc
#
# resource file for "Application"

# Buttons style
style "button"
{
# BackGround Colors
#                  Red  Green  Blue
  bg[PRELIGHT] = { 0.0,  0.75, 0.0 } # Green when the mouse is on the button
  bg[ACTIVE]   = { 0.75, 0.0,  0.0 } # Red on click
# ForeGround Colors
#                  Red  Green  Blue
  fg[PRELIGHT] = { 1.0,  1.0,  1.0 } # White when the mouse is on the button
  fg[ACTIVE]   = { 1.0,  1.0,  1.0 } # White on click
}

# All the buttons will have the style "button"
widget_class "*GtkButton*" style "button"

# Text style
style "text"
{
  font = "-adobe-courier-medium-r-normal-*-15-*-*-*-*-*-*-*"
  text[NORMAL] = { 0.0, 0.0, 0.0 } # black
  fg[NORMAL]   = { 0.0, 0.0, 0.0 } # black
  base[NORMAL] = { 1.0, 1.0, 1.0 } # white : background color
}

# All Gtk_Text will have the "text" style
widget_class "*GtkText" style "text"
\end{verbatim}\end{quote}

\section{General GTK documentation}

This section describes briefly how to use the GTK toolset. This is largely
inspired from the GTK+ documentation. It is recommended that you read this
documentation for all general GTK topics.

The GTK toolkit is based on two lower level layers: GDK and Glib.
It is sometimes needed to call these layers directly. A brief description
of these packages is provided in sections ???\\

Each widget is declared in a separate package.
The file, package and type names can be automatically retrieved one from each
other. For example, the type \verb:Gtk_Text: is defined in the package
\verb:Gtk.Text: which is defined in the file \verb:gtk-text.ads:.\\

You may want to look at the sources themselves to find informations on a
specific widget.

\subsection{Package Gtk.Main: high level routines}

These procedures are described in the order in which they should be called:

\begin{itemize}
\item
\verb:Set_Locale: must be called first. It sets the various datas specific to
your location, e.g time, date, decimal formats.
\begin{quote}\begin{verbatim}
procedure Set_Locale;
\end{verbatim}\end{quote}

\item
\verb:Init: initializes the Gtk {\em engine}. Among other things, it
parses the arguments provided on the command line.
\begin{quote}\begin{verbatim}
procedure Init;
\end{verbatim}\end{quote}

\item
The signal handling loop: call it once the interface has been set-up.
\begin{quote}\begin{verbatim}
procedure Main;
\end{verbatim}\end{quote}

\item
To interrupt the signal handling loop. Usually called in a callback to stop
the application.
\begin{quote}\begin{verbatim}
procedure Main_Quit;
\end{verbatim}\end{quote}
\end{itemize}

\subsection{Package Gtk.Signal: connecting callbacks}

This section describes three of the generic packages provided by
\verb:Gtk.Signal:.
You can connect as many callback per signal and widgets as needed.
For a given widget and signal, the various callbacks will be executed
in the order in which they have been connected, unless the {\it After}
parameter is {\it True}.\\

On the other hand, a same callback routine can be connected on several
widgets and signals.
The \verb:Connect: function returns an integer (\verb:Glib.Guint:) that
identifies the connection, allowing you to destroy it later by giving
this identifier and the appropriate widget.
It is also possible to destroy all the connections of a widget.\\

This first package (\verb:Void_Callback:) provides a way to create callbacks
that has no specific parameter other than the emitting widget:
\begin{quote}\begin{verbatim}
generic
   type Base_Type is new Gtk.Object.Gtk_Object_Record with private;

package Void_Callback is

   type Callback is access procedure (Widget : access Base_Type);

   function Connect
     (Obj    : access Base_Type'Class;
      Name   : in String;
      Func   : in Callback;
      After  : in Boolean := False)
      return Guint;
end Void_Callback;
\end{verbatim}\end{quote}

The callback procedure that can be connected with the \verb:Connect: function
must follow the profile defined by the \verb:Callback: type.
The object parameter will be the widget that emitted the signal.
For the \verb:Connect: function, the parameters are:

\begin{description}
\item [Obj] The widget associated with the signal,
\item [Name] The signal name (\verb:"clicked":, \verb:"destroy":, \verb:"delete_event":, \ldots),
\item [Func] A pointer to the callback routine,
\item [After] This allows a signal handler to be guaranteed to run after other
signal handlers connected to the same signal on the same object.
\end{description}

This second package (\verb:Callback:) whose callbacks accept an additional
data dynamically allocated during the call to \verb:Connect: and whose
initial value is set by the \verb:Func_Data: parameter:

\begin{quote}\begin{verbatim}
generic
   type Base_Type is new Gtk.Object.Gtk_Object_Record with private;

   type Data_Type (<>) is private;
   --  The type of the data for the callback
   --  This type need not be an access type (as opposed as what
   --  happens in C). A new access is created by the connect function.

package Callback is

   type Callback is access procedure
     (Widget : access Base_Type;
      Data   : in Data_Type);
   --  Callback function for Signal_Connect below
   --  Data is now an 'in' parameter, since you are anyway not
   --  modifying the original data you gave, but a copy of it.

   function Connect
     (Obj       : access Base_Type'Class;
      Name      : in String;
      Func      : in Callback;
      Func_Data : in Data_Type;
      After     : in Boolean := False)
      return Guint;
end Callback;
\end{verbatim}\end{quote}

The last package \verb:Object_Callback:
provides callbacks that can be connected on any kind of widget.
(the \verb:Obj: parameter can be any kind of object),
but the callback parameter, as for previous packages will still have to
be the same as the one specified during the instanciation.

At run time, the callback will get the widget parameter
\verb:Slot_Object: that has been given to \verb:Connect:.\\

This is for example useful when you need to handle a button click
depending on the window that contains the button instead of the button itself.

\begin{quote}\begin{verbatim}
generic
   type Base_Type is new Gtk.Object.Gtk_Object_Record with private;

package Object_Callback is
   type Callback is access procedure (Object : access Base_Type);

   function Connect
     (Obj         : access Gtk.Object.Gtk_Object_Record'Class;
      Name        : in String;
      Func        : in Callback;
      Slot_Object : access Base_Type'Class;
      After       : in Boolean := False)
      return Guint;
end Object_Callback;
\end{verbatim}\end{quote}

Two procedures to destroy a specific or any connection.

\begin{quote}\begin{verbatim}
procedure Disconnect
  (Object     : access Gtk.Object.Gtk_Object_Record'Class;
   Handler_Id : in Guint);

procedure Handlers_Destroy
  (Obj : access Object.Gtk_Object_Record'Class);
\end{verbatim}\end{quote}

%gdk:   type Root_Type is abstract tagged

%Package Gtk.Style:
%   type Gtk_Style_Record is new Root_Type with private;
%   type Gtk_Style is access all Gtk_Style_Record'Class;

%Package Gtk.Object:
%   type Gtk_Object_Record is new Root_Type with private;
%   type Gtk_Object is access all Gtk_Object_Record'Class;

%Package Gtk.Data:
%   type Gtk_Data_Record is new Object.Gtk_Object_Record with private;
%   type Gtk_Data is access all Gtk_Data_Record'Class;

\subsection{Package Gtk.Tooltips}
\begin{quote}\begin{verbatim}
type Gtk_Tooltips_Record is new Gtk.Data.Gtk_Data_Record with private;
type Gtk_Tooltips is access all Gtk_Tooltips_Record'Class;
\end{verbatim}\end{quote}

The message hint that pops up in a little window when the mouse stay
on a widget long enough without moving.

\subsection{Package Gtk.Adjustment}
\begin{quote}\begin{verbatim}
type Gtk_Adjustment_Record is new Data.Gtk_Data_Record with private;
type Gtk_Adjustment is access all Gtk_Adjustment_Record'Class;
\end{verbatim}\end{quote}

These objects allow you to create a link between a scrollbar and a
scrollable widget (text, scrolled\_window).

\subsection{Package Gtk.Widget}
\begin{quote}\begin{verbatim}
type Gtk_Widget_Record is new Object.Gtk_Object_Record with null record;
type Gtk_Widget is access all Gtk_Widget_Record'Class;
\end{verbatim}\end{quote}

Root of the widget tree. Here are a few useful primitives that are inherited
by all the widgets.

\begin{itemize}
\item Destroy the widget
\begin{quote}\begin{verbatim}
procedure Destroy (Widget : access Gtk_Widget_Record);
\end{verbatim}\end{quote}

\item The Widget can be referenced in a resource file under a specified name

\begin{quote}\begin{verbatim}
procedure Set_Name
  (Widget : access Gtk_Widget_Record; Name : in String);
\end{verbatim}\end{quote}

\item The \verb:Widget: is displayed

\begin{quote}\begin{verbatim}
procedure Show (Widget : access Gtk_Widget_Record);
\end{verbatim}\end{quote}

\item The \verb:Widget: and its components are displayed

\begin{quote}\begin{verbatim}
procedure Show_All (Widget : access Gtk_Widget_Record);
\end{verbatim}\end{quote}

\item Hide the \verb:Widget:.

\begin{quote}\begin{verbatim}
procedure Hide (Widget : access Gtk_Widget_Record);
\end{verbatim}\end{quote}

\item To manipulate the color tables (see, e.g \verb:Gdk.Color.White:)

\begin{quote}\begin{verbatim}
function Get_Colormap (Widget : access Gtk_Widget_Record)
  return Gdk_Colormap;

function Get_Default_Colormap return Gdk_Colormap;

procedure Set_Default_Colormap
  (Widget : access Gtk_Widget_Record; Cmap : Gdk_Colormap);
\end{verbatim}\end{quote}
\end{itemize}

%Package Gtk.Separator:
%   type Gtk_Separator_Record is new Gtk.Widget.Gtk_Widget_Record with private;
%   type Gtk_Separator is access all Gtk_Separator_Record'Class;

%Package Gtk.Ruler:
%   type Gtk_Ruler_Record is new Gtk.Widget.Gtk_Widget_Record with private;
%   type Gtk_Ruler is access all Gtk_Ruler_Record'Class;

%Package Gtk.Preview:
%   type Gtk_Preview_Record is new Gtk.Widget.Gtk_Widget_Record with private;
%   type Gtk_Preview is access all Gtk_Preview_Record'Class;

%Package Gtk.Preview:
%   type Gtk_Preview_Info_Record is new Gtk.Widget.Gtk_Widget_Record
%     with private;
%   type Gtk_Preview_Info is access all Gtk_Preview_Info_Record'Class;

%Package Gtk.Progress_Bar:
%   type Gtk_Progress_Bar_Record is new Gtk.Progress.Gtk_Progress_Record
%     with private;
%   type Gtk_Progress_Bar is access all Gtk_Progress_Bar_Record'Class;

%Package Gtk.Misc:
%   type Gtk_Misc_Record is new Widget.Gtk_Widget_Record with private;
%   type Gtk_Misc is access all Gtk_Misc_Record'Class;

%Package Gtk.Pixmap:
%   type Gtk_Pixmap_Record is new Gtk.Misc.Gtk_Misc_Record with private;
%   type Gtk_Pixmap is access all Gtk_Pixmap_Record'Class;

%Package Gtk.Arrow:
%   type Gtk_Arrow_Record is new Gtk.Misc.Gtk_Misc_Record with private;
%   type Gtk_Arrow is access all Gtk_Arrow_Record'Class;

\subsection{Package Gtk.Label}
\begin{quote}\begin{verbatim}
type Gtk_Label_Record is new Misc.Gtk_Misc_Record with private;
type Gtk_Label is access all Gtk_Label_Record'Class;
\end{verbatim}\end{quote}

To put and then modify a string.
A \verb:Gtk_Label: can emit no signal (see \verb:Event_Box: if you want to
connect a signal)\\

Create a new label
\begin{quote}\begin{verbatim}
procedure Gtk_New (Label : out Gtk_Label; Str : in String);
\end{verbatim}\end{quote}

Change the label string
\begin{quote}\begin{verbatim}
procedure Set_Text (Label : access Gtk_Label_Record; Str : in String);
\end{verbatim}\end{quote}

%Package Gtk.Tips_Query:
%   type Gtk_Tips_Query_Record is new Gtk.Label.Gtk_Label_Record with private;
%   type Gtk_Tips_Query is access all Gtk_Tips_Query_Record'Class;

%Package Gtk.Image:
%   type Gtk_Image_Record is new Gtk.Misc.Gtk_Misc_Record with private;
%   type Gtk_Image is access all Gtk_Image_Record'Class;

%Package Gtk.GRange:
%   type Gtk_Range_Record is new Gtk.Widget.Gtk_Widget_Record with private;
%   type Gtk_Range is access all Gtk_Range_Record'Class;

%Package Gtk.Scale:
%   type Gtk_Scale_Record is new Gtk.GRange.Gtk_Range_Record with private;
%   type Gtk_Scale is access all Gtk_Scale_Record'Class;

\subsection{Package Gtk.Scrollbar}
\begin{quote}\begin{verbatim}
type Gtk_Scrollbar_Record is new
  Gtk.GRange.Gtk_Range_Record with private;
type Gtk_Scrollbar is access all Gtk_Scrollbar_Record'Class;
\end{verbatim}\end{quote}

Horizontal or vertical scrollbars that can be associated with the
\verb:Widget: you want to scroll using
\verb:Adjustment: (see, eg \verb:Gtk.Text.Get_Vadj:).

\begin{quote}\begin{verbatim}
procedure Gtk_New_Hscrollbar
  (Widget     : out Gtk_Scrollbar;
   Adjustment : in Gtk.Adjustment.Gtk_Adjustment);

procedure Gtk_New_Vscrollbar
  (Widget     : out Gtk_Scrollbar;
   Adjustment : in Gtk.Adjustment.Gtk_Adjustment);
\end{verbatim}\end{quote}

%Package Gtk.Drawing_Area:
%   type Gtk_Drawing_Area_Record is new Gtk.Widget.Gtk_Widget_Record
%     with private;
%   type Gtk_Drawing_Area is access all Gtk_Drawing_Area_Record'Class;

%Package Gtk.Curve:
%   type Gtk_Curve_Record is new Gtk.Drawing_Area.Gtk_Drawing_Area_Record
%     with private;
%   type Gtk_Curve is access all Gtk_Curve_Record'Class;

\subsection{Package Gtk.Editable}
\begin{quote}\begin{verbatim}
type Gtk_Editable_Record is new
  Gtk.Widget.Gtk_Widget_Record with private;
type Gtk_Editable is access all Gtk_Editable_Record'Class;
\end{verbatim}\end{quote}

Parent of the editable widgets, such as \verb:Text:.

%Package Gtk.GEntry:
%   type Gtk_Entry_Record is new Gtk.Editable.Gtk_Editable_Record with private;
%   type Gtk_Entry is access all Gtk_Entry_Record'Class;

%Package Gtk.Spin_Button:
%   type Gtk_Spin_Button_Record is new Gtk.GEntry.Gtk_Entry_Record with private;
%   type Gtk_Spin_Button is access all Gtk_Spin_Button_Record'Class;

\subsection{Package Gtk.Text}
\begin{quote}\begin{verbatim}
type Gtk_Text_Record is new
  Gtk.Editable.Gtk_Editable_Record with private;
type Gtk_Text is access all Gtk_Text_Record'Class;
\end{verbatim}\end{quote}

To manipulate text.
End of line are marked by a \verb:Ascii.LF:.
When the application modify the text (using, e.g \verb:Insert:), it can first
freeze it (\verb:Freeze:) to prevent any change from the user, then
unfreeze it (\verb:Thaw:) to allow the user to interact again.

\begin{quote}\begin{verbatim}
procedure Gtk_New
  (Widget : out Gtk_Text;
   Hadj   : access Gtk.Adjustment.Gtk_Adjustment_Record'Class
     := Gtk.Adjustment.Null_Adjustment;
   Vadj   : access Gtk.Adjustment.Gtk_Adjustment_Record'Class
     := Gtk.Adjustment.Null_Adjustment);

procedure Freeze (Text : access Gtk_Text_Record);

procedure Thaw (Text : access Gtk_Text_Record);

function Get_Hadj (Widget : access Gtk_Text_Record)
  return Gtk.Adjustment.Gtk_Adjustment;

function Get_Vadj (Widget : access Gtk_Text_Record)
  return Gtk.Adjustment.Gtk_Adjustment;

function Get_Length (Text : in Gtk_Text) return Guint;

procedure Insert
  (Text   : access Gtk_Text_Record;
   Font   : in Gdk.Font.Gdk_Font'Class;
   Fore   : in Gdk.Color.Gdk_Color;
   Back   : in Gdk.Color.Gdk_Color;
   Chars  : in String;
   Length : in Gint);
\end{verbatim}\end{quote}

Inherits primitives from \verb:Gtk.Editable.Gtk_Editable::
\begin{itemize}

\item Destroy a text section
\begin{quote}\begin{verbatim}
procedure Delete_Text
  (Editable  : access Gtk_Editable_Record;
   Start_Pos : in Gint;
   End_Pos   : in Gint);   --  e.g Glib.Gint (Get_Length (...))
\end{verbatim}\end{quote}

\item Get the current postion of the cursor
\begin{quote}\begin{verbatim}
function Get_Current_Pos (Widget : access Gtk_Editable_Record)
  return Guint;
\end{verbatim}\end{quote}
\end{itemize}

\subsection{Package Gtk.Container}
\begin{quote}\begin{verbatim}
type Gtk_Container_Record is new
  Gtk.Widget.Gtk_Widget_Record with private;
type Gtk_Container is access all Gtk_Container_Record'Class;
\end{verbatim}\end{quote}

General notion that permits to create a hierarchical structure of widgets, such
as \verb:Gtk_Box:, \verb:Gtk_Table:, \verb:Gtk_EventBox:, \ldots

\begin{quote}\begin{verbatim}
procedure Add (Container : access Gtk_Container_Record;
               Widget    : access Gtk.Widget.Gtk_Widget_Record'Class);

procedure Set_Border_Width (Container : access Gtk_Container_Record;
                            Border_Width : in Gint);

procedure Remove (Container : access Gtk_Container_Record;
                  Widget    : access Gtk.Widget.Gtk_Widget_Record'Class);
\end{verbatim}\end{quote}

%\subsection{Package Gtk.Toolbar}
%\begin{quote}\begin{verbatim}
%   type Gtk_Toolbar_Record is new Gtk.Container.Gtk_Container_Record
%     with private;
%   type Gtk_Toolbar is access all Gtk_Toolbar_Record'Class;
%\end{verbatim}\end{quote}

\subsection{Package Gtk.Table}
\begin{quote}\begin{verbatim}
type Gtk_Table_Record is new Gtk.Container.Gtk_Container_Record
  with private;
type Gtk_Table is access all Gtk_Table_Record'Class;
\end{verbatim}\end{quote}

To group widgets in a table. The same widget can cover several boxes of the
table. The size of the boxes depend on what they contain.

\begin{quote}\begin{verbatim}
procedure Gtk_New
  (Widget      : out Gtk_Table;
   Rows        : in Glib.Gint;
   Columns     : in Glib.Gint;
   Homogeneous : in Boolean);
\end{verbatim}\end{quote}

If \verb:Homogeneous: is True, all the boxes will have the same size, determined
by the largest widget and the longest widget.
Otherwise, the width of a column (resp. heigh of a row) will be determined
by the largest widget of the column.\\

To attach a widget to a table
\begin{quote}\begin{verbatim}
procedure Attach
  (Table         : access Gtk_Table_Record;
   Child         : access Gtk.Widget.Gtk_Widget_Record'Class;
   Left_Attach   : in Gint;
   Right_Attach  : in Gint;
   Top_Attach    : in Gint;
   Bottom_Attach : in Gint;
   Xoptions      : in Gtk_Attach_Options;
   Yoptions      : in Gtk_Attach_Options;
   Xpadding      : in Gint;
   Ypadding      : in Gint);

procedure Attach_Defaults
  (Table         : access Gtk_Table_Record;
   Widget        : access Gtk.Widget.Gtk_Widget_Record'Class;
   Left_Attach   : in Gint;
   Right_Attach  : in Gint;
   Top_Attach    : in Gint;
   Bottom_Attach : in Gint);
\end{verbatim}\end{quote}

Attach the widget \verb:Child: to the position indicated by
\verb:Left_Attach:, \verb:Right_Attach:, \verb:Top_Attach: and
\verb:Bottom_Attach:.
These indexes start from 0 to the number of column or rows specified at
table creation. The origin (0, 0) of the frontiers is located in upper left.

\begin{quote}\begin{verbatim}
    0          1          2
   0+----------+----------+
    |          |          |
   1+----------+----------+
    |          |          |
   2+----------+----------+
\end{verbatim}\end{quote}

The values of \verb:Xoptions: and \verb:Yoptions: can be a logical {\it or} of
several values:
\begin{description}
\item [Gtk.Enums.Expand] The table will use all the remaining space in the
 window.
\item [Gtk.Enums.Shrink] If the widget has less space than needed, it will
 shrink instead of disappearing.
\item [Gtk.Enums.Fill] The widget take the whole space that has been allocated
 for it.
\end{description}

\verb:Xpadding: and \verb:Ypadding: give the widths in number of pixels of the
 free spaces reserved around the widget.

For the \verb:Attach_Defaults: procedure, the default values of \verb:Xoptions:
and \verb:Yoptions: are equals to \verb:Expand or Fill: and those of
\verb:Xpadding: and \verb:Ypadding: are 0.\\

\subsection{Package Gtk.Scrolled\_Window}
\begin{quote}\begin{verbatim}
type Gtk_Scrolled_Window_Record is new Container.Gtk_Container_Record
  with private;
type Gtk_Scrolled_Window is access all Gtk_Scrolled_Window_Record'Class;
\end{verbatim}\end{quote}

To create a scrollable zone in which you can put any kind of widget, like
e.g a table of buttons.
If the window is too small, all the widgets won't be visible, but they will
remain accessible using the scrollbars.
\begin{quote}\begin{verbatim}
procedure Gtk_New
  (Scrolled_Window :    out Gtk_Scrolled_Window;
   Hadjustment     : access Adjustment.Gtk_Adjustment_Record'Class
     := Adjustment.Null_Adjustment;
   Vadjustment     : access Adjustment.Gtk_Adjustment_Record'Class
     := Adjustment.Null_Adjustment);
\end{verbatim}\end{quote}

Create a \verb:Gtk_Scrolled_Window: by optionally specifying adjustment rules.\\

To get the adjutment rules (to attach scrollbars).
\begin{quote}\begin{verbatim}
function Get_Hadjustment
  (Scrolled_Window : access Gtk_Scrolled_Window_Record)
   return Adjustment.Gtk_Adjustment;

function Get_Vadjustment
  (Scrolled_Window : access Gtk_Scrolled_Window_Record)
   return Adjustment.Gtk_Adjustment;
\end{verbatim}\end{quote}

%Package Gtk.Paned:
%   type Gtk_Paned_Record is new Gtk.Container.Gtk_Container_Record
%     with private;
%   type Gtk_Paned is access all Gtk_Paned_Record'Class;

%Package Gtk.Tree:
%   type Gtk_Tree_Record is new Gtk.Container.Gtk_Container_Record with private;
%   type Gtk_Tree is access all Gtk_Tree_Record'Class;

%Package Gtk.Menu_Shell:
%   type Gtk_Menu_Shell_Record is new Gtk.Container.Gtk_Container_Record
%     with private;
%   type Gtk_Menu_Shell is access all Gtk_Menu_Shell_Record'Class;

%Package Gtk.Menu:
%   type Gtk_Menu_Record is new Gtk.Menu_Shell.Gtk_Menu_Shell_Record
%     with private;
%   type Gtk_Menu is access all Gtk_Menu_Record'Class;

%Package Gtk.Menu_Bar:
%   type Gtk_Menu_Bar_Record is new Gtk.Menu_Shell.Gtk_Menu_Shell_Record
%     with private;
%   type Gtk_Menu_Bar is access all Gtk_Menu_Bar_Record'Class;

%Package Gtk.List:
%   type Gtk_List_Record is new Gtk.Container.Gtk_Container_Record with private;
%   type Gtk_List is access all Gtk_List_Record'Class;

%Package Gtk.Fixed:
%   type Gtk_Fixed_Record is new Gtk.Container.Gtk_Container_Record
%     with private;
%   type Gtk_Fixed is access all Gtk_Fixed_Record'Class;

\subsection{Package Gtk.Notebook}
\begin{quote}\begin{verbatim}
type Gtk_Notebook_Record is new Gtk.Container.Gtk_Container_Record
  with private;
type Gtk_Notebook is access all Gtk_Notebook_Record'Class;
\end{verbatim}\end{quote}

The NoteBook Widget is a collection of {\em pages} that overlap each other,
each page containing different information.
This widget has become more common lately in GUI programming,
and it is a good way to show blocks similar information that warrant
separation in their display. 

%Package Gtk.CList:
%   type Gtk_Clist_Record is new Gtk.Container.Gtk_Container_Record
%     with private;
%   type Gtk_Clist is access all Gtk_Clist_Record'Class;

\subsection{Package Gtk.Box}
\begin{quote}\begin{verbatim}
type Gtk_Box_Record is new
  Gtk.Container.Gtk_Container_Record with private;
type Gtk_Box is access all Gtk_Box_Record'Class;
subtype Gtk_Vbox is Gtk_Box;
subtype Gtk_Hbox is Gtk_Box;
\end{verbatim}\end{quote}

Horizontal (\verb:Gtk_New_Hbox:) and vertical (\verb:Gtk_New_Vbox:) boxes
that can contain several widgets.
you can add widgets from

\begin{itemize}
\item the left to the right starting from the beginning (\verb:pack_start:)
\item the right to the left, starting from the end (\verb:pack_end:)
\end{itemize}

\begin{quote}\begin{verbatim}
procedure Gtk_New_Vbox
  (Box         : in out Gtk_Box;
   Homogeneous : in  Boolean;
   Spacing     : in  Gint);
procedure Initialize_Vbox
  (Box         : access Gtk_Box_Record;
   Homogeneous : in  Boolean;
   Spacing     : in  Gint);

procedure Gtk_New_Hbox
  (Box         : in out Gtk_Box;
   Homogeneous : in  Boolean;
   Spacing     : in  Gint);A
procedure Initialize_Hbox
  (Box         : access Gtk_Box_Record;
   Homogeneous : in  Boolean;
   Spacing     : in  Gint);

procedure Pack_Start
  (In_Box  : access Gtk_Box_Record;
   Child   : access Gtk.Widget.Gtk_Widget_Record'Class;
   Expand  : in Boolean := True;
   Fill    : in Boolean := True;
   Padding : in Gint    := 0);
\end{verbatim}\end{quote}

See also \verb:Gtk_Table:

%Package Gtk.Status_Bar:
%   type Gtk_Status_Bar_Record is new Gtk.Box.Gtk_Box_Record with private;
%   type Gtk_Status_Bar is access all Gtk_Status_Bar_Record'Class;

%Package Gtk.Color_Selection:
%   type Gtk_Color_Selection_Record is new Gtk.Box.Gtk_Box_Record with private;
%   type Gtk_Color_Selection is access all Gtk_Color_Selection_Record'Class;

%Package Gtk.Button_Box:
%   type Gtk_Button_Box_Record is new Gtk.Box.Gtk_Box_Record with private;
%   type Gtk_Button_Box is access all Gtk_Button_Box_Record'Class;

%Package Gtk.VButton_Box:
%   type Gtk_VButton_Box_Record is new Gtk.Button_Box.Gtk_Button_Box_Record
%     with private;
%   type Gtk_VButton_Box is access all Gtk_VButton_Box_Record'Class;

%Package Gtk.HButton_Box:
%   type Gtk_Hbutton_Box_Record is new Gtk.Button_Box.Gtk_Button_Box_Record
%     with private;
%   type Gtk_Hbutton_Box is access all Gtk_Hbutton_Box_Record'Class;

%Package Gtk.Gamma_Curve:
%   type Gtk_Gamma_Curve_Record is new Gtk.Box.Gtk_Box_Record with private;
%   type Gtk_Gamma_Curve is access all Gtk_Gamma_Curve_Record'Class;

%Package Gtk.Combo:
%   type Gtk_Combo_Record is new Gtk.Box.Gtk_Box_Record with private;
%   type Gtk_Combo is access all Gtk_Combo_Record'Class;

\subsection{Package Gtk.Button}
\begin{quote}\begin{verbatim}
type Gtk_Button_Record is new Bin.Gtk_Bin_Record with private;
type Gtk_Button is access all Gtk_Button_Record'Class;
\end{verbatim}\end{quote}

A simple button with a label and signals {e.g \em clicked}.

%Package Gtk.Option_Menu:
%   type Gtk_Option_Menu_Record is new Button.Gtk_Button_Record with private;
%   type Gtk_Option_Menu is access all Gtk_Option_Menu_Record'Class;

\subsection{Package Gtk.Toggle\_Button}
\begin{quote}\begin{verbatim}
type Gtk_Toggle_Button_Record is new Gtk.Button.Gtk_Button_Record
  with private;
type Gtk_Toggle_Button is access all Gtk_Toggle_Button_Record'Class;
\end{verbatim}\end{quote}

Toggle buttons are very similar to normal buttons, except they will always
be in one of two states, alternated by a click. They may be depressed,
and when you click again, they will pop back up.  Click again, and they will
pop back down.

\subsection{Package Gtk.Check\_Button}
\begin{quote}\begin{verbatim}
type Gtk_Check_Button_Record is new
  Toggle_Button.Gtk_Toggle_Button_Record with private;
type Gtk_Check_Button is access all Gtk_Check_Button_Record'Class;
\end{verbatim}\end{quote}

Check buttons inherit many properties and functions from the the toggle
buttons above, but look a little different.
Rather than being buttons with text inside them, they are small squares with
the text to the right of them. These are often seen for toggling
options on and off in applications. 

%Package Gtk.Radio_Button:
%  type Gtk_Radio_Button is new Check_Button.Gtk_Check_Button with private;
\subsection{Package Gtk.Bin}
\begin{quote}\begin{verbatim}
type Gtk_Bin is new Container.Gtk_Container with private;
\end{verbatim}\end{quote}

%Package Gtk.Item:
%   type Gtk_Item_Record is new Bin.Gtk_Bin_Record with private;
%   type Gtk_Item is access all Gtk_Item_Record'Class;

%Package Gtk.List_Item:
%   type Gtk_List_Item_Record is new Gtk.Item.Gtk_Item_Record with private;
%   type Gtk_List_Item is access all Gtk_List_Item_Record'Class;

%Package Gtk.Menu_Item:
%   type Gtk_Menu_Item_Record is new Item.Gtk_Item_Record with private;
%   type Gtk_Menu_Item is access all Gtk_Menu_Item_Record'Class;

%Package Gtk.Check_Menu_Item:
%   type Gtk_Check_Menu_Item_Record is new Gtk.Menu_Item.Gtk_Menu_Item_Record
%     with private;
%   type Gtk_Check_Menu_Item is access all Gtk_Check_Menu_Item_Record'Class;

%Package Gtk.Radio_Menu_Item:
%   type Gtk_Radio_Menu_Item_Record
%      is new Gtk.Check_Menu_Item.Gtk_Check_Menu_Item_Record with private;
%   type Gtk_Radio_Menu_Item is access all Gtk_Radio_Menu_Item_Record'Class;

%Package Gtk.Tree_Item:
%   type Gtk_Tree_Item_Record is new Gtk.Item.Gtk_Item_Record with private;
%   type Gtk_Tree_Item is access all Gtk_Tree_Item_Record'Class;

%Package Gtk.Handle_Box:
%   type Gtk_Handle_Box_Record is new Gtk.Bin.Gtk_Bin_Record with private;
%   type Gtk_Handle_Box is access all Gtk_Handle_Box_Record'Class;

%Package Gtk.Frame:
%   type Gtk_Frame_Record is new Gtk.Bin.Gtk_Bin_Record with private;
%   type Gtk_Frame is access all Gtk_Frame_Record'Class;

%Package Gtk.Aspect_Frame:
%   type Gtk_Aspect_Frame_Record is new Gtk.Frame.Gtk_Frame_Record with private;
%   type Gtk_Aspect_Frame is access all Gtk_Aspect_Frame_Record'Class;

\subsection{Package Gtk.Event\_Box}
\begin{quote}\begin{verbatim}
type Gtk_Event_Box_Record is new Gtk.Bin.Gtk_Bin_Record with private;
type Gtk_Event_Box is access Gtk_Event_Box_Record'Class;
\end{verbatim}\end{quote}

To associate a callback or clip a widget that is not able to do it, like
labels for example.

\begin{quote}\begin{verbatim}
procedure Gtk_New (Widget : out Gtk_Event_Box);
\end{verbatim}\end{quote}

This widget is a child of \verb:Gtk_Container: and inherits in particular of:

\begin{quote}\begin{verbatim}
procedure Add (Container : access Gtk_Container_Record;
               Widget    : access Gtk.Widget.Gtk_Widget_Record'Class);
\end{verbatim}\end{quote}

%Package Gtk.Viewport:
%   type Gtk_Viewport_Record is new Gtk.Bin.Gtk_Bin_Record with private;
%   type Gtk_Viewport is access all Gtk_Viewport_Record'Class;

\subsection{Package Gtk.Window}
\begin{quote}\begin{verbatim}
type Gtk_Window_Record is new Bin.Gtk_Bin_Record with private;
type Gtk_Window is access all Gtk_Window_Record'Class;
\end{verbatim}\end{quote}

The base window, emits the signals \verb:"destroy":, \verb:"delete_event":.

%Package Gtk.Color_Selection_Dialog:
%   type Gtk_Color_Selection_Dialog_Record is new Gtk.Window.Gtk_Window_Record
%     with private;
%   type Gtk_Color_Selection_Dialog
%     is access all Gtk_Color_Selection_Dialog_Record'Class;

\subsection{Package Gtk.File\_Selection}
\begin{quote}\begin{verbatim}
type Gtk_File_Selection_Record is new Gtk.Window.Gtk_Window_Record
  with private;
type Gtk_File_Selection is access all Gtk_File_Selection_Record'Class;
\end{verbatim}\end{quote}

To select a file in the directories tree. Nothing special to know about
it, just use it!
There are three buttons \verb:Ok:, \verb:Cancel: and \verb:Help:.
You can modify these buttons (e.g change the labels, connect callbacks, \ldots)
with the various \verb:Get_..._Button: functions.\\

\begin{quote}\begin{verbatim}
procedure Gtk_New
  (File_Selection : out Gtk_File_Selection; Title : in String);
\end{verbatim}\end{quote}

To associate a callback with the buttons of the file selector:
\begin{quote}\begin{verbatim}
function Get_Ok_Button
  (File_Selection : access Gtk_File_Selection_Record)
   return Gtk.Button.Gtk_Button;

function Get_Cancel_Button
  (File_Selection : access Gtk_File_Selection_Record)
   return Gtk.Button.Gtk_Button;
\end{verbatim}\end{quote}

To consult or set the filename:
\begin{quote}\begin{verbatim}
function Get_Filename (File_Selection : access Gtk_File_Selection_Record)
  return String;

procedure Set_Filename
  (File_Selection : access Gtk_File_Selection_Record;
   Filename : in String);
\end{verbatim}\end{quote}

To hide the file manipulation buttons (destruction, \ldots):

\begin{quote}\begin{verbatim}
procedure Hide_Fileop_Buttons
  (File_Selection : access Gtk_File_Selection_Record);
\end{verbatim}\end{quote}

%Package Gtk.Dialog:
%   type Gtk_Dialog_Record is new Gtk.Window.Gtk_Window_Record with private;
%   type Gtk_Dialog is access all Gtk_Dialog_Record'Class;

%Package Gtk.Input_Dialog:
%   type Gtk_Input_Dialog_Record is new Dialog.Gtk_Dialog_Record with private;
%   type Gtk_Input_Dialog is access all Gtk_Input_Dialog_Record'Class;

%Package Gtk.Alignment:
%   type Gtk_Alignment_Record is new Gtk.Bin.Gtk_Bin_Record with private;
%   type Gtk_Alignment is access Gtk_Alignment_Record'Class;

\subsection{Package Gtk.Enums}
This package defines all the enumerated types used by the GTK hierarchy.

%\begin{quote}\begin{verbatim}
% type Gtk_State_Type is (State_Normal,
% type Gtk_Window_Type is (Window_Toplevel,
% type Gtk_Button_Action is new Guint;
% type Gtk_Button_Box_Style is (Default_Style, Spread,
% type Gtk_Direction_Type is (Dir_Tab_Forward,
% type Gtk_Shadow_Type is (Shadow_None,
% type Gtk_Arrow_Type is (Arrow_Up,
% type Gtk_Cell_Type is (Cell_Empty,
% type Gtk_Pack_Type is (Pack_Start, Pack_End);
% type Gtk_Policy_Type is (Policy_Always,
% type Gtk_Update_Type is (Update_Continuous,
% type Gtk_Relief_Style is (Relief_Normal,
% type Gtk_Attach_Options is new Glib.Guint32;
% type Gtk_Window_Position is (Win_Pos_None,
% type Gtk_Submenu_Direction is (Direction_Left,
% type Gtk_Submenu_Placement is (Top_Bottom,
% type Gtk_Menu_Factory_Type is (Menu_Factory_Menu,
% type Gtk_Resize_Mode is (Resize_Parent,
% type Gtk_Metric_Type is (Pixels,
% type Gtk_Scroll_Type is (Scroll_None,
% type Gtk_Trough_Type is (Trough_None,
% type Gtk_Position_Type is (Pos_Left,
% type Gtk_Preview_Type is (Preview_Color,
% type Gtk_Justification is (Justify_Left,
% type Gtk_Selection_Mode is (Selection_Single,
% type Gtk_Orientation is (Orientation_Horizontal,
% type Gtk_Spin_Button_Update_Policy is (Update_Always,
% type Gtk_Toolbar_Child_Type is (Toolbar_Child_Space,
% type Gtk_Toolbar_Style is (Toolbar_Icons,
% type Gtk_Toolbar_Space_Style is (Toolbar_Space_Empty,
% type Gtk_Tree_View_Mode is (Tree_View_Line,
% type Gtk_Visibility is (Visibility_None,
% type Gtk_Progress_Bar_Style is (Progress_Continuous,
% type Gtk_Progress_Bar_Orientation is (Progress_Left_To_Right,
%\end{verbatim}\end{quote}

\section{Description of the GDK hierarchy}
GTK is based on a lower level layer called GDK that contains some simple
drawing and window primitives.

%Color types and table of colors:
\subsection{Package Gdk.Color}
\begin{quote}\begin{verbatim}
type Gdk_Color is private;
type Gdk_Colormap is new Root_Type with private;
\end{verbatim}\end{quote}

Allows one to get black and white colors by asking the
\verb:Gdk_Colormap: of a widget:
\begin{quote}\begin{verbatim}
function White (Colormap : in Gdk_Colormap) return Gdk_Color;
function Black (Colormap : in Gdk_Colormap) return Gdk_Color;
Wrong_Color : exception;
\end{verbatim}\end{quote}

See for example \verb:Get_Default_Colormap:

\section{Description of the Glib hierarchy}

Glib is the low-level layer and provides various types such as
\verb:Gint:, \verb:Guint:, \ldots.\\

%Glib.XML

\section{Creating and Binding new widgets}

New since version 0.6, GtkAda has now a basic support for creating new
widgets directly in Ada (although you can't create your own signals
yet, we are still working on it).

Since GtkAda has an Object Oriented conception (well, at least you can
program by extension), it is easy, if you want to associate your
own data with a widget, to create your own type. Please see the
examples below. You should also have a look at the \verb:testgtk/:
 directory.

We provide a Perl script to help you create a binding to a C widget
(this is the script we have used ourselves).  This will not fully
automate the process, although it should really speed things up. You
will probably need less than 15 min to create a new binding once you
will get used to the way GtkAda works. Note that your C file should
have the same format as the one used by Gtk+ itself.

Here are the steps to create a new binding:

\begin{itemize}
\item Give the \verb:generate.pl: script the C header file

\item The perl script should ask you for every field in the C structure if
you want to create a function to make it accessible from Ada. Answer
{\em y} or {\em n} (the default value is {\em n}, just press ENTER).

\begin{quote}\begin{verbatim}
$ perl generate.pl ../include/gtk/gtkbutton.h > temporary
  Create a function for the field child (of type GtkWidget*) [n]?
  Create a function for the field in_button (of type guint) [n]?
  Create a function for the field button_down (of type guint) [n]?
\end{verbatim}\end{quote}

\item If you answered yes to at least one of the above questions, create a
new C file, and move the C part of the {\em temporary} file created  by
generate.pl to this C file.

\item Do a gnatchop on the {\em temporary} file created by generate.pl

\begin{quote}\begin{verbatim}
$ gnatchop temporary
\end{verbatim}\end{quote}

This should create two Ada files (specification and body)

\item Edit these two files if needed (generally to change some parameters
  from Gint to Boolean for instance). It can be a little bit tricky
  when one of your functions returns a GList* or a GSList*. Please have
  a look at gtk-combo.ads for examples how to do this.
\end{itemize}

\section{Threads}

The 1.2 series of Gtk+ are now thread safe. The
usage of tasks inside programs using this binding should not cause any
problem although we have not tested it ourselves.\\

We recommend however that you read the section related to this topic in the
GTK+ documentation.

\section{How to report bugs}

This library is still considered beta code, and it is thus likely that
you will  find bugs.  We  have tried to  test it as much  as possible,
essentially  by  converting  the  testgtk.c  file  found  in  the  gtk
distribution.   We   have  been  able   to  rewrite  nearly   all  the
tests. Please have a look at the  testgtk, which can give you a lot of
examples of how to use this binding.\\

For more general questions about gtk itself, please ask your questions
to the  gtk  mailing list. The  authors of  this binding  are far from
beeing specialists of gtk, as it was one of our first project with gtk.\\

There are two kinds of problems you can encounter:
\begin{itemize}
\item If the gtk library itself was compiled with warnings turned on, you
may get some  warnings messages,  mainly because of types problems.
These warnings should not appear, as we have tried to be as type safe
as possible  in this package. To know exactly where the problem is,
compile your program with debug information, run gdb, and set a
breakpoint on the function \verb:g_warning:. Then run your program as usual,
using the {\em run} command. Then send us the result of the {\em where}
command. Here is a summary:

\begin{quote}\begin{verbatim}
$ gnatmake -f -g <your_program_name> `gtkada-config`
$ gdb <your_program_name>
(gdb) break main
(gdb) run
(gdb) break g_warning
(gdb) continue
....
(gdb) where
\end{verbatim}\end{quote}

\item In  some  (hopefully) rare cases,   you can even get a  segmentation
fault  within gtk.  That  means there is  definitevly  something wrong
either  your program  or   the  binding.  Please  check   your program
carefully, and if you think this is a problem in  the binding, send us
an e-mail.
\end{itemize}

To  report errors,  send a  mail  to all  the authors  (see the AUTHORS
file distributed with GtkAda) explaining exactly what your
are  doing,  what  it  the  expected  result  and  what  you  actually
get. Please include the required sources to reproduce the problem, in
a  format usable  by {\em gnatchop}  (basically, insert  all  the required
sources at  the end of  the mail). Please  try to provide a  subset of
your sources as small as possible.\\

Of course, we will  welcome any patch   you can provide, so  that this
binding is as useful as possible.

\section{New tagged type scheme}

GtkAda 0.6 is an almost complete rewrite of GtkAda. Whereas widgets
used to be record types, they now are implemented as access types.
This change has two benefits:
\begin{itemize}
\item It is now clearer, when you pass an object to a function or as
  an argument to a callback, that you are still working with the
  widget you created before.
\item Most important, it is now possible to extend existing types directly
  in Ada (see the section below).
\end{itemize}

Your existing code might have to be modified a little though (sorry
about that, this is for the better!).
\begin{itemize}
\item Although \verb:Gtk_New: now creates access types (and allocate memory for
  them), you do not have to free this memory yourself. This is
  automatically taken care of by gtk itself, which is one of the
  strong points of the new scheme.
\item The only part of your code that is actually modified are the
  callbacks. The changes should be easy to handle (We did it
  for testgtk itself :-).
  When instanciating a callback generic, the first parameter should be
  modified like this:

\begin{quote}\begin{verbatim}
package My_Cb is new Signal.Void_Callback (Gtk_Widget_Record);
                                                     ^^^^^^^
\end{verbatim}\end{quote}

  Then you have to modify the spec of the subprogram iself:

\begin{quote}\begin{verbatim}
procedure My_Func (Button : access Gtk.Button.Gtk_Button_Record;
                   Data   : in Gint);
\end{verbatim}\end{quote}

  Note that the first parameter is an anonymous access to a record
  type, and the second parameter is an "in" parameter.
\end{itemize}

The last things that have changed in this new version of the binding are some
of the names of the parameters in the subprograms of the bindings. This
is part of a major cleanup we are doing so that things can be more
homogeneous within GtkAda.

\section{Using tagged types to extend Gtk widgets}

Since version 0.6 of this binding, it is possible to associate your
own data with existing widgets, simply by creating new types. This
file will show you a simple example, but you should rather read the
source code in testgtk/ where we used this feature instead of using
\verb:user_data: as in the C version.

\begin{quote}\begin{verbatim}
type My_Button_Record is new Gtk_Button_Record with record
    --  whatever data you want to associate with your button
end record;
type My_Button is access all My_Button_Record'Class;
\end{verbatim}\end{quote}

With the above statements, your new type is defined. Every function
available for \verb:Gtk_Button: is also available for \verb:My_Button:.
Of course, as with every tagged type in Ada, you can create your own
primitive functions, with the following prototype:

\begin{quote}\begin{verbatim}
procedure My_Primitive_Func (Myb : access My_Button_Record);
\end{verbatim}\end{quote}

To instanciate an object of type \verb:My_Button: in your application, do
the following:

\begin{quote}\begin{verbatim}
declare
   Myb : My_Button;
begin
   Myb := new My_Button_Record;
   Initialize (Myb);   --  from Gtk.Button
end;
\end{verbatim}\end{quote}

The first line creates the Ada type, whereas the {\em Initialize} call
actually creates the C widget and associate with the Ada type.

\section{Support for Glade, the Gtk GUI builder}

GtkAda now comes with a support for the GUI builder Glade (this is not
the glade released with Gnat for distributed systems).
Not all widgets are supported yet, but we eventually hope to have all
of them. If you really need one, it is easy to add the two required
functions \ldots \\

We actually provide two versions: a dynamic one and a static one. In
both cases, you first need to get and install glade (http://glade.pn.org).
Then start a new project (or edit an old one). It is easy enough to use,
simply select the widget you want to add to your interface, and click!\\

For now, you can not directly create Ada files from Glade (although this
should be in the next version). In the meanwhile, save your project as
an XML file.\\

\begin{itemize}
\item DGATE is the dynamic version of our support. This is an Ada program
that takes the XML file in argument. It also provides default
callbacks for your application, we recommand using it while you are
trying to design your interface.

\item GATE is the static version of our support. This tool
takes the XML file in argument and generates a set of Ada files that,
when compiled, will recreate the interface you just designed with Glade.
\end{itemize}

The most important file created by Gate is called
\verb:callback_<project_name>.adb:.
It contains stubs for all the callbacks you declared in Glade.\\

Note that you can easily go back to Glade any time, modify your interface,
and have GATE re-generate a set of files. All your modifications will be
kept in the new files. For that, GATE creates a directory \verb:.gate/: in the
current directory. Please do not delete it if you want GATE to be able to
keep your changes from one version to the next.\\

Also note that to be able to keep track of your modifications, gate
relies on \verb:patch: and \verb:diff: being available on your system.
If you don't have a working set of \verb:diff:/\verb:patch:, \verb:configure:
will simply replace them by null operations.\\

\section{A complete example}
A window is created with 3 buttons that shows the 3 different types of
callbacks provided.
One interesting thing is that \verb:Callbacks.Bye: is
connected three times: on the \verb:"Quit": button and two times on the
main window.
\begin{quote}\begin{verbatim}
with Gtk.Signal;
with Gtk.Button;
with Gtk.Window;

package Callbacks is

   package Button_Callback is new Gtk.Signal.Void_Callback
     (Widget_Type => Gtk.Button.Gtk_Button);
   procedure Increment (Widget : in out Gtk.Button.Gtk_Button);

   package Button_Message is new Gtk.Signal.Callback
     (Widget_Type => Gtk.Button.Gtk_Button,
      Data_Type => String);

   procedure Message
     (Widget : in out Gtk.Button.Gtk_Button; Data : in out String);

   package Window_Callback is new Gtk.Signal.Object_Callback
     (Widget_Type => Gtk.Window.Gtk_Window);

   procedure Bye (Window : in out Gtk.Window.Gtk_Window);

end Callbacks;

with Gtk.Main;
with Ada.Text_Io;

package body Callbacks is

   Counter : Natural := 0;

   procedure Increment (Widget : in out Gtk.Button.Gtk_Button) is
   begin
      Counter := Counter + 1;
      Ada.Text_Io.Put_Line (Natural'Image (compteur));
   end Increment;

   procedure Message
     (Widget : in out Gtk.Button.Gtk_Button; Data : in out String) is
   begin
      Ada.Text_Io.Put_Line (Data);
   end Message;

   procedure Bye (Window : in out Gtk.Window.Gtk_Window) is
   begin
      Gtk.Window.Destroy (Window);
      Gtk.Main.Main_Quit;
   end Bye;

end Callbacks;

with Gtk.Rc;
with Gtk.Main;
with Gtk.Enums;
with Gtk.Window;
with Gtk.Box;
with Gtk.Label;
with Gtk.Button;
with Callbacks;
with Glib;

procedure Example is

   procedure Fix_Label (Box : in out Gtk.Box.Gtk_Box; Str : String) is
      Label : Gtk.Label.Gtk_Label;
   begin
      Gtk.Label.Gtk_New (Label => Label, Str => Str);
      Gtk.Box.Pack_Start
        (In_Box => Box, Child => Label, Expand => False, Fill => False);
   end Fix_Label;

   procedure Create_Box (W : in out Gtk.Window.Gtk_Window; Str : String) is
      Box    : Gtk.Box.Gtk_Box;
      Button : Gtk.Button.Gtk_Button;
      Cb_Id  : Glib.Guint;

   begin
      Gtk.Box.Gtk_New_Vbox
        (Widget => Box, Homogeneous => True, Spacing => 0);
      Gtk.Window.Add (Container => W, Widget => Box);

      Fix_Label (Box, Str);

      Gtk.Button.Gtk_New (Widget => Button, Label => "Increment");
      Gtk.Box.Pack_Start (In_Box => Box, Child => Button);
      Cb_Id := Callbacks.Button_Callback.Connect
        (Obj => Button,
         Name => "clicked",
         Func => Callbacks.Increment'Access);

      Gtk.Button.Gtk_New (Widget => Button, Label => "Message");
      Gtk.Box.Pack_Start (In_Box => Box, Child => Button);
      Cb_Id := Callbacks.Button_Message.Connect
        (Obj => Button,
         Name => "clicked",
         Func => Callbacks.Message'Access,
         Func_Data => "Button message clicked");

      Gtk.Button.Gtk_New (Widget => Button, Label => "Quit");
      Gtk.Box.Pack_Start (In_Box => Box, Child => Button);
      Cb_Id := Callbacks.Window_Callback.Connect
        (Obj => Button,
         Name => "clicked",
         Func => Callbacks.Bye'Access,
         Slot_Object => W);
   end Create_Box;

   procedure Window is
      Main_Window : Gtk.Window.Gtk_Window;
      Cb_Id : Glib.Guint;

   begin
      Gtk.Window.Gtk_New
        (Window => Main_Window, The_Type => Gtk.Enums.Window_Toplevel);

      --  Inherited from Gtk.Widget:

      Gtk.Window.Set_Title (Window => Main_Window, Title => "Some Title");
      Create_Box (Main_Window, "my box") ;

      --  Connect the Callbacks

      Cb_Id := Callbacks.Window_Callback.Connect
        (Obj => Main_Window,
         Name => "destroy",
         Func => Callbacks.Bye'Access,
         Slot_Object => Main_Window);
      Cb_Id := Callbacks.Window_Callback.Connect
        (Obj => Main_Window,
         Name => "delete_event",
         Func => Callbacks.Bye'Access,
         Slot_Object => Main_Window);
      Gtk.Window.Show_All (Main_Window);
   end Window;

begin
   Gtk.Main.Set_Locale;
   Gtk.Main.Init;
   Gtk.Rc.Parse ("example.rc"); 
   Window;
   Gtk.Main.Main;
end Example;
\end{verbatim}\end{quote}

\section{Widgets Hierarchy}

The simple rule followed by GtkAda to implement each widget is the following:
Given a widget \verb:Gtk_Xxx:, its definition can be found in the package
\verb:Gtk.Xxx: in the file \verb:gtk-xxx.ads:.

For example, the \verb:Gtk_Text: type is defined in package
\verb:Gtk.Text: located in the file \verb:gtk-text.ads:.

Here is the complete hierarchy of Gtk widgets:

\begin{quote}\begin{verbatim}
Gtk_Object

   Gtk_Data
      Gtk_Tooltips
      Gtk_Adjustment

   Gtk_Widget
      Gtk_Separator
      Gtk_Ruler
      Gtk_Preview
      Gtk_Preview_Info
      Gtk_Progress_Bar
      Gtk_Misc
         Gtk_Arrow
         Gtk_Image
         Gtk_Label
            Gtk_Tips_Query
         Gtk_Pixmap

      Gtk_Range
         Gtk_Scale
         Gtk_Scrollbar

      Gtk_Drawing_Area
         Gtk_Curve

      Gtk_Editable
         Gtk_Entry
            Gtk_Spin_Button
         Gtk_Text

      Gtk_Container
         Gtk_Box
         Gtk_Button
            Gtk_Option_Menu
            Gtk_Toggle_Button
               Gtk_Check_Button
                  Gtk_Radio_Button
         Gtk_Toolbar
         Gtk_Table
         Gtk_Scrolled_Window
         Gtk_Paned
         Gtk_Tree
         Gtk_Menu_Shell
            Gtk_Menu
            Gtk_Menu_Bar
         Gtk_List
         Gtk_Fixed
         Gtk_Notebook
         Gtk_CList
            Gtk_Button_Box
               Gtk_VButton_Box
               Gtk_HButton_Box
            Gtk_Color_Selection
            Gtk_Combo
            Gtk_Gamma_Curve
            Gtk_Status_Bar
         Gtk_Bin
            Gtk_Alignment
            Gtk_Event_Box
            Gtk_Frame
               Gtk_Aspect_Frame
            Gtk_Handle_Box
            Gtk_Item
               Gtk_Tree_Item
               Gtk_List_Item
               Gtk_Menu_Item
                  Gtk_Check_Menu_Item
                     Gtk_Radio_Menu_Item
            Gtk_Viewport
            Gtk_Window
               Gtk_Color_Selection_Dialog
               Gtk_File_Selection
               Gtk_Dialog
                  Gtk_Input_Dialog
\end{verbatim}\end{quote}
\end{document}
